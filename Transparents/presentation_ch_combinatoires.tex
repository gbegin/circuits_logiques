% Created 2024-03-01 ven 08:21
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[, french]{babel}
\usepackage{svg}
\logo{\includegraphics[width=.1\textwidth]{../by-sa.png}}
\AtBeginEnvironment{minted}{\renewcommand{\fcolorbox}[4][]{#4}}
\usetheme{metropolis}
\usecolortheme{}
\usefonttheme{}
\useinnertheme{}
\useoutertheme{}
\author{Guy Bégin}
\date{\today}
\title{Circuits logiques combinatoires et séquentiels}

\hypersetup{
 pdfauthor={Guy Bégin},
 pdftitle={Circuits logiques combinatoires et séquentiels},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.5.2)}, 
 pdflang={French}}
\begin{document}

\maketitle

\section{Circuits combinatoires typiques}
\label{sec:orgaa52962}

\begin{frame}[label={sec:org631176e}]{Objectifs}
\begin{itemize}
\item Analyser un circuit combinatoire à partir de son schéma
\item Concevoir un circuit combinatoire à partir d'une spécification
\item Connaître différentes approches de réalisation
\item Se familiariser avec les principaux circuits combinatoires courants et
leurs fonctions: additionneur, décodeur, multiplexeur, encodeur,
comparateur
\item Comprendre le fonctionnement d'une chaîne d'addition binaire et les
mécanismes de propagation et d'anticipation de retenue
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgf5fa6ee}]{Circuit combinatoire}
\begin{itemize}
\item Un circuit logique combinatoire est une combinaison de portes logiques dont la sortie à un instant donné ne dépend que des valeurs des entrées à cet instant.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org42cad15}]{Circuit combinatoire \ldots{} 2}
\begin{itemize}
\item Un circuit combinatoire à \(n\) entrées et \(m\) sorties peut être représenté par un schéma-bloc, dans lequel on place généralement les entrées à gauche et les sorties à droite.
\end{itemize}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{../Images_png/circuit_comb.png}
\caption{\label{fig:org6031571}Circuit combinatoire}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org7d00cb2}]{Circuit combinatoire}
\begin{itemize}
\item Avec \(n\) entrées, il est possible de créer \(2^n\) combinaisons différentes des entrées binaires.

\item Pour chaque combinaison, le circuit peut donner une sortie 0 ou 1.

\item On peut donc préciser la fonction réalisée par le circuit au moyen d'un tableau de vérité comportant \(2^n\) lignes.

\item Comme nous avons \(m\) sorties différentes, il y aura \(m\) colonnes dans le tableau de vérité pour les fonctions de sortie.

\item Traditionnellement, on présente les entrées en ordre croissant de combinaisons binaires.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org67c02b8}]{Analyse d'un circuit logique combinatoire}
\begin{itemize}
\item Si on se trouve devant le schéma d'un circuit logique dont on ne connaît pas la fonction, on doit en faire l'analyse.

\item La première étape consiste à vérifier qu'il s'agit bien d'un circuit combinatoire.

\item Si le schéma ne comporte pas de cellules de mémoire ou de boucles de rétroaction, on peut conclure que le circuit est combinatoire.

\item Une boucle de rétroaction consiste en un chemin du circuit par lequel une valeur d'entrée d'une porte provient, directement ou indirectement (par l'intermédiaire d'autres portes), de la sortie de la même porte.

\item La présence de rétroaction est une caractéristique des circuits logiques séquentiels, que nous étudierons plus loin.
\end{itemize}
\end{frame}


\begin{frame}[label={sec:org205a2b4}]{Analyse d'un circuit logique combinatoire \ldots{} 2}
\begin{itemize}
\item Pour interpréter le comportement du circuit, nous devons déterminer les expressions logiques qu'il met en oeuvre ou établir son tableau de vérité.
\end{itemize}


Pour déterminer l'expression logique, on procède ainsi:
\begin{enumerate}
\item Étiqueter toutes les sorties des portes qui sont alimentées par les
variables d'entrée du système. Les noms de variables seront
arbitraires, mais devraient être choisis de façon à faciliter
l'interprétation par la suite. Déterminer les fonctions logiques
pour ces variables.
\item Étiqueter les sorties des portes qui sont alimentées par les
variables d'entrée et par les sorties étiquetées à l'étape
précédente. Déterminer les fonctions logiques pour ces nouvelles
variables.
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:orgf4d455f}]{Analyse d'un circuit logique combinatoire \ldots{} 3}
\begin{enumerate}
\setcounter{enumi}{2}
\item Répéter l'étape 2 jusqu'à arriver aux variables de sortie du système.
\item En substituant les expressions logiques des fonctions identifiées,
déterminer l'expression logique pour les sorties du système en
fonction des entrées du système.
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:org6b59d92}]{Exemple d'analyse d'un circuit logique combinatoire}
Analysons le circuit combinatoire illustré à la figure
suivante.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circuit_logique_inconnu}
\caption{\label{fig:org0575236}Circuit combinatoire à analyser}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgbf8714f}]{Exemple d'analyse d'un circuit logique combinatoire \ldots{} 2}
\begin{enumerate}
\item Il n'est pas la peine d'étiqueter la sortie de la porte
inverseur. Comme variables intermédiaire, on considère \(I_1\)
en sortie de la porte ET à trois entrées et \(I_2\) en sortie de la
porte NOR. On trouve que \(I_1 = A^\prime \cdot B \cdot C\) et que
\(I_2 = (A + D)^\prime = A^\prime \cdot D^\prime\).

\item On aura donc \(F_1 = I_1 \cdot I_2\).

\item En substituant, \(F_1 = ( A^\prime \cdot B \cdot C ) \cdot (
   A^\prime \cdot D^\prime) = A^\prime \cdot B \cdot C \cdot
   D^\prime\).

\item En simplifiant, on obtient finalement \(F_1 = A^\prime \cdot B
   \cdot C \cdot D^\prime\).
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:org586cfb0}]{Exemple d'analyse d'un circuit logique combinatoire \ldots{} 3}
\begin{table}[h] \scriptsize
\caption{\label{tab:org726302a}Tableaux de vérité des fonctions intermédiaires et de la sortie}
\centering
\begin{tabular}{rrrrlrrr}
\(A\) & \(C\) & \(B\) & \(D\) &  & \(I_1\) & \(I_2\) & \(F_1\)\\
\hline
0 & 0 & 0 & 0 &  & 0 & 0 & 0\\
0 & 0 & 0 & 1 &  & 0 & 0 & 0\\
0 & 1 & 0 & 0 &  & 0 & 1 & 0\\
0 & 1 & 0 & 1 &  & 0 & 0 & 0\\
0 & 0 & 1 & 0 &  & 0 & 1 & 0\\
0 & 0 & 1 & 1 &  & 0 & 0 & 0\\
0 & 1 & 1 & 0 &  & 1 & 1 & 1\\
0 & 1 & 1 & 1 &  & 1 & 0 & 0\\
1 & 0 & 0 & 0 &  & 0 & 0 & 0\\
1 & 0 & 0 & 1 &  & 0 & 0 & 0\\
1 & 1 & 0 & 0 &  & 0 & 0 & 0\\
1 & 1 & 0 & 1 &  & 0 & 0 & 0\\
1 & 0 & 1 & 0 &  & 0 & 0 & 0\\
1 & 0 & 1 & 1 &  & 0 & 0 & 0\\
1 & 1 & 1 & 0 &  & 0 & 0 & 0\\
1 & 1 & 1 & 1 &  & 0 & 0 & 0\\
\end{tabular}
\end{table}
\end{frame}


\begin{frame}[label={sec:org6a4b44b}]{Conception d'un circuit combinatoire}
\begin{itemize}
\item Concevoir un circuit logique commence avec la formulation de la ou des fonctions du système et se termine avec une implémentation en portes logiques des fonctions logiques correspondantes.
\end{itemize}

Voici les étapes à suivre.

\begin{enumerate}
\item À partir de l'expression du besoin ou des spécifications du
système, déterminer combien d'entrées et de sorties sont
requises, puis leur assigner des noms de variables. Le choix des noms
devrait faciliter leur interprétation en lien avec leur fonction.

\item Formuler le tableau de vérité qui décrit les valeurs logiques que
doivent assumer les sorties en fonction des différentes
combinaisons d'entrées.
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:orge2f9b5a}]{Conception d'un circuit combinatoire \ldots{} 2}
\begin{enumerate}
\setcounter{enumi}{2}
\item Simplifier les expressions logiques pour les différentes fonctions,
en tenant éventuellement compte des partages possibles d'éléments
intermédiaires.

\item Tracer le circuit logique résultant et le valider (à la main ou
mieux, par simulation).
\end{enumerate}
\end{frame}

\begin{frame}[label={sec:org597044d}]{Conception d'un circuit combinatoire \ldots{} 3}
\begin{itemize}
\item L'étape 2 est cruciale, car ce qui sera implémenté (s'il n'y a pas d'erreurs) est exactement ce que le tableau de vérité stipule.

\item On doit donc s'assurer que le tableau est correctement rempli et représente véritablement les besoins identifiés.

\item Si des hypothèses ou des choix doivent être faits, notamment dans le cas où l'expression informelle des besoins est incomplète ou ambiguë, ces choix doivent être clairement identifiés et documentés, permettant le cas échéant de les modifier lorsque le système est mis à l'épreuve en fonctionnement.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgd95efdb}]{Conception d'un circuit combinatoire \ldots{} 4}
N'importe quelle méthode de simplification peut être utilisée pour l'étape 3, mais il faut aussi prendre en compte 
\begin{itemize}
\item le type de portes disponibles pour l'implémentation,
\item les délais de propagation à travers les portes,
\item le nombre d'interconnexions entre sorties et entrées de portes,
\item et tout autre facteur pratique susceptible d'orienter les décisions.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org4fbbeaf}]{Alternatives d'implémentation}
\begin{itemize}
\item Considérons la fonction logique \(Y\) correspondant au diag-K de la figure suivante.
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/kmap3altern}
\caption{\label{fig:org551e5f8}Diag-K d'une fonction combinatoire \(Y\) à réaliser}
\end{figure} 
\end{frame}

\begin{frame}[label={sec:orge32a79f}]{Implémentations via la fonction directe, en \emph{somme de produits}}
\begin{itemize}
\item En \emph{somme de produits}, on a \(Y = bc + a^\prime b + a b^\prime c^\prime\) pour la fonction et \(Y^\prime = a^\prime b^\prime + b^\prime c + a b c^\prime\) pour son complément.

\item Les implémentations possibles pour la fonction directe sont illustrées ci-dessous.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgf4512f9}]{Implémentations via la fonction directe, en \emph{somme de produits}}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_1}
\caption{\label{fig:orgca9080f}Implémentation de \(Y\) en \emph{somme de produits}}
\end{figure} 
\end{frame}

\begin{frame}[label={sec:org7e4a822}]{Implémentations via la fonction directe, en \emph{somme de produits} \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_2}
\caption{\label{fig:org5532516}Implémentation (en NAND) de \(Y\) en \emph{somme de produits}}
\end{figure} 
\end{frame}


\begin{frame}[label={sec:org8787fd2}]{Implémentation en \emph{produit de sommes}}
\begin{itemize}
\item En \emph{produit de sommes}, on a \(Y =(a + b ) (b + c^\prime ) (a^\prime + ba^\prime + c)\) pour la fonction et \(Y^\prime = (b^\prime +c^\prime )(a+b^\prime )(a^\prime +b+c)\) pour son complément.

\item Les implémentations possibles pour la fonction directe sont illustrées ci-dessous.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgd38a793}]{Implémentation en \emph{produit de sommes} \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_ps1}
\caption{\label{fig:org89f3e25}Implémentation de \(Y\) en \emph{produit de sommes}}
\end{figure} 
\end{frame}

\begin{frame}[label={sec:orga4503e4}]{Implémentation en \emph{produit de sommes} \ldots{} 3}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_ps2}
\caption{\label{fig:orgdae8f28}Implémentation (en NOR) de \(Y\) en \emph{produit de sommes}}
\end{figure} 
\end{frame}


\begin{frame}[label={sec:orga834cf0}]{Implémentations via la fonction complémentaire}
\begin{itemize}
\item On peut aussi implémenter la fonction à partir de la fonction complémentaire \(Y^\prime\), en se basant sur le complément \(Y^\prime = (b^\prime +c^\prime )(a+b^\prime )(a^\prime +b+c)\) et en inversant la sortie.

\item Voici les implémentations que l'on obtient alors.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgceb5a39}]{Implémentation via la fonction complémentaire, en \emph{somme de produits}}
\begin{itemize}
\item En \emph{somme de produits}, on a utilisé une porte NOR en sortie pour obtenir finalement \(Y\).
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_comp_sp1}
\caption{\label{fig:orgb865f6e}Implémentation via \(Y^\prime\) en \emph{somme de produits}}
\end{figure} 
\end{frame}

\begin{frame}[label={sec:org99881c4}]{Implémentation via la fonction complémentaire, en \emph{somme de produits} \ldots{} 2}
\begin{itemize}
\item Une autre forme fait appel à des portes NAND au premier niveau.
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_comp_sp2}
\caption{\label{fig:org7ece2ab}Implémentation via \(Y^\prime\) en \emph{somme de produits}}
\end{figure} 
\end{frame}

\begin{frame}[label={sec:org13185c5}]{Implémentation via la fonction complémentaire, en \emph{produit de sommes}}
\begin{itemize}
\item En \emph{produit de sommes}, en se basant sur le complément \(Y^\prime = (b^\prime +c^\prime )(a+b^\prime )(a^\prime +b+c)\).

\item On a encore ici deux variantes selon le type de portes utilisées.
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_comp_ps1}
\caption{\label{fig:orgbe466d6}Implémentation via \(Y^\prime\) en \emph{produit de sommes}}
\end{figure} 
\end{frame}

\begin{frame}[label={sec:org5dfb454}]{Implémentation via la fonction complémentaire, en \emph{produit de sommes} \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/circ_altern_comp_ps2}
\caption{\label{fig:orgfa87bb9}Implémentation via \(Y^\prime\) en \emph{produit de sommes}}
\end{figure} 
\end{frame}

\begin{frame}[label={sec:org86d6525}]{Circuits logiques combinatoires classiques}
\begin{itemize}
\item Nous allons maintenant nous intéresser à un certain nombre de fonctions typiques que l'on rencontre fréquemment en circuits logiques.

\item Ce sera aussi l'occasion de mettre en pratique les approches de conception que nous avons vues.
\end{itemize}
\end{frame}


\begin{frame}[label={sec:orgab14752}]{Additionneur binaire}
\begin{itemize}
\item Une des opérations binaires les plus utilisées est l'addition (et la soustraction).

\item Nous avons présenté précédemment le tableau de vérité pour un additionneur binaire dont les entrées sont \(a_{i}\) et \(b_{i}\), les bits des nombres à additionner, et aussi \(r_{i-1}\), la retenue provenant de la position \(i-1\).

\item En sortie, on aura la somme \(S_{i}\) et la retenue \(R_{i}\).

\item Notez que pour bien distinguer la retenue d'entrée de la retenue de sortie, nous utilisons un symbole minuscule, \(r_{i-1}\), pour l'entrée et un symbole majuscule, \(R_{i}\), pour la sortie.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org15c211a}]{Additionneur binaire \ldots{} 2}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{../Images_png/additionneur.png}
\caption{\label{fig:org2df799d}Schéma-bloc d'un additionneur complet}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgc62f9ca}]{Additionneur binaire \ldots{} 3}
\begin{table}[htbp]
\caption{\label{tab:orgabd2521}Tableau de vérité pour l'additionneur binaire}
\centering
\begin{tabular}{rrrlrr}
\(a_{i}\) & \(b_{i}\) & \(r_{i-1}\) &  & \(R_{i}\) & \(S_{i}\)\\
\hline
0 & 0 & 0 &  & 0 & 0\\
0 & 0 & 1 &  & 0 & 1\\
0 & 1 & 0 &  & 0 & 1\\
0 & 1 & 1 &  & 1 & 0\\
1 & 0 & 0 &  & 0 & 1\\
1 & 0 & 1 &  & 1 & 0\\
1 & 1 & 0 &  & 1 & 0\\
1 & 1 & 1 &  & 1 & 1\\
\end{tabular}
\end{table}
\end{frame}


\begin{frame}[label={sec:org47e8b23}]{Demi-additionneur}
\begin{itemize}
\item Un circuit logique qui effectue l'addition de deux bits est appelé un demi-additionneur.

\item Mais ce qu'il nous faut vraiment, c'est un \alert{additionneur complet}, c'est-à-dire un circuit de trois entrées qui fait l'addition de trois bits, puisqu'il faudra pouvoir tenir compte de la retenue du niveau précédent pour effectuer l'addition sur un niveau.

\item Il est possible d'implémenter l'additionneur complet avec deux demi-additionneurs.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgcf82464}]{Demi-additionneur \ldots{} 2}
\begin{table}[htbp]
\caption{\label{tab:org844d456}Tableau de vérité pour un demi-additionneur}
\centering
\begin{tabular}{rrlrr}
\(a_{i}\) & \(b_{i}\) &  & \(R_{i}\) & \(S_{i}\)\\
\hline
0 & 0 &  & 0 & 0\\
0 & 1 &  & 0 & 1\\
1 & 0 &  & 0 & 1\\
1 & 1 &  & 1 & 0\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:orgcc94cd7}]{Demi-additionneur \ldots{} 3}
\begin{itemize}
\item À partir du tableau de vérité, on peut trouver que pour un demi-additionneur, \(S_{i} = a_i b_i^\prime + a_i^\prime b_i = a_i \operatorname{Xor} b_i\) et \(R_{i} = a_i b_i\).
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/demi_add2}
\caption{\label{fig:org5fc7bf9}Circuit demi-additionneur (en S de P)}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgd9187c1}]{Demi-additionneur \ldots{} 4}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/demi_add}
\caption{\label{fig:org9df32d8}Circuit demi-additionneur avec porte XOR}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org1e5f91c}]{Additionneur complet}
\begin{itemize}
\item Une addition binaire complète de deux arguments constitués de \(n\) bits procède du bit le moins significatif vers le bit le plus significatif, en additionnant à chaque étape trois bits: \(a_{i}\), \(b_{i}\) et \(r_{i-1}\) et en produisant une somme \(S_{i}\) et une retenue \(R_{i}\).
\end{itemize}


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/kmapSi_fulladder}
\caption{\label{fig:org9a810c7}Diag-K pour \(S_i\), additionneur complet}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orge63d019}]{Additionneur complet \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/kmap3fulladderR}
\caption{\label{fig:org6bf1560}Diag-K pour \(R_i\), additionneur complet}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgb9c3bf5}]{Additionneur complet \ldots{} 3}
Les expressions simplifiées sont 

$$ S_{i} = a_i^\prime b_i^\prime r_{i-1} + a_i^\prime b_i
r_{i-1}^\prime + a_i b_i^\prime r_{i-1}^\prime + a_i b_i r_{i-1} $$

$$ R_{i} = a_i b_i + a_i r_{i-1} + b_i r_{i-1} $$
\end{frame}

\begin{frame}[label={sec:org05c6e8f}]{Additionneur complet \ldots{} 4}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/fulladderS}
\caption{\label{fig:org0e8d729}Circuit additionneur complet pour \(S_i\)}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgab13184}]{Additionneur complet \ldots{} 5}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/fulladderR}
\caption{\label{fig:orgcd1d091}Circuit additionneur complet pour \(R_i\)}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org3b187b8}]{Additionneur complet \ldots{} 6}
Comme nous le disions précédemment, il est possible de combiner deux
demi-additionneurs pour réaliser un additionneur complet, comme on
peut le voir ici.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/fulladderxor}
\caption{\label{fig:org232fb6b}Circuit additionneur complet comportant deux demi-additionneurs et une porte OU}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgad5b3b3}]{Additionneur binaire pour \(n\) bits}
\begin{itemize}
\item Un additionneur binaire est un circuit logique qui permet d'évaluer
la somme arithmétique de deux nombres binaires de \(n\) bits.

\item Il peut être conçu en combinant des additionneurs complets en
cascade, en reliant la retenue de sortie provenant de la position 0
(la moins significative) à l'entrée de retenue de la position 1, la
retenue de sortie provenant de la position 1 à l'entrée de retenue
de la position 2,\ldots{}, la retenue de sortie provenant de la position
\(i-1\) à l'entrée de retenue de la position \(i\), etc. (figure
\ref{fig:org34cbec8}).
\end{itemize}
\end{frame}


\begin{frame}[label={sec:org5f03573}]{Additionneur binaire pour \(n\) bits \ldots{} 2}
\begin{itemize}
\item Pour en faire un circuit général pouvant également se combiner en
chaîne, on prévoit une entrée pour une retenue au niveau 0, \(r_0\)
et une sortie pour une retenue du dernier niveau \(n-1\),
\(R_{n-1}\).

\item On doit donc, pour le chaînage, acheminer la sortie retenue du
niveau courant à l'entrée de retenue du niveau suivant.
\end{itemize}
\end{frame}


\begin{frame}[label={sec:org1621b05}]{Chaîne d'addition}
\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{../Images_png/additionneur_cascade.png}
\caption{\label{fig:org34cbec8}Chaîne d'addition}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgd50fb6b}]{Chaîne d'addition \ldots{} 2}
\begin{itemize}
\item Cette réalisation en forme de chaîne, en réutilisant de façon
systématique un bloc élémentaire, est avantageuse du point de vue de
la complexité et de la flexibilité.

\item Imaginons par exemple le défi de concevoir un additionneur binaire pour des nombres de quatre bits avec la méthode classique.

\item Comme il faudrait considérer neuf entrées, le tableau de vérité comporterait \(2^9= 512\) lignes!
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org93db6de}]{Propagation de retenue}
\begin{itemize}
\item L'approche en cascade ne comporte pas que des avantages.

\item Lorsqu'on effectue l'addition de deux nombres, les bits d'entrée des deux arguments et la retenue d'entrée sont présentés en même temps à l'additionneur.

\item Comme dans tout circuit combinatoire, il faut un certain délai avant que les sorties n'atteignent leur niveau de sortie final.

\item Ce délai de propagation dépend de la profondeur du circuit, en nombre de portes élémentaires à franchir de l'entrée vers la sortie.

\item Et c'est évidemment le chemin le plus long qui détermine le délai de propagation global.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org922f7d5}]{Propagation de retenue \ldots{} 2}
\begin{itemize}
\item Dans le cas de l'additionneur, le chemin de propagation le plus long est celui qui mène à la dernière retenue finale \(R_{n-1}\).

\item En effet, pour pouvoir calculer \(R_{n-1}\), bien que les valeurs de \(a_{n-1}\) et \(b_{n-1}\) soient déjà disponibles, il faut attendre que la valeur de \(r_{n-1} = R_{n-2}\) soit stabilisée avant que le calcul puisse s'effectuer avec les bonnes valeurs.

\item Il en est de même avec le bloc précédent et ainsi, en remontant la chaîne vers \(r_0\), on trouve le chemin de propagation de retenue comme chemin le plus long.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org4274c0d}]{Propagation de retenue \ldots{} 3}
\begin{itemize}
\item Pour déterminer le nombre de portes à franchir pour le chemin de propagation de retenue, nous avons ajouté deux sorties intermédiaires à notre circuit d'additionneur complet, \(P_i\) et \(G_i\), permettant de récrire la sortie comme \(S_i = P_i \operatorname{Xor} r_i\) et la retenue de sortie comme \(R_i = P_i r_i + G_i\).

\item Les signaux \(P_i\) et \(G_i\) ne dépendent que des entrées et sont donc disponibles après le délai des portes ET et XOR.

\item Le chemin de \(r_i\) à \(R_i\) passe par une porte ET et une porte OU.

\item Pour un additionneur de \(n\) bits comprenant \(n\) additionneurs complets, on aura une profondeur de retenue totale de \(2n\) portes.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org335244a}]{Propagation de retenue \ldots{} 4}
\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{../Images_svg/fulladderxorPG}
\caption{\label{fig:orgde1b4ca}Circuit additionneur complet montrant les signaux intermédiaires \(P_i\) et \(G_i\)}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgcb73a3e}]{Anticipation de retenue}
\begin{itemize}
\item Les valeurs calculées par le circuit complet en chaîne ne seront valides et ne devront être prises en compte que lorsque le délai maximal se sera écoulé.

\item Entre-temps, les valeurs binaires présentes aux différentes sorties assumeront typiquement des valeurs changeantes jusqu'à la stabilisation finale.

\item Le délai de propagation de retenue est un facteur qui limite la vitesse à laquelle on pourra calculer la somme de deux nombres.

\item Et comme l'addition est une opération souvent utilisée, parfois à répétition, pour réaliser d'autres opérations arithmétiques, cette limitation est problématique.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orge9c3f9b}]{Anticipation de retenue \ldots{} 2}
\begin{itemize}
\item Il serait en théorie possible de ramener à un minimum le délai de calcul de la retenue finale en réalisant cette fonction en deux niveaux, par exemple avec un \emph{produit de sommes}.

\item Cette option n'est pas réaliste, car le nombre d'entrées à considérer en parallèle est prohibitif.

\item Comme solutions de compromis intermédiaires, un certain nombre de mécanismes ont été élaborés, dont l'approche par anticipation de retenue, que nous allons explorer ici.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org7ea0107}]{Anticipation de retenue \ldots{} 3}
\begin{itemize}
\item On fait appel aux deux signaux \(P_i = a_i \operatorname{Xor} b_i\) et \(G_i = a_i b_i\), qui donnent respectivement pour la sortie et la retenue de sortie
\end{itemize}

$$ S_i = P_i \operatorname{Xor} r_{i-1} $$
$$ R_i = P_i r_{i-1} + G_i $$

\begin{itemize}
\item \(G_i\) est le signal qui indique la \alert{génération} de retenue, produisant une retenue lorsque \(a_i\) et \(b_i\) sont tous deux à 1, sans égard à la valeur de la retenue d'entrée \(r_{i-1}\).

\item Le signal \(P_i\) est l'indicateur de \alert{propagation} de retenue, parce qu'il détermine si la retenue du niveau précédent \(r_{i-1}\) sera propagée à \(R_i\).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgf6a4caf}]{Anticipation de retenue \ldots{} 4}
En partant du niveau 0, voici les expressions pour les différentes retenues:

$$ R_0 = r_0 = \operatorname{in}$$
$$ R_1 = G_0 + P_0 R_0 $$
$$ R_2 = G_1 + P_1 R_1 = G_1 + P_1 (G_0 + P_0 R_0) = G_1 + P_1 G_0 + P_1 P_0 R_0 $$
$$ R_3 = G_2 + P_2 R_2 = G_2 + P_2 G_1 + P_2 P_1 G_0 + P_2 P_1 P_0 R_0 $$
etc.
\end{frame}

\begin{frame}[label={sec:org1f68a43}]{Anticipation de retenue \ldots{} 5}
\begin{itemize}
\item Les expressions pour les retenues successives sont en forme \emph{somme de produits}, ce qui mène à une implémentation à deux niveaux pour calculer les retenues rapidement.

\item Contrairement à l'approche de propagation de retenue, toutes les retenues sont obtenues après un même délai équivalent à une profondeur de deux portes.

\item En calculant d'abord les différentes valeurs de \(P_i\) et \(G_i\) pour chaque niveau et en utilisant ces résultats intermédiaires pour, d'une part, alimenter le circuit d'anticipateur de retenue et, d'autre part, effectuer \(S_i = P_i \operatorname{Xor} r_i\), on obtient un additionneur parallèle plus rapide que la configuration en cascade.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org907b825}]{Anticipation de retenue \ldots{} 6}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.55]{../Images_svg/lookahead1}
\caption{\label{fig:orga63d756}Circuit d'anticipateur de retenue pour \(n= 4\)}
\end{figure}
\end{frame}


\begin{frame}[label={sec:org58c7c9e}]{Soustraction}
\begin{itemize}
\item Pour effectuer une soustraction \(A - B\), il faut effectuer \(A + (-B)\), c'est-à-dire additionner le complément à deux de \(B\) à \(A\).

\item On détermine le complément à deux en obtenant d'abord le complément à un en complémentant chaque bit et en additionnant ensuite 1 à cette valeur par le biais de l'entrée de retenue de l'additionneur.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org3bf0e23}]{Soustraction \ldots{} 2}
\begin{itemize}
\item Il est ainsi possible de concevoir un additionneur/soustracteur commandé par un signal de contrôle \(O\).

\item Si \(O=0\), le circuit calcule \(A + (B)\) et si \(O=1\), le circuit calcule \(A + (-B)\).

\item La complémentation de \(B\) se fait au moyen de portes XOR qui calculent \(O \operatorname{Xor} b_i\) et dont la sortie est acheminée à l'entrée \(B\) de l'additionneur.

\item Lorsque \(O=1\), leur sortie vaut \(b_i^\prime\).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org9502f42}]{Soustraction \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{../Images_svg/add_sous}
\caption{\label{fig:orgc93358d}Circuit additionneur/ soustracteur 4 bits}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgad33db6}]{Débordements}
\begin{itemize}
\item Un additionneur ou un soustracteur est conçu en fonction d'une taille de nombres \(n\).

\item Lorsque le résultat de l'opération dépasse la limite pouvant être représentée, on doit détecter cette condition et la signaler par un signal binaire.

\item Le cas de l'addition de nombres non signés est le plus simple.

\item Il suffit de surveiller la retenue du niveau le plus significatif.

\item Une retenue de 1 signifie un débordement de l'addition.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org7190d69}]{Débordements: nombre signés}
\begin{itemize}
\item Les calculs avec des nombres signés en complément à deux peuvent aussi occasionner des débordements, mais la détection doit tenir compte des bits qui indiquent le signe des nombres.

\item L'addition de deux nombres de signes différents ne peut pas occasionner de débordement, puisque la valeur absolue du résultat sera nécessairement moindre que celle du plus grand des nombres initiaux.

\item Un débordement ne peut donc se produire que si les deux nombres additionnés sont de même signe, deux positifs ou deux négatifs.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org84d39b7}]{Débordements: illustration}
\begin{itemize}
\item Prenons le cas de nombres représentés sur huit bits en complément à deux.

\item La gamme représentable va de -128 à +127 avec un bit qui représente le signe.

\item Si on additionne (+50)10 = (00110010)2 avec (+100)10 = (01100100)2, on aura un débordement, car \(150 > 127\).

\item On voit dans le tableau suivant les bits qui seront produits par l'addition, avec en évidence les retenues des deux derniers niveaux.

\item Le bit de signe a été séparé des autres.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgfd1f507}]{Débordements: deux positifs}
\begin{table}[htbp]
\caption{\label{tab:org62b8e10}Addition de (+50)10 + (+100)10 = (00110010)2 + (01100100)2}
\centering
\begin{tabular}{lrrl}
Retenues & 0 & 1 & \\
\hline
 &  & 0 & 011 0010\\
 &  & 0 & 110 0100\\
\hline
 &  & 1 & 001 0110\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:org0cb6377}]{Débordements: deux négatifs}
\begin{itemize}
\item Refaisons le même exercice avec deux nombres négatifs: on additionne (-50)10 = (1100 1110)2 avec (-100)10 = (1001 1100)2, qui créera aussi un débordement.
\end{itemize}

\begin{table}[htbp]
\caption{\label{tab:orge71bfdf}Addition de (-50)10 + (-100)10 = (1100 1110)2 + (1001 1100)2}
\centering
\begin{tabular}{lrrl}
Retenues & 1 & 0 & \\
\hline
 &  & 1 & 100 1110\\
 &  & 1 & 001 1100\\
\hline
 &  & 0 & 110 1010\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:org7eaaf61}]{Débordements: règle générale}
\begin{itemize}
\item On peut dans les deux cas détecter le débordement en observant que la retenue du dernier niveau et la retenue de l'avant-dernier niveau sont différentes.

\item On peut vérifier facilement que les autres cas sans débordement donnent des retenues égales.

\item Donc, si on fait un OU-exclusif entre ces deux retenues, un résultat 1 indiquera un débordement.

\item Ce mécanisme de détection de débordement a été ajouté au circuit additionneur/soustracteur 4 bits dans la figure suivante pour générer le signal \(D\) qui indique un débordement.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1ae69ef}]{Détection de débordements}
\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{../Images_svg/add_sous_deb}
\caption{\label{fig:org9921479}Circuit additionneur/soustracteur 4 bits avec débordement}
\end{figure}
\end{frame}


\begin{frame}[label={sec:orgcd3053a}]{Multiplexeur}
\begin{itemize}
\item Un multiplexeur est un circuit combinatoire qui sélectionne le signal qui provient d'une de ses entrées, et fait que sa sortie est égale à l'entrée sélectionnée.

\item Les signaux de sélection fonctionnent typiquement selon un encodage binaire, ce qui suppose un nombre d'entrées de la forme \(2^n\).

\item On désigne le multiplexeur par le nombre de signaux d'entrées à sélectionner.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga2f04d6}]{Multiplexeur deux-vers-un}
\begin{itemize}
\item Le multiplexeur le plus simple utilise un seul signal de sélection \(S\) qui permet de choisir une de deux entrées \(I_0\) ou \(I_1\) pour agir sur la sortie \(Y\).
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/mux2b}
\caption{\label{fig:orge2c73e5}Circuit du multiplexeur deux-vers-un}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org652ed01}]{Multiplexeur deux-vers-un: symbole}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/mux2symb}
\caption{\label{fig:org3634555}Symbole du multiplexeur deux-vers-un}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org9c35613}]{Multiplexeur quatre-vers-un}
\begin{itemize}
\item Un multiplexeur quatre-vers-un permet de choisir une de quatre entrées en utilisant deux signaux de sélection.

\item Pour simplifier la représentation symbolique, les deux signaux de sélection sont représentés comme un seul fil, qui correspond en fait à une paire de signaux \(S_0\) et \(S_1\).

\item Pour un multiplexeur à \(2^n\) entrées, on aurait un vecteur de \(n\) signaux de sélection.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org72cea79}]{Multiplexeur quatre-vers-un \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/mux4}
\caption{\label{fig:orgf6c3c1c}Circuit du multiplexeur quatre-vers-un}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org0a1ee99}]{Multiplexeur quatre-vers-un \ldots{} 3}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/mux4symb}
\caption{\label{fig:org1f76c06}Symbole du multiplexeur quatre-vers-un}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgfa25d90}]{Multiplexeur quatre-vers-un \ldots{} 4}
\begin{table}[htbp]
\caption{\label{tab:orgeb3fde0}Tableau de vérité du multiplexeur quatre-vers-un}
\centering
\begin{tabular}{rrll}
\(S_1\) & \(S_0\) &  & \(Y\)\\
\hline
0 & 0 &  & \(I_0\)\\
0 & 1 &  & \(I_1\)\\
1 & 0 &  & \(I_2\)\\
1 & 1 &  & \(I_3\)\\
\end{tabular}
\end{table}
\end{frame}



\begin{frame}[label={sec:orga7e3613}]{Décodeur}
\begin{itemize}
\item Un décodeur est un circuit combinatoire qui sert à interpréter des données encodées, le plus souvent en binaire.

\item Il prend un groupe (vecteur) de \(n\) bits en entrée, et active une sortie parmi jusqu'à \(2^n\) sorties différentes.

\item Dans le cas où certaines combinaisons d'entrées ne sont pas utilisées, moins de \(2^n\) sorties peuvent être produites.

\item Dans un décodeur générique, chaque combinaison binaire distincte activera une seule sortie.

\item Il y a une correspondance directe entre chaque sortie possible et un minterm d'entrée.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgde467f0}]{Décodeur \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.55]{../Images_svg/decod3_8}
\caption{\label{fig:orgd8f77ab}Circuit du décodeur trois-vers-huit}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgcd10f09}]{Décodeur \ldots{} 3}
\begin{table}[htbp]
\caption{\label{tab:org3e3bd15}Tableau de vérité du décodeur trois-vers-huit}
\centering
\begin{tabular}{rrrlrrrrrrrr}
\(x\) & \(y\) & \(z\) &  & \(D_0\) & \(D_1\) & \(D_2\) & \(D_3\) & \(D_4\) & \(D_5\) & \(D_6\) & \(D_7\)\\
\hline
0 & 0 & 0 &  & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 1 &  & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 0 &  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
0 & 1 & 1 &  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\
1 & 0 & 0 &  & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
1 & 0 & 1 &  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\
1 & 1 & 0 &  & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\
1 & 1 & 1 &  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:org93e0f79}]{Décodeur avec sortie active basse et signal de contrôle}
\begin{itemize}
\item On peut aussi concevoir des décodeurs basés sur des portes NAND et dont la sortie sélectionnée est active au niveau bas.

\item Une autre fonction utile est un signal de contrôle \(E\) qui n'active une sortie que lorsqu'il est activé.

\item Le décodeur deux-vers-quatre, dont le circuit est présenté ci-dessous, comporte ces deux caractéristiques.

\item Comme on peut voir dans le tableau de vérité, tant que le signal de contrôle est inactif ( \(E = 1\) puisque ce signal est également actif bas), les sorties sont inactives (au niveau 1) quelles que soient les entrées \(x\) et \(y\).

\item Lorsque \(E = 0\), une seule sortie passe à 0, selon le code binaire présent aux entrées \(x\) et \(y\).

\item Notez que ce décodeur a été conçu et étiqueté en fonction d'entrées \(x\) et \(y\) qui sont actives haut.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgd88ee28}]{Décodeur avec sortie active basse et signal de contrôle \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/decode2_4_enable}
\caption{\label{fig:org3fef8aa}Décodeur à sortie active basse}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org7215aee}]{Décodeur avec sortie active basse et signal de contrôle \ldots{} 3}
\begin{table}[htbp]
\caption{\label{tab:orgd089392}Tableau de vérité, décodeur 2 vers 4 avec sortie active basse}
\centering
\begin{tabular}{rrrlrrrr}
\(E\) & \(x\) & \(y\) &  & \(D_0\) & \(D_1\) & \(D_2\) & \(D_3\)\\
\hline
0 & 0 & 0 &  & 0 & 1 & 1 & 1\\
0 & 0 & 1 &  & 1 & 0 & 1 & 1\\
0 & 1 & 0 &  & 1 & 1 & 0 & 1\\
0 & 1 & 1 &  & 1 & 1 & 1 & 0\\
1 & 0 & 0 &  & 1 & 1 & 1 & 1\\
1 & 0 & 1 &  & 1 & 1 & 1 & 1\\
1 & 1 & 0 &  & 1 & 1 & 1 & 1\\
1 & 1 & 1 &  & 1 & 1 & 1 & 1\\
\end{tabular}
\end{table}
\end{frame}


\begin{frame}[label={sec:org91d4a93}]{Implémentation de fonctions arbitraires au moyen d'un décodeur}
\begin{itemize}
\item Puisqu'un décodeur active sélectivement les \(2^n\) minterms possibles à partir de ses \(n\) entrées, il est possible d'implémenter, en \emph{somme de produits}, une fonction quelconque en acheminant les minterms de la fonction à une porte OU.

\item Il est même possible d'implémenter plusieurs fonctions différentes, en leur consacrant chacune une porte OU de sortie.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org884acf1}]{Implémentation d'une fonction arbitraire}
Voici par exemple une fonction réalisée à partir d'un décodeur trois-vers-huit.
\begin{itemize}
\item L'entrée \(I\) correspond à un vecteur de trois bits. Le
\end{itemize}
tableau de vérité correspondant est donné.

\begin{itemize}
\item On peut voir que les minterms choisis permettent d'implémenter
\end{itemize}

$$ Y = \sum(0,2,5,6)$$
\end{frame}


\begin{frame}[label={sec:org2a85199}]{Implémentation d'une fonction arbitraire \ldots{} 3}
\begin{itemize}
\item Le tableau de vérité correspondant est le suivant.
\end{itemize}

\begin{table}[htbp]
\caption{\label{tab:org93215f5}Tableau de vérité pour la fonction arbitraire}
\centering
\begin{tabular}{rrrlr}
\(I_2\) & \(I_1\) & \(I_0\) &  & \(Y\)\\
\hline
0 & 0 & 0 &  & 1\\
0 & 0 & 1 &  & 0\\
0 & 1 & 0 &  & 1\\
0 & 1 & 1 &  & 0\\
1 & 0 & 0 &  & 0\\
1 & 0 & 1 &  & 1\\
1 & 1 & 0 &  & 1\\
1 & 1 & 1 &  & 0\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:orge3aec1b}]{Implémentation de fonctions arbitraires}
\begin{itemize}
\item Une fonction qui comporte de nombreux minterms exige l'utilisation d'une porte OU avec un grand nombre d'entrées.

\item Si la fonction à réaliser exige plus de \(2^n/2\) minterms, il est alors plus avantageux d'implémenter le complément de la fonction, qui nécessitera moins de \(2^n/2\) minterms, et d'inverser ensuite la sortie pour obtenir la fonction.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgff8dc78}]{Encodeur}
\begin{itemize}
\item Un encodeur effectue le travail inverse du décodeur: lorsqu'une de ses \(2^n\) (ou moins) entrées est activée, il donne le code binaire correspondant sur ses \(n\) sorties vues comme un vecteur binaire.

\item Le circuit ne nécessite pas vraiment d'entrée pour \(D_0\).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org3a5ec7a}]{Encodeur \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/encode1}
\caption{\label{fig:org48e3eb8}Encodeur 3 bits}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orge8babd1}]{Encodeur \ldots{} 3}
\begin{table}[htbp]
\caption{\label{tab:org697bb95}Tableau de vérité pour l'encodeur 3 bits}
\centering
\begin{tabular}{rrrrrrrrlrrr}
\(D_0\) & \(D_1\) & \(D_2\) & \(D_3\) & \(D_4\) & \(D_5\) & \(D_6\) & \(D_7\) &  & \(x\) & \(y\) & \(z\)\\
\hline
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  & 0 & 0 & 0\\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 &  & 0 & 0 & 1\\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 &  & 0 & 1 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 &  & 0 & 1 & 1\\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 &  & 1 & 0 & 0\\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 &  & 1 & 0 & 1\\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 &  & 1 & 1 & 0\\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 &  & 1 & 1 & 1\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:orge5ce853}]{Encodeur \ldots{} 4}
\begin{itemize}
\item Cette configuration d'encodeur exige qu'une seule entrée ne soit activée à la fois.

\item Activer plus d'une entrée ne correspond en effet à rien de valide: comment donner un sens à une telle combinaison au moyen d'un vecteur de \(n\) bits?

\item Les sorties produites alors seront des vecteurs binaires sans signification.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org211ff5b}]{Encodeur à priorité}
\begin{itemize}
\item Une encodeur à priorité met en oeuvre une priorité entre les entrées.

\item S'il y a plus d'une entrée 1 en même temps, la sortie sera celle qui correspond à l'entrée active qui a la plus grande priorité.

\item Voici le tableau de vérité pour un encodeur 2 bits à priorité, dans lequel on a ajouté une sortie \(V\) qui indique la validité des sorties.

\item Si aucune entrée n'est active, \(V=0\) et les sorties \(x\) et \(y\) ne doivent pas être prises en compte.

\item Lorsque des entrées sont activées, c'est celle qui a le plus grand indice qui est prioritaire.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1f3f4a6}]{Encodeur à priorité \ldots{} 2}
\begin{table}[htbp]
\caption{\label{tab:orge12cdba}Tableau de vérité pour encodeur 2 bits à priorité}
\centering
\begin{tabular}{lrrrlrrr}
\(D_0\) & \(D_1\) & \(D_2\) & \(D_3\) &  & \(x\) & \(y\) & \(V\)\\
\hline
0 & 0 & 0 & 0 &  & X & X & 0\\
1 & 0 & 0 & 0 &  & 0 & 0 & 1\\
X & 1 & 0 & 0 &  & 0 & 1 & 1\\
X & X & 1 & 0 &  & 1 & 0 & 1\\
X & X & X & 1 &  & 1 & 1 & 1\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:org34374a7}]{Encodeur à priorité \ldots{} 3}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/kmap4foncencode_pri_x}
\caption{\label{fig:org76c871a}Diag-K pour \(x\) de l'encodeur à priorité}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org622d451}]{Encodeur à priorité \ldots{} 4}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/kmap4foncencode_pri_y}
\caption{\label{fig:org58455f4}Diag-K pour \(y\) de l'encodeur à priorité}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org4dd0aaf}]{Encodeur à priorité: expressions}
En simplifiant, on trouve les expressions suivantes:

$$ x = D_2 + D_3 $$

$$ y = (D_1 D_2^\prime) + D_3 $$

$$ V = D_0 + D_1 + D_2 + D_3 $$
\end{frame}

\begin{frame}[label={sec:orgcbce471}]{Encodeur à priorité: réalisation}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/encode_pri}
\caption{\label{fig:org4d08016}Encodeur 2 bits à priorité, en P de S}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgb9d3b59}]{Encodeur à priorité: autre réalisation}
Puisque le terme \(x = D_2 + D_3\) est déjà calculé pour \(x\), on
peut le réutiliser pour construire le terme pour \(V\), tel
qu'illustré ci-dessous, ce qui évite d'utiliser une porte OU à quatre
entrées.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/encode_pri2}
\caption{\label{fig:orged7b0f2}Encodeur 2 bits à priorité avec ré-utilisation d'un des termes}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgab4def7}]{Comparateur de magnitude}
\begin{itemize}
\item Comparer la magnitude de deux nombres binaires est une opération qui peut se systématiser, comme on l'a fait pour l'addition.

\item Considérons deux nombres binaires non signés, \(A\) et \(B\) de même taille \(n\), avec leurs bits respectifs \(a_i\) et \(b_i\).

\item On veut que notre comparateur active une des trois sorties, selon le cas: \(A < B\), \(A = B\) ou \(A > B\).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgbc8a508}]{Comparateur de magnitude \ldots{} 2}
\begin{itemize}
\item Pour illustrer, nous considérerons \(n = 4\).
\end{itemize}

$$ a_3 a_2 a_1 a_0 $$

$$ b_3 b_2 b_1 b_0 $$

\begin{itemize}
\item Nous aurons besoin d'une fonction qui permet de déterminer si deux bits sont égaux.

\item Cette fonction correspond à la fonction \alert{Équivalence} ou NOR-exclusif \(a_i b_i + a_i^\prime b_i^\prime\).
\end{itemize}
\end{frame}


\begin{frame}[label={sec:org86d268c}]{Comparateur de magnitude \ldots{} 3}
\begin{itemize}
\item Si les bits diffèrent en position \(i\), \(a_i = 1\) nous permet de conclure que \(A > B\), et, à l'inverse, \(a_i = 0\) nous indique que \(A < B\).

\item Nous avons ainsi les éléments qui permettent d'effectuer une comparaison pour un bit, comme on peut en voir l'implémentation sur la figure suivante.
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/comparateur}
\caption{\label{fig:org3033d5f}Comparateur de magnitude}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org4b32708}]{Comparateur de magnitude: \(n\) bits}
\begin{itemize}
\item Notre démarche de conception pour \(n\) bits sera calquée sur la procédure que nous utilisons intuitivement pour faire une telle comparaison.

\item La comparaison commence au niveau du bit le plus significatif.

\item Si ces bits sont égaux, on considère la position suivante, jusqu'à atteindre une position \(i\) où les bits diffèrent ou la fin des nombres (c'est-à-dire \(i=0\)).

\item Si les bits diffèrent en position \(i\), \(a_i = 1\) nous permet de conclure que \(A > B\), alors que \(a_i = 0\) nous indique que \(A < B\).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org6680f65}]{Comparateur de magnitude: \(n\) bits}
\begin{itemize}
\item Les signaux intermédiaires \(x_i = a_i b_i + a_i^\prime b_i^\prime\) qui indiquent si deux bits d'une position sont égaux seront mis à profit pour alimenter un réseau de conditions en forme \emph{somme de produits} qui mettront en application les règles énoncées.

\item Les signaux de sortie binaires sont \((A = B), (A < B), (A > B)\).

\item D'une part, la régularité des opérations simplifie la conception et, d'autre part, l'implémentation sera simplifiée du fait que certains des termes nécessaires peuvent être réutilisés.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga9f046d}]{Comparateur de magnitude: 4 bits}
$$ (A = B) = x_3 x_2 x_1 x_0 $$ 

$$ (A < B) = a_3^\prime b_3 + x_3  a_2^\prime b_2  +  x_3 x_2  a_1^\prime b_1 +  x_3 x_2 x_1  a_0^\prime b_0 $$

$$ (A > B) = a_3 b_3^\prime + x_3  a_2 b_2^\prime  +  x_3 x_2  a_1 b_1^\prime +  x_3 x_2 x_1  a_0 b_0^\prime $$

\begin{itemize}
\item On obtient ainsi un comparateur pour des nombres de quatre bits, tel qu'illustré.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org4d44a9e}]{Comparateur de magnitude: 4 bits \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.45]{../Images_svg/comparateur_4b}
\caption{\label{fig:org7107471}Comparateur de magnitude 4 bits}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org780b1fa}]{Démultiplexeur}
\begin{itemize}
\item Un démultiplexeur achemine la valeur logique de son entrée à une sortie (parmi \(2^n\) sorties) sélectionnée par un code binaire de sélection.

\item Le démultiplexeur de la figure suivante comporte trois bits de sélection et permet donc d'acheminer la valeur de l'entrée \(I\) vers une des huit sorties \(O_i, i = 0, \ldots, 7\).

\item On peut aussi interpréter ce circuit comme un décodeur trois-vers-huit avec une entrée signal de contrôle (\emph{enable}) \(I\).
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org7e83382}]{Démultiplexeur \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.3]{../Images_svg/demux8}
\caption{\label{fig:org34b8a0c}Démultiplexeur un-vers-huit}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgdfc4f38}]{Encodeurs divers}
\begin{itemize}
\item Il est possible de concevoir des encodeurs pour des fonctions spécialisées, comme des encodeurs pour commander des affichages.

\item La démarche de conception s'apparente largement à celles que nous avons vues dans les exemples précédents.
\end{itemize}
\end{frame}


\begin{frame}[label={sec:org0d3e65b}]{Portes à trois états et tampon de bus}
\begin{itemize}
\item Les portes à trois états ajoutent un troisième état de fonctionnement aux sorties: en plus des niveaux logiques bas et haut conventionnels, un troisième état appelé \alert{haute impédance} fait en sorte que la sortie se comporte comme si elle n'était plus connectée au circuit.

\item La sortie n'agit pas sur le reste du circuit, les autres portes dont les entrées sont alimentées par la porte en haute impédance ne sont aucunement affectées par celle-ci.

\item Pour activer cet état de sortie haute impédance, une entrée de contrôle est ajoutée.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org3570bbb},fragile]{Portes à trois états et tampon de bus \ldots{} 2}
 Le figure ci-dessous montre une porte tampon à trois états. Avec
\texttt{Contrôle} = 0, la sortie est en haute impédance; avec  \texttt{Contrôle} = 1,
la sortie est égale à l'entrée.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/buf_3s}
\caption{\label{fig:org237d1d5}Porte tampon à trois états}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org23936b9}]{Portes à trois états et tampon de bus \ldots{} 3}
\begin{itemize}
\item En plaçant des tampons à trois états à chaque sortie d'un décodeur, on peut réaliser un multiplexeur \(n\)-vers-un en reliant les sorties des tampons à une sortie unique.

\item Ainsi, lorsqu'une entrée est sélectionnée au moyen des entrées de sélection, c'est sa valeur qui se retrouve à la sortie du dispositif.

\item La valeur Z représente l'état haute impédance.

\item Lorsque l'entrée de contrôle \(E = 0\), la sortie est en haute impédance.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgaf6a9ff}]{Portes à trois états et tampon de bus \ldots{} 4}
\begin{table}[htbp]
\caption{\label{tab:org1c2a7e3}Tableau de vérité pour un  multiplexeur quatre-vers-un trois états}
\centering
\begin{tabular}{rrrlllllll}
\(s_1\) & \(S_0\) & \(E\) &  & \(I_0\) & \(I_1\) & \(I_2\) & \(I_3\) &  & \(Y\)\\
\hline
X & X & 0 &  & X & X & X & X &  & Z\\
0 & 0 & 1 &  & \(I_0\) & X & X & X &  & \(I_0\)\\
0 & 1 & 1 &  & X & \(I_1\) & X & X &  & \(I_1\)\\
1 & 0 & 1 &  & X & X & \(I_2\) & X &  & \(I_2\)\\
1 & 1 & 1 &  & X & X & X & \(I_3\) &  & \(I_3\)\\
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:org90a7270}]{Multiplexeur trois états}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/mux_4_1_3s}
\caption{\label{fig:org62bad22}Multiplexeur quatre-vers-un trois états}
\end{figure}
\end{frame}


\begin{frame}[label={sec:org2499630},fragile]{Émetteur-récepteur de bus}
 \begin{itemize}
\item La fonctionnalité trois-états permet aussi de concevoir un émetteur-récepteur de bus.

\item Ce dispositif, illustré à la figure suivante, permet d'établir une connexion bidirectionnelle entre \texttt{I/O} et \texttt{O/I}.

\item Lorsque l'entrée de contrôle \(E = 0\), c'est le tampon du haut de la figure qui est actif, et \texttt{O/I} détermine la valeur de \texttt{I/O}.

\item Lorsque \(E = 1\), c'est le tampon du bas qui est actif, et \texttt{I/O} détermine la valeur de \texttt{O/I}.
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgbf5f66a}]{Émetteur-récepteur de bus \ldots{} 2}
\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/bus_trans}
\caption{\label{fig:org0491670}Émetteur-récepteur de bus}
\end{figure}
\end{frame}
\end{document}