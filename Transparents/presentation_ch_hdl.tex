% Created 2023-10-26 jeu 09:55
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[, french]{babel}
\usepackage{svg}
\logo{\includegraphics[width=.1\textwidth]{../by-sa.png}}
\AtBeginEnvironment{minted}{\renewcommand{\fcolorbox}[4][]{#4}}
\usetheme{metropolis}
\usecolortheme{}
\usefonttheme{}
\useinnertheme{}
\useoutertheme{}
\author{Guy Bégin}
\date{\today}
\title{Circuits logiques combinatoires et séquentiels}

\hypersetup{
 pdfauthor={Guy Bégin},
 pdftitle={Circuits logiques combinatoires et séquentiels},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.6.6)}, 
 pdflang={French}}
\begin{document}

\maketitle

\section{Langages descriptifs et de modélisation}
\label{sec:orgdcced18}

\begin{frame}[label={sec:orgb702ff5}]{Objectifs}
\begin{itemize}
\item Expliquer la différence entre un langage descriptif de matériel et un langage de programmation
\item Expliquer les mécanismes d'assignation de signaux et la notion de concurrence
\item Faire la distinction entre une description d'entité et une architecture
\item Faire la distinction entre un modèle structural et un modèle comportemental
\item Faire la distinction entre un signal et une variable
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org79c2aa6}]{Objectifs \ldots{} 2}
\begin{itemize}
\item Se familiariser avec les principaux types utilisés en descriptions de circuits
\item Préparer une description (modèle) de circuit en langage VHDL
\item Préparer un banc d'essai permettant de tester un modèle de circuit
\item Simuler un modèle VHDL au moyen d'un banc d'essai et interpréter les résultats
\item Élaborer une description complète en VHDL pour un système simple
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1648a2d}]{Modélisation et simulation}
\begin{itemize}
\item Lorsque vient le temps de concevoir, simuler, tester et élaborer des systèmes numériques complexes, les approches manuelles que nous avons employées jusqu'ici ne suffisent plus
\item Il faut alors faire appel à des familles d'outils plus puissants de conception assistée par ordinateur
\item Avec ces outils, il est possible de concevoir et de spécifier précisément le design voulu, en simuler le fonctionnement, le valider par une batterie de tests, afin de s'assurer que le tout correspond aux besoins de l'application avant même de solliciter une seule porte logique physique
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgf868f51}]{Modélisation et simulation \ldots{} 2}
\begin{itemize}
\item Un élément clé de cette démarche est la possibilité de décrire précisément le ou les circuits qui seront implémentés au moyen d'un langage approprié
\item Un tel \alert{langage descriptif de matériel} (en anglais \emph{Hardware Description Language} (HDL)), qui s'apparente à un langage de programmation, permet de décrire de façon textuelle les différents éléments de notre circuit, leurs interconnexions et interactions
\item Alors qu'un langage de programmation spécifie essentiellement des procédures et les données qui y sont associées, un HDL est un langage de modélisation qui décrit des structures matérielles et le comportement de systèmes logiques
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org5d29e5f}]{Modélisation et simulation \ldots{} 3}
\begin{itemize}
\item Un HDL peut spécifier des diagrammes logiques, des expressions logiques, voire des tableaux de vérité
\item Il permet aussi de décrire le comportement du système à différents niveaux d'abstraction et les relations hiérarchiques entre les différents sous-systèmes qui le composent
\item On peut voir un modèle HDL comme la description des relations entre les entrées et les sorties du système
\item Entrées et sorties sont modélisées comme des \alert{signaux}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org84d5d18}]{Langage VHDL}
Parmi les nombreux HDL en usage, quelques-uns ont été standardisés: les plus répandus sont \emph{Verilog} et VHDL
\begin{itemize}
\item C'est ce dernier langage que nous allons utiliser
\item Le V dans l'acronyme VHDL (\emph{VHSIC Hardware Description Language}) provient d'un autre acronyme, VHSIC pour \emph{Very High Speed Integrated Circuits} (circuits intégrés à très haute vitesse)
\item On comprend que le langage a été créé dans l'optique de concevoir des circuits intégrés rapides et complexes
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org551c166}]{Langage VHDL \ldots{} 2}
\begin{itemize}
\item Un design en VHDL est un ensemble d'entités de conception
\item Une entité, celle du plus haut niveau, invoque les autres entités comme composants
\item Le design dans son ensemble est structuré de façon hiérarchique
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org9179283}]{Entité}
Une \alert{entité} définit le nom d'un modèle et spécifie ses interfaces, c'est-à-dire les entrées et les sorties qui permettent au modèle d'interagir avec son environnement
\begin{itemize}
\item Le nom, la direction et le type de chaque signal d'interface sont déclarés dans le \alert{port} de l'entité
\item La fonction du modèle n'est aucunement précisée
\item Il s'agit uniquement de décrire la «coquille» d'une boîte noire
\item La déclaration d'entité spécifie le nom de l'entité et la liste des ports d'entrée et de sortie
\item La forme générale est comme ci-dessous (les éléments entre crochets sont optionnels)
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orge18c3a5},fragile]{Déclaration d'entité}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
entity Nom_Entite is 
[generic generic_declarations);]

port (noms_signaux: mode type;

noms_signaux: mode type;
--
--
--
noms_signaux: mode type);

end [Nom_Entite];

\end{minted}
\end{frame}

\begin{frame}[label={sec:org11fafa8},fragile]{Déclaration d'entité \ldots{} 2}
 \begin{itemize}
\item La déclaration commence avec le mot réservé \alert{\texttt{entity}}, suivi du nom et du mot réservé \alert{\texttt{is}}
\item Viennent ensuite les déclarations de ports avec le mot réservé \alert{\texttt{port}}
\item La déclaration se termine avec le mot réservé \alert{\texttt{end}} et optionnellement, le nom de l'entité
\item \texttt{Nom\_Entite} est un nom arbitraire choisi par le concepteur ou la conceptrice
\item \texttt{noms\_signaux} donne une liste d'un ou de plusieurs identifiants séparés par des virgules qui définissent les signaux externes d'interface
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orge67762b},fragile]{Déclaration d'entité \ldots{} 3}
 \alert{mode}: est un des mots réservés suivants, qui définissent la direction des signaux:
\begin{itemize}
\item \texttt{in}: le signal est une entrée
\item \texttt{out}: le signal est une sortie de l'entité, qui peut être lue par les autres entités qui y sont raccordées
\item \texttt{buffer}: le signal est une sortie qui peut être lue de l'intérieur de l'architecture de l'entité
\item \texttt{inout}: le signal peut être une entrée ou une sortie
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1ac2159},fragile]{Déclaration d'entité \ldots{} 4}
 \begin{itemize}
\item \texttt{type}: est un type de signal prédéfini ou défini par le concepteur ou la conceptrice, par exemple, \texttt{bit, bit\_vector, Boolean, character, std\_logic,} ou \texttt{std\_ulogic}
\item \texttt{bit}: une valeur binaire  0 ou 1
\item \texttt{bit\_vector}: un vecteur de bits
\item \texttt{std\_logic, std\_ulogic, std\_logic\_vector, std\_ulogic\_vector}: des valeurs binaires plus nuancées (voir librairies)
\item \texttt{boolean}: deux valeurs possibles: TRUE ou FALSE
\item \texttt{integer}: des valeurs entières
\item \texttt{real}: des valeurs réelles
\item \texttt{character}: des caractères
\item \texttt{time}: des valeurs de temps
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgc002b5d},fragile]{Déclarations génériques}
 \begin{itemize}
\item \alert{\texttt{generic}}: les déclarations génériques sont optionnelles et spécifient des constantes locales utilisées pour préciser par exemple des valeurs de temps ou des tailles de vecteur
\item Un générique peut avoir une valeur de défaut
\item La syntaxe est comme ci-après
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org2dc3f7b},fragile]{Déclarations génériques \ldots{} 2}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
generic (

nom_constante: type [:=valeur];

nom_constante: type [:=valeur];
--
--
--
nom_constante: type [:=valeur] );
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgb7fb481},fragile]{Déclaration d'entité}
 Le listage qui suit montre un exemple simple de déclaration d'entité

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
entity ALU is
port (argl, arg2: in bit_vector;
add_or_sub: in bit;
result: out bit_vector);
end ALU;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org46c53bd},fragile]{Architecture}
 \begin{itemize}
\item Une \alert{\texttt{architecture}} est une réalisation (ou implémentation) de l'intérieur de la boîte noire
\item Jumelée à une entité, elle décrit comment les sorties de l'entité sont obtenues à partir de ses entrées
\item Il est possible d'associer de multiples architectures à une même entité
\end{itemize}

Une architecture peut contenir:

\begin{itemize}
\item des déclarations de données

\item des affectations concurrentes de signaux

\item des blocs processus

\item des instanciations de composants
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgf3367f3},fragile]{Structure typique d'une architecture}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
architecture nom_d_architecture of NOM_ENTITE is
-- Déclarations de types de données
-- Déclarations de composants
-- Déclarations de signaux
-- Déclarations de constantes
-- Déclarations de fonctions
-- Déclarations de procédures
begin
-- Énoncés concurrents ou séquentiels
end nom_d_architecture;
\end{minted}

Les énoncés qui peuvent se trouver dans le corps de l'architecture (entre le \texttt{begin} et le \texttt{end} peuvent être des instanciations de composants, des assignations de signaux ou des énoncés de processus
\end{frame}

\begin{frame}[label={sec:orgab7c9c6},fragile]{Signaux et assignation}
 \begin{itemize}
\item Un signal représente en quelque sorte un «fil»
\item Une assignation comme \mintinline[frame=lines]{vhdl}{A <= NOT(B);} signifie que A et B sont des signaux reliés dont l'un est l'inverse logique de l'autre
\item Ainsi, \mintinline[frame=lines]{vhdl}{A <= B;} signifie que les deux signaux A et B auront la même valeur logique
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga1f17a2},fragile]{Notes sur la syntaxe}
 \begin{itemize}
\item Des expressions aussi complexes que désiré peuvent être écrites, en utilisant des parenthèses pour spécifier les priorités d'évaluation des opérations (si elles doivent être différentes de la priorité implicite de VHDL)
\item Les commentaires sont possibles: tout ce qui suit deux tirets (- -) est ignoré
\item Toutes les assignations doivent se terminer avec un point-virgule (;)
\end{itemize}

Voici des exemples d'expressions
\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
a <= ((b and c and f) or (t nor r)) nand p;
a(3 downto 0) <=
b(4 downto 1) when (p and q)
else (p & q & q & p);
\end{minted}
\end{frame}


\begin{frame}[label={sec:org8e3fd6e},fragile]{Autres exemples d'assignations}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
A <= B OR C;
A <= B AND C;
A <= B NOR C;
A <= B NAND C;
A <= B XOR C;
A <= NOT B; --ceci est un commentaire
A <= (B AND C) OR (D AND E); --(aucune priorité 
                             -- préétablie de AND/OR)
\end{minted}

\begin{itemize}
\item Les parenthèses permettent de préciser l'ordre des opérations
\item Nous nous contenterons de ces opérations pour le moment
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgc857a95},fragile]{Priorité d'opérations et associativité}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
A <= B AND C AND D; -- ceci fonctionne

A <= B NAND C NAND D; -- pas ceci: NAND n'est pas associatif

A <= NOT(B AND C AND D); -- ceci fonctionne
\end{minted}
\end{frame}


\begin{frame}[label={sec:org403e2b2}]{Assignations avec vecteurs de signaux}
\begin{itemize}
\item Voici encore d'autres exemples d'assignations
\item Le dernier de ces exemples fait appel à des vecteurs de signaux
\item Nous verrons plus loin comment définir ces regroupements de signaux
\item De façon générale, VHDL est insensible aux MAJUSCULES ou minuscules et ignore les espaces supplémentaires et sauts de lignes
\item On doit déclarer le type de tous les objets: signaux, constantes ou variables
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1b818c1},fragile]{Assignations avec vecteurs de signaux \ldots{} 2}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
Sum <= A XOR B XOR Cin;

Cout <= (A AND B) OR (A AND Cin);

Cout <= (A AND B) OR (A AND Cin) OR (B AND Cin);

a <= b when c else a; -- sélection (multiplexage)

a(6 downto 1) <= c & d(3 downto 0) & e; -- concaténation 
                                        -- bit-à-bit ("&")

\end{minted}
\end{frame}


\begin{frame}[label={sec:org9971599},fragile]{Concurrence}
 \begin{itemize}
\item Dans un corps d'architecture, les assignations sont \alert{concurrentes}
\item Par exemple, dans ce qui suit, les deux énoncés sont évalués en parallèle
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
q <= r nor qb; -- énoncé 1
qb <= s nor q; -- énoncé 2
\end{minted}

\begin{itemize}
\item Les valeurs pour q et qb sont continuellement mises à jour: dès qu'un des signaux à droite de l'assignation change (on dit qu'un évènement se produit sur le signal), l'énoncé est évalué de nouveau
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org815b55a}]{Énoncés concurrents}
\begin{itemize}
\item \alert{Ce n'est pas comme en programmation} où les énoncés sont évalués l'un après l'autre, une seule fois
\item Tous les énoncés concurrents sont continuellement évalués
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orge17f144},fragile]{Énoncés concurrents équivalents}
 \begin{itemize}
\item L'effet de ces énoncés sera exactement le même si on les place dans un autre ordre dans la description, comme ci-dessous
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
qb <= s nor q; -- énoncé 1
q <= r nor qb; -- énoncé 2
\end{minted}

\begin{itemize}
\item Le langage décrit à la base un circuit et non pas une procédure: toutes les portes sont toujours alimentées et les fils sont toujours connectés
\item L'ordre dans lequel on donne la description n'a \alert{aucune importance}
\item Nous verrons plus loin qu'il est aussi possible de définir des blocs dans lesquels l'exécution est séquentielle comme en programmation
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org524faad}]{Vecteurs de bits}
\begin{itemize}
\item Il est possible de grouper des signaux pour en faire des vecteurs, qui sont des groupes ordonnés de bits: un mot, un bus, etc.
\item De cette façon, les spécifications sont plus compactes et faciles à interpréter
\item La convention la plus naturelle ordonne les indices de bits 
A(msb) \(\longleftrightarrow\) A(lsb), mais l'ordre inverse est également possible
\item Il vaut mieux établir une convention et s'y tenir pour éviter les erreurs d'interprétation
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org148c55a},fragile]{Vecteur de bits}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
A(VALEUR_HAUTE downto VALEUR_BASSE)

A(15 downto 0) -- A comporte 16 bits

A(7 downto 3) -- 5 bits du milieu de A

A(0 to 7) -- A comporte 8 bits, énumérés de façon croissante
\end{minted}
\end{frame}


\begin{frame}[label={sec:org5d97f10},fragile]{Concaténation}
 L'opérateur de concaténation \texttt{\&} permet de combiner des groupes de bits

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
A(15 downto 0) <= B(7 downto 0) &
                  C(7 downto 0);
\end{minted}
\end{frame}

\begin{frame}[label={sec:orge3ddc24}]{Description compacte et lisibilité}
\begin{itemize}
\item Considérons par exemple la partie du calcul de somme de la description d'un additionneur 8 bits ci-dessous
\item Avec des déclarations adéquates, on peut écrire un calcul de somme plus compact
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgc63ec14},fragile]{Calcul de somme initial}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
Sum(7 downto 0) <= A(7 downto 0)
xor B(7 downto 0)
xor C(7 downto 0);

C(7 downto 0) <= (A(7 downto 0) and
B(7 downto 0)
)
or (A(7 downto 0) and
(C(6 downto 0) & Cin)
)
or (B(7 downto 0) and
(C(6 downto 0) & Cin)
);

Cout <= C(7);
\end{minted}
\end{frame}

\begin{frame}[label={sec:org8a6172c},fragile]{Calcul de somme compact}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
Sum <= A xor B xor (C(6 downto 0) & Cin);

C <= (A and B) or
(A and (C(6 downto 0) & Cin) ) or
(B and (C(6 downto 0) & Cin) );

Cout <= C(7);
\end{minted}
\end{frame}

\begin{frame}[label={sec:orga3b737c}]{Modèle complet}
\begin{itemize}
\item Considérons la bascule JK maître-esclave de la figure \ref{fig:org4386d95} ci-dessous, construite au moyen de portes simples
\item Un modèle VHDL complet pour cette bascule JK maître-esclave est donné ensuite
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{../Images_svg/JK-MS}
\caption{\label{fig:org4386d95}Bascule JK maître-esclave à modéliser}
\end{figure}
\end{frame}

\begin{frame}[label={sec:org94f0368},fragile]{Bascule JK maître-esclave}
 \begin{minted}[linenos,firstnumber=1,frame=lines,fontsize=\scriptsize]{vhdl}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
-- Bascule JK maître-esclave.
-- La bascule maître mémorise sur une horloge haute, 
-- la bascule esclave mémorise sur une horloge basse. 
-- Les deux rétroactions évitent les conditions 
-- interdites aux entrées 
entity mainJK is
  port (
    J: in std_logic; -- entrée J (set) de la bascule
    C: in std_logic; -- entrée d'horloge
    K: in std_logic; -- entrée K (reset) de la bascule
    Q: out std_logic; -- bit stocké
    notQ: out std_logic -- inverse du bit stocké
    );
end mainJK;
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgd03bb0f},fragile]{Bascule JK maître-esclave \ldots{} 2}
 \begin{minted}[linenos,firstnumber=18,frame=lines,fontsize=\scriptsize]{vhdl}
architecture Complet of mainJK is
  signal notQ_temp: std_logic;
  signal Q_temp: std_logic;
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
begin
  s0 <= NOT C;
  s2 <= NOT ((notQ_temp AND J AND C) OR s1);
  s1 <= NOT (s2 OR (C AND K AND Q_temp));
  Q_temp <= NOT ((s2 AND s0) OR notQ_temp);
  notQ_temp <= NOT (Q_temp OR (s0 AND s1));
  Q <= Q_temp;
  notQ <= notQ_temp;
end Complet;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org25f088b},fragile]{Modèle comportemental}
 \begin{itemize}
\item Un modèle comportemental d'une entité est un ensemble d'énoncés qui sont exécutés séquentiellement
\item Ces énoncés peuvent se trouver dans des blocs \texttt{process, function} ou \texttt{procedure}
\item Un tel bloc est concurrent avec les autres énoncés du modèle général
\item Il est possible d'utiliser des variables à l'intérieur des processus
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgf86b72a}]{Modèle comportemental \ldots{} 2}
\begin{itemize}
\item Un énoncé d'assignation spécifique aux variables permet d'assigner (sans délai) une valeur à une variable qui a été préalablement déclarée
\item On se rapproche alors de la programmation traditionnelle
\item Les variables sont locales aux processus
\item Dans un bloc processus, il est possible d'avoir des boucles, des branchements conditionnels, etc.
\item Dans le corps de l'entité, un bloc processus apparaît comme une grosse porte logique arbitrairement définie lors de la conception du bloc
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgc125c61}]{Modèle flux de données}
\begin{itemize}
\item Dans un modèle flux de données, c'est le mouvement des données qui est exprimé par un ensemble d'énoncés concurrents
\item On peut faire appel à des opérateurs logiques AND, OR, NOT, etc., pour décrire les relations entre les signaux
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org55128ae}]{Modèle structural}
\begin{itemize}
\item Un modèle structural décrit des ensembles de composants interconnectés
\item Un énoncé d'instanciation d'un composant (qui revient à dire quelque chose comme «utiliser le composant X ici» est un énoncé concurrent qui indique de créer une instance de la «chose» spécifiée
\item Une telle description structurale se contente de préciser quels composants seront reliés à quels autres composants, sans référence au comportement desdits composants
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org48513bc},fragile]{Modèle structural \ldots{} 2}
 \begin{itemize}
\item Les énoncés qui suivent le \alert{begin} spécifient l'instanciation de composants et les interconnexions
\item Un énoncé d'instanciation de composant crée un nouveau niveau hiérarchique
\item Chaque ligne commence avec un \texttt{nom d'instance}, suivi d'un deux-points (':'), d'un nom de composant et du mot réservé \alert{\texttt{port map}}
\item Ce \texttt{port map} spécifie les interconnexions du composant
\item Rappelons que l'ordre de ces énoncés est sans conséquences
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org61fbc72},fragile]{Bloc processus}
 \begin{itemize}
\item Un énoncé \texttt{process} permet de définir un processus
\item Le format est le suivant
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org6d06b74},fragile]{Bloc processus}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
[etiquette_processus:] process [ (liste_sensibilité) ] [is]
[déclarations_processus]
begin
--   liste d'énoncés séquentiels tels que:
-- assignations de signaux 
-- assignations de variables
-- énoncés /case/
-- énoncés /exit/
-- énoncés /if/ 
-- énoncés /loop/ 
-- énoncés /next/
-- énoncés /null/
-- appels de procedure
-- énoncés /wait/
end process [etiquette_processus];
\end{minted}
\end{frame}

\begin{frame}[label={sec:org34b8a7f}]{Bascule D, front montant, mise à zéro asynchrone}
Voici un exemple d'un modèle avec bloc processus d'une bascule D déclenchée sur un front montant avec mise à zéro asynchrone
\end{frame}

\begin{frame}[label={sec:org361b1b9},fragile]{Bascule D, front montant, mise à zéro asynchrone \ldots{} 2}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
library ieee;
use ieee.std_logic_1164.all;

entity DFF_CLEAR is
   port (CLK, CLEAR, D : in std_logic;
      Q : out std_logic);
end DFF_CLEAR;

architecture COMPORT_DFF of DFF_CLEAR is
begin
DFF_PROCESS: process (CLK, CLEAR)
   begin
      if (CLEAR = '1') then
         Q <= '0';
      elsif (CLK'event and CLK = '1') then
         Q <= D;
      end if;
   end process;
end COMPORT_DFF;
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgc7bde94},fragile]{Bascule D, front montant, mise à zéro asynchrone \ldots{} 3}
 \begin{itemize}
\item Le processus, déclaré à l'intérieur d'une architecture, est un énoncé concurrent
\item Mais tout ce qui se déroule à l'intérieur du processus est exécuté de façon séquentielle
\item Comme tout énoncé concurrent, le processus lit et écrit des signaux sur ses ports d'interface
\item Dans l'exemple précédent, la sortie Q reçoit des valeurs par assignation au sein du processus
\item L'expression \texttt{CLK'*event* *and* CLK = '1'} teste une condition de front montant sur l'interface d'entrée CLK
\item Il ne peut pas y avoir de déclarations de signaux dans un processus; seules des variables ou des constantes peuvent être déclarées
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org681026d},fragile]{Bascule D, front montant, mise à zéro asynchrone \ldots{} 4}
 \begin{itemize}
\item Une \alert{liste de sensibilité} est un ensemble de signaux qui déclenchent l'exécution du processus
\item N'importe quel changement sur un des signaux de la liste provoque l'exécution immédiate du processus
\item S'il n'y a pas de liste de sensibilité, il faudra inclure un énoncé \texttt{wait} pour s'assurer que le processus se termine
\item Il n'est pas permis d'avoir à la fois une liste de sensibilité et un énoncé \texttt{wait} pour un même processus
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgb596877},fragile]{Bascule D, front montant, mise à zéro asynchrone \ldots{} 5}
 \begin{itemize}
\item Les variables et constantes utilisées dans le processus sont définies dans la portion \texttt{déclarations\_processus}
\item Les énoncés entre \alert{\texttt{begin}} et \alert{\texttt{end}} sont exécutés séquentiellement
\item Les assignations de variables, dénotées :=, sont exécutées immédiatement
\item Un énoncé concurrent est comme un processus d'une seule ligne, dont la liste de sensibilité est constituée de tous les signaux qui sont à droite de l'assignation
\item Il est possible de définir un processus dont le corps est une description combinatoire
\item Par exemple, le processus suivant permet de modéliser une porte OU entre les entrées a et b
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org56f7d11},fragile]{Processus avec porte OU combinatoire}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
proc1: process
  begin
    wait on a, b;
    s <= a or b;
  end process proc1;
\end{minted}

La sensibilité d'un tel processus (ici obtenue au moyen de l'énoncé \texttt{wait on a, b;)} doit comporter tous les signaux utilisés pour que l'exécution se fasse dès qu'une des entrées change de valeur
\end{frame}

\begin{frame}[label={sec:org322b615}]{Processus avec porte OU combinatoire \ldots{} 2}
\begin{itemize}
\item Les assignations de signaux dans un processus ne prennent effet qu'une fois que le processus est suspendu
\item Cela veut notamment dire que c'est seulement la dernière assignation à un signal donné qui sera effectivement exécutée
\item Si un processus effectue une lecture d'un signal qui se verra aussi assigner une valeur par le processus, la lecture prendra en compte la valeur précédente du signal \alert{avant} qu'il soit affecté par l'assignation
\item Il est donc possible de créer de la rétroaction au sein d'un même processus
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgccc720c}]{Modélisation du délai}
Deux formes de délai peuvent être modélisés en VHDL: le délai inertiel et le délai de transport
\end{frame}

\begin{frame}[label={sec:org02a5476},fragile]{Délai inertiel}
 \begin{itemize}
\item Le délai inertiel est la forme de délai par défaut
\item Le mot réservé \texttt{after} suppose par défaut un délai inertiel
\item Avec du délai inertiel, deux changements consécutifs du signal d'entrée qui sont plus rapprochés temporellement que la valeur de délai ne seront pas reflétés sur le signal de sortie
\item On modélise alors une inertie du circuit, qui est trop lent pour réagir lorsque les changements d'entrée sont trop rapides pour lui
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org5e09e43},fragile]{Délai inertiel \ldots{} 2}
 \begin{itemize}
\item Par exemple, avec une assignation comme la suivante:
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
b <= a after 30 ns;
\end{minted}

\begin{itemize}
\item Si le signal a passe de '0' à '1' à 10 ns et de '1' à '0' à 20 ns, la sortie ne changera pas du tout et restera tout le temps à '0'
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org9566e43},fragile]{Délai de transport}
 \begin{itemize}
\item Le délai de transport applique un retard dans le signal de sortie
\item Par exemple, avec la spécification suivante:
\end{itemize}


\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
b <= transport a after 20 ns;
\end{minted}

\begin{itemize}
\item Si le signal a passe de '0' à '1' à 10 ns et de '1' à '0' à 20 ns, la sortie passera de '0' à '1' à 30 ns et de '1' à '0' à 40 ns, reproduisant en sortie la même forme d'onde qu'en entrée, mais retardée de 20 ns
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org7fe1dcf},fragile]{Librairies}
 \begin{itemize}
\item Des librairies de types peuvent être définies pour préciser des types d'objets qui pourront ensuite être utilisés de façon standard
\item Par exemple, la librairie IEEE \texttt{std\_logic\_1164} définit le type logique \texttt{std\_logic} qui apporte plus de nuances que le simple type binaire, qui lui ne comporte que deux valeurs numériques '0' et '1'
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgd9af7d4},fragile]{Librairies: valeurs pour \texttt{std\_logic}}
 Le tableau suivant donne la liste des valeurs possibles avec
\texttt{std\_logic}

\begin{table}[htbp]
\label{tab:org330a7b1}
\centering
\begin{tabular}{ll}
Symbole & Interprétation\\[0pt]
\hline
'1' & 1 Logique\\[0pt]
'0' & 0 Logique\\[0pt]
'Z' & Haute impédance\\[0pt]
'W' & Signal faible, indéterminé entre 0 ou 1\\[0pt]
'L' & 0 faible, \emph{pulldown}\\[0pt]
'H' & 1 faible, \emph{pullup}\\[0pt]
'-' & \emph{Don't care}\\[0pt]
'U' & Non initialisé\\[0pt]
'X' & Inconnu, conflit entre sources multiples\\[0pt]
\end{tabular}
\end{table}
\end{frame}

\begin{frame}[label={sec:org84c63d9},fragile]{Librairies: valeurs pour \texttt{std\_logic} \ldots{} 3}
 \begin{itemize}
\item Comme on peut le voir, les signaux pourront ainsi assumer des valeurs comme \texttt{Z} (haute impédance pour les signaux trois-états), \texttt{X} (pour valeur inconnue), \texttt{-} pour valeur facultative, etc.
\item Il y a même des nuances pour la solidité des valeurs logiques
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org622308e},fragile]{Déclaration de librairies}
 \begin{itemize}
\item Une clause \texttt{use} permet de spécifier les librairies à utiliser au début du fichier de spécification
\item Par exemple, le fichier VHDL pourrait commencer avec les déclarations du listage suivant:
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
\end{minted}

\begin{itemize}
\item Nous avons déjà vu un exemple de l'utilisation de librairies dans le modèle de la bascule JK maître-esclave
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgd9f0dfc}]{Encapsulation}
\begin{itemize}
\item Il est possible de grouper des énoncés et de les réutiliser au besoin, dans d'autres modèles
\item Ceci nous permet de «cacher» la description dans une boîte
\item Dans ce cas-ci, il s'agit d'un loquet SR construit avec des portes NOR
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgfe7410a},fragile]{Encapsulation}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
entity rs is
port(r, s: in bit; q, qb: out bit);
end rs;

architecture norlogic of rs is
begin
q <= r nor qb;
qb <= s nor q;
end nor_logic;
\end{minted}

\begin{itemize}
\item L'entité définie est un composant qui peut être utilisée dans d'autres circuits, à l'intérieur d'une hiérarchie de design
\item Voici comment on peut utiliser le composant loquet pour modéliser un loquet D
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org34b717d},fragile]{Utilisation d'un composant}
 \begin{minted}[linenos,firstnumber=1,frame=lines,fontsize=\scriptsize]{vhdl}
entity Dlatch is
port (clk,d: in bit; q,qb: out bit);
end Dlatch;

architecture test of Dlatch is
--
signal db, cr, cs: bit;
--
component rs_ff
port (r, s: in bit;
q, qb: out bit);
end component;
--
label rs0;
--
for rs0: rs_ff
use entity rs(nor_logic);
\end{minted}
\end{frame}

\begin{frame}[label={sec:org74e9bf8},fragile]{Utilisation d'un composant \ldots{} 2}
 \begin{minted}[linenos,firstnumber=18,frame=lines,fontsize=\scriptsize]{vhdl}
begin
db <= not d;
cr <= db and clk;
cs <= d and clk;
rs0: rs_ff port map(cr, cs, q, qb);
end test;
\end{minted}
\end{frame}


\begin{frame}[label={sec:org4d72951}]{Bascule maître-esclave structurale}
Voici un exemple de bascule maître-esclave conçue de façon structurale à partir du composant loquet
\end{frame}

\begin{frame}[label={sec:org3a2b1f4},fragile]{Bascule maître-esclave structurale \ldots{} 2}
 \begin{minted}[linenos,firstnumber=1,frame=lines,fontsize=\scriptsize]{vhdl}
entity MS is
port (clear,reset,set,clock: in bit;
q, qbar: out bit);
end MS;

architecture ms_struct of MS is
signal clrbar, r0, s0, q0, qbar0,
r1, s1, cbar: bit;
label rs0, rs1;
component rs_ff
port (r,s: in bit; q,qbar: out bit);
end component;
for rs0, rs1: rs_ff
use entity RS(nor_logic);
\end{minted}
\end{frame}



\begin{frame}[label={sec:orgaff556f},fragile]{Bascule maître-esclave structurale \ldots{} 3}
 \begin{minted}[linenos,firstnumber=16,frame=lines,fontsize=\scriptsize]{vhdl}
begin
clrbar <= not clear;
cbar <= not clock;
r0 <= (reset and clock) or clear;
s0 <= (set and clock) and clrbar;
rs0: rs_ff port map(r0,s0,q0,qbar0);
r1 <= (qbar0 and cbar) or clear;
s1 <= (q0 and cbar) and clrbar;
rs1: rs_ff port map(r1,s1,q,qbar);
end ms_struct;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org13e46d0}]{Compteur basé sur la bascule}
Voici un exemple de compteur élaboré à partir de cette bascule maître-esclave
\end{frame}

\begin{frame}[label={sec:orgb92c5a3},fragile]{Compteur basé sur la bascule \ldots{} 2}
 \begin{minted}[linenos,firstnumber=1,frame=lines,fontsize=\scriptsize]{vhdl}
entity CNTER is
port (clock, clear: in bit;
a: out bit_vector(3 downto 0));
end CNTER;

architecture count of CNTER is
signal b: bit_vector(3 downto 0);
component ms_ff
port (clr, r, s, c: in bit;
q, qbar: out bit);
end component;
label ms0, msl, ms2, ms3;
for ms0, msl, ms2, ms3: ms_ff
use entity MS(ms_struct);
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgf8aa4af},fragile]{Compteur basé sur la bascule \ldots{} 3}
 \begin{minted}[linenos,firstnumber=15,frame=lines,fontsize=\scriptsize]{vhdl}
begin
ms0: ms_ff port map(
clear,a(0),b(0),clock,a(0),b(0));
ms1: ms_ff port map(
clear,a(1),b(1),a(0),a(1),b(1));
ms2: ms_ff port map(
clear,a(2),b(2),a(1),a(2),b(2));
ms3: ms_ff port map(
clear,a(3),b(3),a(2),a(3),b(3));
end count;
\end{minted}
\end{frame}


\begin{frame}[label={sec:org34367ce}]{Description de design en VHDL}
\begin{itemize}
\item La description complète du système à simuler est placée dans un fichier avec extension .vhdl qui est ensuite compilé et simulé
\item On appelle cette description «fichier de design» ou «design» tout court
\item Un design en VHDL est un ensemble d'entités de conception
\item L'entité de plus haut niveau invoque les autres entités comme composants
\item Le design dans son ensemble est appelé «hiérarchie de design»
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgb17e98b}]{Multiplicateur huit bits}
\begin{itemize}
\item Voici l'exemple d'un multiplicateur huit bits construit à partir de plusieurs autres composants
\item Les listages qui suivent donnent le détail de la modélisation
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgacee3ad},fragile]{Multiplicateur 8 bits: entité \texttt{multiply}}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
entity multiply is
port (load, clock: in bit;
input1, input2: in
bit_vector(7 downto 0);
product: out
bit_vector(15 downto 0);
output_valid: out bit);
end multiply;

\end{minted}
\end{frame}

\begin{frame}[label={sec:org7d473ae},fragile]{Multiplicateur 8 bits: entité \texttt{adder}}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
entity adder is
port(a: in bit_vector(7 downto 0);
b: in bit_vector(7 downto 0);
cin: in bit;
sum: out bit_vector(7 downto 0)
cout: out bit) ;
end adder;
\end{minted}
\end{frame}


\begin{frame}[label={sec:org6f268f2},fragile]{Multiplicateur 8 bits: entité \texttt{D\_FF}}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
entity D_FF is
port(din: in bit_vector(7 downto 0)
dout: out bit_vector(7 downto 0)
enable: in bit);
end D_FF;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org8b1ece7},fragile]{Multiplicateur 8 bits: composant \texttt{adder}}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
architecture logic of adder is
signal cw, cx: bit_vector(7 downto 0);
--
begin
cw(0) <= cin;
cw(7 downto 1) <= cx(6 downto 1);
cx <= (a and b) or (a and cw) or (b and cw);
sum <= a xor b xor cw;
cout <= cx(7);
end logic;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org572826a},fragile]{Multiplicateur 8 bits: composant \texttt{D\_FF}}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
architecture edge of D_FF is
-- une bascule D de 8 bits de large
signal x, y, z, w, qb, e :
bit_vector(7 downto 0);
begin
e <= "11111111" when enable else 0;
x <= din nand y;
y <= e nand (not w);
z <= e nand w;
w <= z nand x;
dout <= z nand qb;
qb <= y nand dout;
end edge;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org7252792},fragile]{Multiplicateur 8 bits: déclarations}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
architecture mult of multiply is
signal mux1, mux2, mux3, mux4:
bit_vector(7 downto 0);
signal control, adder_out:
bit_vector(7 downto 0);
signal accum:
bit_vector(15 downto 0);
signal carry_out: bit;
label l1, l2, l3, l4;

component add
port (argl, arg2: in bitvec;
c_in: in bit;
result: out bitvec;
c_out: out bit);
end component;
for l4: add use entity adder(logic);
\end{minted}
\end{frame}

\begin{frame}[label={sec:org1c9e03d},fragile]{Multiplicateur 8 bits: déclarations \ldots{} 2}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
component latch
port (xin: in bitvec;
xout: out bitvec; enable: in bit);
end component;
for l1, l2, l3: latch use
entity D_FF(edge);
\end{minted}
\end{frame}


\begin{frame}[label={sec:org37a9994},fragile]{Multiplicateur 8 bits: descriptions}
 \begin{minted}[linenos,firstnumber=1,frame=lines,fontsize=\scriptsize]{vhdl}
begin mux1(7 downto 0) <= 255 when load else "0" & contro1(7 downto
1); l1: latch port map ( mux1, control, clock);

mux2 <= 0 when load else
carry_out & adder_out(7 downto 1);
l2: latch port map (
mux2, accum(15 downto 8), clock);

mux3 <= input2 when load else
adder_out(0) & accum(7 downto 1);
l3: latch port map (
mux3, accum(7 downto 0), clock);

mux4 <= input1 when accum(0) else 0;
l4: add port map (
mux4, accum(15 downto 8), "0",
adder_out, carry_out);
\end{minted}
\end{frame}

\begin{frame}[label={sec:org9f7edf0},fragile]{Multiplicateur 8 bits: descriptions \ldots{} 2}
 \begin{minted}[linenos,firstnumber=18,frame=lines,fontsize=\scriptsize]{vhdl}
output_valid <= not(control(0));
product <= accum when output_valid
else 0;
end mult;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org7e73c3e}]{Banc d'essai}
\begin{itemize}
\item Pour simuler un circuit avec un HDL, on doit lui appliquer des signaux aux entrées afin que le simulateur puisse générer les sorties correspondantes
\item Une description qui vise à générer ces signaux d'entrée est appelée un \alert{banc d'essai}
\end{itemize}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{../Images_png/banc_essai.png}
\caption{\label{fig:orgb7308f6}Banc d'essai}
\end{figure}
\end{frame}

\begin{frame}[label={sec:orgccf0895}]{Banc d'essai \ldots{} 2}
\begin{itemize}
\item Le bloc stimulus génère les signaux d'excitation qui sont appliqués aux entrées du modèle à tester
\item Un bloc se charge de valider les sorties observées, ce qui peut être fait automatiquement
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org1dc1b18},fragile]{Entité banc d'essai}
 On commence par définir une entité de niveau supérieur pour le banc d'essai

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
entity test_bench is

end entity test_bench;
\end{minted}

\begin{itemize}
\item L'entité ne comporte pas de ports, puisque le banc d'essai ne comporte pas d'entrées ou de sorties externes
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org9d60738},fragile]{Instanciation}
 \begin{itemize}
\item Il faut ensuite instancier le modèle à tester
\item L'instanciation peut se faire comme composant ou directement
\item À moins de vouloir définir un \texttt{package} pour le modèle à tester, le composant doit être défini \alert{avant} le code principal
\item Voici un exemple de déclaration d'instanciation par composant
\item Les noms de composant et de ports doivent correspondre à ceux du modèle à tester
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga31c7e4},fragile]{Banc d'essai: instanciation par composant}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
component and_gate is 
port ( 
   a : in std_logic; 
   b : in std_logic; 
   and_out : out std_logic 
); 
end component and_gate; 
\end{minted}
\end{frame}


\begin{frame}[label={sec:org8062334},fragile]{Composant lié}
 Le composant est ensuite relié au modèle de test

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
and_gate_instance: component and_gate
  port map (
    a       => signal_a,
    b       => signal_b,
    and_out => signal_and_out
  );
\end{minted}
\end{frame}

\begin{frame}[label={sec:org6d24d31},fragile]{Composant lié \ldots{} 2}
 \begin{itemize}
\item Chaque instanciation doit avoir son propre nom
\item Ici, c'est \texttt{and\_gate\_instance}
\item Les noms de signaux à gauche sont les noms des ports du composant
\item Les noms à droite sont les signaux qui sont reliés aux ports
\item Ces signaux doivent être déclarés avant utilisation et avoir le bon type
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org2ea6b4e},fragile]{Instanciation directe}
 Voici un exemple d'instanciation directe:

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
and_gate_instance: entity work.and_gate(ltr)
  port map (
    a       => signal_a,
    b       => signal_b,
    and_out => signal_and_out
  );
\end{minted}

\begin{itemize}
\item Dans ce cas, il faut également préciser la librairie et l'architecture pour le modèle à tester
\item Ici, la librairie est «work» et l'architecture est «ltr»
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgebd77d6},fragile]{Écoulement du temps}
 \begin{itemize}
\item Pour tester le modèle, on doit typiquement produire des signaux qui varient en fonction du temps
\item Pour ce faire, il est possible d'utiliser les énoncés \texttt{after} et \texttt{wait}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orge37602b}]{Type VHDL pour le temps}
Il existe un type prédéfini VHDL pour le temps, qui utilise les unités suivantes.  La plus petite unité de temps correspond à une femtoseconde (fs = \(10^{-15}\) seconde)

\begin{table}[htbp]
\label{tab:org4819039}
\centering
\begin{tabular}{ll}
Unité & Valeur\\[0pt]
\hline
fs & \\[0pt]
ps & 1000 fs\\[0pt]
ns & 1000 ps\\[0pt]
us & 1000 ns\\[0pt]
ms & 1000 us\\[0pt]
sec & 1000 ms\\[0pt]
min & 60 sec\\[0pt]
hr & 60 min\\[0pt]
\end{tabular}
\end{table}
\end{frame}



\begin{frame}[label={sec:org6e760cf},fragile]{Énoncés liés au temps}
 Voici des exemples d'énoncés liés au temps:

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
time_ex <= 100 ps; -- 100 picoseconds 
time_ex <= 1.2 ns; -- 1200 picoseconds
time_ex <= 1.2 sec; -- 1200 milliseconds
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgc1e71cc},fragile]{Énoncé \texttt{after}}
 \begin{itemize}
\item L'énoncé \texttt{after} ajoute un aspect temporel à une assignation
\item La partie de l'énoncé qui précède la virgule est une assignation qui fonctionne comme toute assignation normale
\item La deuxième partie de l'énoncé spécifie une nouvelle valeur pour le signal, qui prendra effet au temps (futur) indiqué
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
<signal> <= <valeur_initiale>, <valeur_finale> after <temps>;
\end{minted}
\end{frame}


\begin{frame}[label={sec:org978f8e5},fragile]{Signal de mise à zéro}
 Voici un exemple d'utilisation pour créer un signal de mise à zéro

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
reset <= '1', '0' after 1 us;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org39a0107},fragile]{Signal d'horloge}
 \begin{itemize}
\item L'exemple suivant montre une méthode simple pour générer un signal d'horloge
\item La période obtenue sera le double du délai, soit ici 20 ns.
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
clock <= not clock after 10 ns;
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgf0f3741},fragile]{Énoncé \texttt{wait}}
 \begin{itemize}
\item L'énoncé \texttt{wait} suspend l'exécution dans un bloc processus pendant un certain temps
\item Rappelons que le processus ne peut pas avoir de liste de sensibilité
\item Trois types d'usage de \texttt{wait} sont possibles
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
wait for <time>; 

wait until <condition> for <time>;

wait on <signal_name>;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org3b82de2},fragile]{Énoncé \texttt{wait} \ldots{} 2}
 \begin{itemize}
\item Dans le premier cas, l'exécution est stoppée pendant la durée indiquée
\item Dans le deuxième cas, l'exécution est stoppée jusqu'à ce que la condition soit remplie
\item Il est possible de fonder les conditions sur des macros pour les fronts montants \texttt{rising\_edge} ou descendants \texttt{falling\_edge}
\item La portion \texttt{for} est optionnelle
\item Elle permet de prévoir un temps d'attente maximal
\item L'attente s'arrêtera donc si la condition est remplie ou après l'écoulement du temps spécifié
\item Dans le troisième cas, on attend simplement qu'un évènement se produise sur le signal spécifié pour cesser l'attente
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orge2f96d5},fragile]{Liste de signaux en attente d'évènement}
 Il est possible de spécifier une liste de signaux en les séparant par des virgules

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
wait on sig_a, sig_b;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org61b664b}]{Exemples de banc d'essai}
Testons un circuit séquentiel simple comportant deux entrées A et B qui passent par une porte ET et une bascule avec sortie Q
\end{frame}

\begin{frame}[label={sec:org2f1dd87},fragile]{Création d'une entité vide pour le banc d'essai}
 L'extrait de code suivant montre le point de départ de notre banc d'essai

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
entity exemple_tb is
end entity exemple_tb;

architecture test of exemple_tb is

--

end architecture exemple_tb;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org586a485},fragile]{Instanciation du modèle à tester}
 \begin{itemize}
\item Nous faisons une instanciation directe
\item L'extrait de code suivant montre comment la spécifier, en supposant que les signaux \texttt{in\_a, in\_b} et \texttt{out\_q} ont été déclarés précédemment
\end{itemize}

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
-- Instanciation du modèle à tester 
dut: entity work.exemple_design(rtl)
  port map (
    a => in_a,
    b => in_b,
    q => out_q
   );
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgc56f015}]{Génération de l'horloge et du signal de mise à zéro}
\begin{itemize}
\item Il faut ensuite générer les signaux d'horloge et de mise à zéro, en spécifiant les éléments temporels
\item Les deux signaux seront définis de façon concurrente
\item Nous prévoyons une inversion d'horloge à toutes les 10 ns, ce qui donne une période de 20 ns qui correspond à une fréquence de 50 MHz
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org0b0c811},fragile]{Génération de signaux de test}
 L'extrait de code suivant montre les détails

\begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
-- Reset et clock
clock <= not clock after 10 ns;
reset <= '1', '0' after 50 ns;
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgd38f61e}]{Stimulus}
\begin{itemize}
\item Le dernier élément à spécifier est le stimulus, c'est-à-dire les signaux qui seront appliqués aux entrées de notre modèle à tester
\item Nous utilisons un processus pour générer les quatre combinaisons possibles de nos deux entrées
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgb378acd},fragile]{Stimulus pour entrées}
 \begin{minted}[frame=lines,fontsize=\scriptsize]{vhdl}
  -- Génération du stimulus
  stimulus:
  process begin
    -- Attendre que reset soit activé
    wait until (reset = '0');

    -- Générer chaque condition, avec 2 périodes entre chaque
    -- itération pour laisser du temps pour la propagation
    and_in <= "00";
    wait for 20 ns;
    and_in <= "01";
    wait for 20 ns;
    and_in <= "10";
    wait for 20 ns;
    and_in <= "11";
    -- Fin du test
    wait;
  end process stimulus;
end architecture exemple_tb;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org2ceea76},fragile]{Exemples complets: 1}
 Dans le premier exemple, nous faisons appel ici au mot réservé \texttt{alias} qui permet de rendre le code plus facile à comprendre en nommant un sous-ensemble du type \texttt{array} qui a été utilisé pour générer les combinaisons d'entrées
\end{frame}

\begin{frame}[label={sec:org3e9a6f1},fragile]{Premier exemple complet de banc d'essai}
 \begin{minted}[linenos,firstnumber=1,frame=lines,fontsize=\scriptsize]{vhdl}
entity exemple_tb is
end entity exemple_tb;

architecture test of exemple_tb is
  signal clock  : std_logic := '0';
  signal reset  : std_logic := '1';
  signal and_in : std_logic_vector(1 down 0) := (others => '0');
  alias in_a is and_in(0);
  alias in_b is and_in(1);
  signal out_q  : std_logic;
begin
  -- Reset et clock
  clock <= not clock after 10 ns;
  reset <= '1', '0' after 50 ns;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org28efe50},fragile]{Premier exemple complet de banc d'essai \ldots{} 2}
 \begin{minted}[linenos,firstnumber=15,frame=lines,fontsize=\scriptsize]{vhdl}
-- Instanciation du modèle à tester 
dut: entity work.exemple_design(rtl)
  port map (
    a => in_a,
    b => in_b,
    q => out_q );
\end{minted}
\end{frame}


\begin{frame}[label={sec:org8a270cc},fragile]{Premier exemple complet de banc d'essai \ldots{} 3}
 \begin{minted}[linenos,firstnumber=21,frame=lines,fontsize=\scriptsize]{vhdl}
  -- Génération du stimulus
  stimulus:
  process begin
    wait until (reset = '0');  -- Attendre reset relâché
    -- Générer chaque condition, avec 2 périodes entre chaque
    -- itération pour laisser du temps pour la propagation
    and_in <= "00";
    wait for 2 ns;
    and_in <= "01";
    wait for 2 ns;
    and_in <= "10";
    wait for 2 ns;
    and_in <= "11";
    -- Fin du test
    wait;
  end process stimulus;
end architecture exemple_tb;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org0886328}]{Deuxième exemple complet de banc d'essai}
\begin{itemize}
\item Le listage du deuxième exemple de banc d'essai, qui teste le fonctionnement d'un compteur haut/bas de quatre bits modélisé de façon comportementale, est présenté en trois portions
\item Une façon différente de générer le signal d'horloge y est utilisée
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgd03568c},fragile]{Deuxième exemple complet de banc d'essai, portion 1}
 \begin{minted}[linenos,firstnumber=1,frame=lines,fontsize=\scriptsize]{vhdl}

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity up_down_counter is
  port( clock : in std_logic;
        reset : in std_logic;
        up_down : in std_logic;
        counter : out std_logic_vector(3 downto 0));
end up_down_counter;

\end{minted}
\end{frame}

\begin{frame}[label={sec:org813ff65},fragile]{Deuxième exemple complet de banc d'essai, portion 2}
 \begin{minted}[linenos,firstnumber=11,frame=lines,fontsize=\scriptsize]{vhdl}
architecture bhv of up_down_counter is
  signal t_count: unsigned(3 downto 0);
begin
  process (clock, reset)
  begin
    if (reset='1') then
      t_count <= "0000";
    elsif rising_edge(clock) then
      if up_down = '0' then
        t_count <= t_count + 1;
      else
        t_count <= t_count - 1;
      end if;
    end if;
  end process;

  counter <= std_logic_vector(t_count);
end bhv;
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgbc7c6e8},fragile]{Deuxième exemple complet de banc d'essai, portion 3}
 \begin{minted}[linenos,firstnumber=29,frame=lines,fontsize=\scriptsize]{vhdl}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_up_down is
end tb_up_down;
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgaeba643},fragile]{Deuxième exemple complet de banc d'essai, portion 4}
 \begin{minted}[linenos,firstnumber=35,frame=lines,fontsize=\scriptsize]{vhdl}
architecture behavior of tb_up_down is

-- déclaration de composant pour le modèle à tester
component up_down_counter
port(
clock : in std_logic;
reset : in std_logic;
up_down : in std_logic;
counter : out std_logic_vector(3 downto 0)
);
end component up_down_counter;

\end{minted}
\end{frame}

\begin{frame}[label={sec:org410daf0},fragile]{Deuxième exemple complet de banc d'essai, portion 5}
 \begin{minted}[linenos,firstnumber=46,frame=lines,fontsize=\scriptsize]{vhdl}
--Inputs
signal clock : std_logic := '0';
signal reset : std_logic := '0';
signal up_down : std_logic := '0';

--Outputs
signal counter : std_logic_vector(3 downto 0);

-- Clock period definitions
constant clock_period : time := 20 ns;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org4367238},fragile]{Deuxième exemple complet de banc d'essai, portion 6}
 \begin{minted}[linenos,firstnumber=56,frame=lines,fontsize=\scriptsize]{vhdl}
begin

-- Instanciation du composant à tester
uut: component up_down_counter
  port map (
    clock => clock,
    reset => reset,
    up_down => up_down,
    counter => counter
);
\end{minted}
\end{frame}

\begin{frame}[label={sec:org4fe32a1},fragile]{Deuxième exemple complet de banc d'essai, portion 7}
 \begin{minted}[linenos,firstnumber=66,frame=lines,fontsize=\scriptsize]{vhdl}
-- Processus d'horloge
clock_process: process
begin
clock <= '0';
wait for clock_period/2;
clock <= '1';
wait for clock_period/2;
end process;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org7d4d946},fragile]{Deuxième exemple complet de banc d'essai, portion 8}
 \begin{minted}[linenos,firstnumber=74,frame=lines,fontsize=\scriptsize]{vhdl}
-- Processus de stimulus
stim_proc: process
begin
-- hold reset state for 100 ns.
wait for 20 ns;
reset <= '1';
wait for 20 ns;
reset <= '0';
up_down <= '0';
wait for 200 ns;
up_down <= '1';
wait;
end process;

end;
\end{minted}
\end{frame}

\begin{frame}[label={sec:orgbe1f716}]{Compilation et simulation}
Voici enfin les grandes étapes permettant de passer de la spécification d'un modèle à une simulation du comportement du circuit modélisé
\end{frame}

\begin{frame}[label={sec:orge1d9ffd}]{Créer un fichier VHDL}
\begin{itemize}
\item Ce fichier ne contient qu'une seule paire entité.architecture de niveau supérieur, qui sera le banc d'essai
\item Il y aura typiquement d'autres entités de niveau inférieur, notamment le modèle de circuit à simuler
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org0c5752e},fragile]{Entité de niveau supérieur}
 \begin{minted}[frame=lines,fontsize=\footnotesize]{vhdl}
entity MACHIN is
...
end MACHIN;

architecture TRUC of MACHIN is
...
end TRUC;
\end{minted}
\end{frame}

\begin{frame}[label={sec:org2a9d8dd}]{Compiler cette description}
\begin{itemize}
\item Les commandes à utiliser dépendent du simulateur qui est utilisé, mais deux étapes sont normalement requises:
\begin{itemize}
\item l'\alert{analyse} du code source
\item l'\alert{élaboration} du design
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgfc8663f}]{Simuler}
\begin{itemize}
\item Une fois le design élaboré, on peut \alert{simuler} le résultat
\item Si le simulateur ne permet pas directement la visualisation des résultats, il faudra sauvegarder les résultats de simulation sous un format qui permettra ensuite de les visualiser avec un autre outil
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgd964903}]{Visualiser}
\begin{itemize}
\item Pour \alert{visualiser} le résultat, on peut utiliser un outil intégré ou encore un outil externe qui permet de visualiser les signaux obtenus  (formes d'ondes, résultats interprétés)
\end{itemize}
\end{frame}

\section{Préparation et simulation des modèles VHDL}
\label{sec:org399c076}

\begin{frame}[label={sec:org2e2cade}]{Éditeurs}
\begin{itemize}
\item N'importe quel éditeur de programmation peut être utilisé pour éditer les modèles VHDL
\item Certains simulateurs comportent un éditeur intégré
\item Il peut être avantageux d'utiliser un éditeur avec fonction de surlignage syntaxique pour le langage
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orgfa1b210}]{Simulateurs gratuits}
Voici quelques simulateurs gratuits 
\end{frame}

\begin{frame}[label={sec:orgaa12312}]{Modelsim/Questa}
Des versions de ce simulateur sont offertes par plusieurs fabricants de circuits intégrés programmables

\begin{itemize}
\item Intel
\item Lattice
\item Microchip
\end{itemize}
\end{frame}


\begin{frame}[label={sec:org41adac2}]{Modelsim/Questa (Intel)}
\href{https://www.intel.com/content/www/us/en/collections/products/fpga/software/downloads.html?s=Newest\&f=\%255B\%257B\%2522name\%2522\%3A\%2522quartusedition\%2522\%2C\%2522facetId\%2522\%3A\%2522quartusedition\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522name\%2522\%3A\%2522quartusaddon\%2522\%2C\%2522facetId\%2522\%3A\%2522quartusaddon\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%257B\%2522value\%2522\%3A\%2522Intel\%25C2\%25AE\%2520FPGA\%2520Simulation\%2520Tools\%2522\%2C\%2522state\%2522\%3A\%2522idle\%2522\%2C\%2522children\%2522\%3A\%255B\%257B\%2522value\%2522\%3A\%2522Questa*-Intel\%25C2\%25AE\%2520FPGA\%2520Starter\%2520Edition\%2522\%2C\%2522state\%2522\%3A\%2522selected\%2522\%257D\%255D\%257D\%255D\%257D\%2C\%257B\%2522name\%2522\%3A\%2522fpgadevicefamily\%2522\%2C\%2522facetId\%2522\%3A\%2522fpgadevicefamily\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522name\%2522\%3A\%2522fpgaplatform\%2522\%2C\%2522facetId\%2522\%3A\%2522fpgaplatform\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522facetId\%2522\%3A\%2522os-rdc\%2522\%2C\%2522name\%2522\%3A\%2522OperatingSystem\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522facetId\%2522\%3A\%2522\%40emtcontenttype\_en\%2522\%2C\%2522name\%2522\%3A\%2522ContentType\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522facetId\%2522\%3A\%2522lastupdated-rdc\%2522\%2C\%2522name\%2522\%3A\%2522lastupdated\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%255D\&q=lite}{FPGA Software Download Center}

\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat ou Ubuntu)
\item Un des simulateurs les plus populaires
\item L'utilisation requiert une licence (gratuite) spécifique à un ordinateur donné, qu'il faut demander par courriel
\item L'installation et l'activation comportent plusieurs étapes
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org91d718a}]{Modelsim/Questa (Lattice)}
\href{http://www.latticesemi.com/icecube2}{iCEcube2 Design Software}

\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat)
\item Fait partie d'une suite logicielle en support à la gamme de FPGA du fabricant
\item L'utilisation requiert une licence (gratuite) spécifique à un ordinateur donné
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orge5d502e}]{Modelsim/Questa (Microchip)}
\href{https://www.microchip.com/en-us/products/fpgas-and-plds/fpga-and-soc-design-tools/fpga/libero-software-later-versions\#downloads}{Libero SoC Design Suite}

\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat)
\item Fait partie d'un suite logicielle (Libero) en support à la gamme de FPGA du fabricant
\item L'utilisation requiert une licence (gratuite) spécifique à un ordinateur donné
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga87b226}]{Active-HDL (version étudiante)}
\href{https://www.aldec.com/en/products/fpga\_simulation/active\_hdl\_student}{Free Active-HDL Student Edition}

\begin{itemize}
\item Fonctionne sous Windows
\item Licence gratuite pour la communauté étudiante (on doit indiquer son université)
\item L'inscription donne accès à une page de téléchargement
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org7f97c36}]{Vivado (Xilinx)}
\href{https://www.xilinx.com/support/download.html}{Xilinx téléchargements}

\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat ou Ubuntu)
\item Cette suite pour conception de circuits intégrés programmables comporte un simulateur
\item L'utilisation requiert une licence (gratuite) spécifique à un ordinateur donné
\end{itemize}
\end{frame}

\begin{frame}[label={sec:orga68bd2c}]{GHDL/GTKWave}
\url{http://ghdl.free.fr/}

\url{https://github.com/ghdl/ghdl}

\url{http://gtkwave.sourceforge.net/}

\url{https://github.com/gtkwave/gtkwave}

Ces deux logiciels sont à code source ouvert, donc entièrement gratuits

\begin{itemize}
\item Fonctionnent sous Windows, Mac ou Linux
\item GHDL est utilisé pour la simulation
\item GTKWave est utilisé pour visualiser les résultats
\end{itemize}
\end{frame}

\begin{frame}[label={sec:org614139c}]{EDA Playground}
\href{https://www.edaplayground.com/n}{EDA Playground}

\begin{itemize}
\item Cette option, utilisable via un fureteur Web, ne nécessite pas d'installation et peut donc s'utiliser sur toutes les plateformes
\item On doit s'enregistrer
\item Il est possible de choisir le simulateur
\item On y trouve également des exemples de codes
\end{itemize}
\end{frame}
\end{document}