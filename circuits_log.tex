% Created 2023-10-26 jeu 15:25
% Intended LaTeX compiler: pdflatex
\documentclass[letter, oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[a-1b]{pdfx}
\usepackage[, french]{babel}
\frenchbsetup{og=«,fg=»}
\usepackage{newunicodechar}
\newunicodechar{−}{\textemdash}
\usepackage{svg}
\usepackage{titlesec}
\addto\captionsfrench{\renewcommand{\listfigurename}{Liste des figures}}
\renewcommand\listoflistingscaption{Liste des listages}
\renewcommand{\listingscaption}{Listage}% Listing -> Listage (avec minted)
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[R]{\rightmark}
\fancyfoot[L]{\includegraphics[width=1cm]{by-sa.png}}
\fancyfoot[C]{\thepage}
\AtBeginEnvironment{minted}{\renewcommand{\fcolorbox}[4][]{#4}}
\author{Guy Bégin}
\date{\today}
\title{Circuits logiques combinatoires et séquentiels}
\hypersetup{
 pdfauthor={Guy Bégin},
 pdftitle={Circuits logiques combinatoires et séquentiels},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.1 (Org mode 9.6.6)}, 
 pdflang={French}}
\begin{document}


%----------------------------------------------------------------------------------------
%	Page titre
%----------------------------------------------------------------------------------------

\titlepage 
	{\includegraphics[width=0.45\paperwidth]{image_final/final/couverture_sans-text.png}} % Insertion de l'image 
	{ % titre, auteur
		\centering\sffamily % Police 
		{\Huge\bfseries Circuits logiques combinatoires et séquentiels\par} % Book title
		\vspace{16pt} % Espace vertical
%		{\LARGE \par} % sous-titre
		\vspace{24pt} 
		{\huge\bfseries Guy Bégin\par} % Auteur
	}

%----------------------------------------------------------------------------------------
%	COPYRIGHT
%----------------------------------------------------------------------------------------

\thispagestyle{empty} % élimination des en-têtes et pied de pages

~\vfill % place le tout en bas de page

\noindent Copyright \copyright\ 2023 Guy Bégin\\ % Copyright 

%\noindent \textsc{éditeur}\\ % éditeur

\noindent 
Le contenu de ce manuel électronique est
disponible en vertu des conditions de la
\href{https://creativecommons.org/licenses/by-sa/4.0/deed.fr}{Licence
Creative Commons Attribution - Partage dans les mêmes conditions 4.0
International}.

Vous êtes autorisé à : 

\begin{description}
\item[{Partager}] – Copier, distribuer et communiquer le matériel par tous
moyens et sous tous formats.
\item[{Adapter}] – Remixer, transformer et créer à partir du matériel pour
toute utilisation, y compris commerciale.
\end{description}

Selon les conditions suivantes :

\begin{description}
\item[{Paternité}] – Vous devez citer le nom de l'auteur original.
\item[{Mêmes conditions}] – Si vous remixez, transformez, ou créez à
partir du matériel composant l'Oeuvre originale, vous devez diffuser
l'Oeuvre modifiée avec la même licence.
\end{description}

\noindent \textit{Octobre 2023} %  date

\chapter*{Avant-propos}
\label{sec:org5605d4a}
Ce manuel a été rédigé en fonction de deux objectifs distincts mais
reliés. Le premier objectif était de produire un manuel de qualité, en
français, sur un sujet fondamental en électronique numérique et d'en
faire une \emph{Ressource éducative libre (REL)}. Une recherche préalable
nous avait en effet permis de constater qu'il existe peu de manuels
récents de ce type sur le sujet. En offrant une telle ressource à la
communauté, nous espérons contribuer à rendre plus accessible la
formation dans ce domaine technologique important.

Le deuxième objectif était d'expérimenter avec une méthode de
travail permettant d'élaborer de telles ressources éducatives en
faisant appel à un ensemble d'outils libres et universellement accessibles. Le
but était aussi de s'assurer de pouvoir obtenir un document ou un ensemble de
documents sources susceptibles d'en faciliter la réutilisation, la
révision et le remixage. Le manuel est donc appelé à devenir une
preuve de concept pour le processus d'élaboration qui a été utilisé.

La matière couverte dans ce manuel correspond d'assez près au contenu
du cours \href{https://etudier.uqam.ca/cours?sigle=MIC1065}{MIC1065 Circuits logiques}, offert dans le cadre du
\href{https://etudier.uqam.ca/programme?code=6526}{baccalauréat en systèmes informatiques et électroniques} de
l'\href{https://uqam.ca/}{Université du Québec à Montréal}. 

L'auteur, Guy Bégin, est professeur au département d'informatique de
l'Université du Québec à Montréal. Ses recherches l'ont toujours amené
à s'intéresser aux 0 et aux 1 si souvent rencontrés en circuits
logiques, mais également en télécommunications numériques, son champ
de recherche privilégié.

\section*{Remerciements}
\label{sec:org7645a87}

L'auteur souhaite remercier particulièrement Yves Munn (chargé de
projets technopédagogiques), Boris Nonveiller (bibliothécaire), Rachel
Rouleau (révision linguistique) et Émile Gauvin (étudiant au
baccalauréat en systèmes informatiques et électroniques). Ce manuel a
été réalisé avec le soutien de la \href{https://fabriquerel.org/}{fabriqueREL}.

\section*{Licence}
\label{sec:org7938172}

\begin{center}
\href{https://creativecommons.org/licenses/by/4.0/deed.fr}{\includesvg[width=0.5\linewidth]{by-sa}} 
\end{center}


Le contenu de ce manuel électronique est
disponible en vertu des conditions de la
\href{https://creativecommons.org/licenses/by-sa/4.0/deed.fr}{Licence
Creative Commons Attribution - Partage dans les mêmes conditions 4.0
International}.

Vous êtes autorisé à : 

\begin{description}
\item[{Partager}] – Copier, distribuer et communiquer le matériel par tous
moyens et sous tous formats.
\item[{Adapter}] – Remixer, transformer et créer à partir du matériel pour
toute utilisation, y compris commerciale.
\end{description}

Selon les conditions suivantes :

\begin{description}
\item[{Paternité}] – Vous devez citer le nom de l'auteur original.
\item[{Mêmes conditions}] – Si vous remixez, transformez, ou créez à
partir du matériel composant l'Oeuvre originale, vous devez diffuser
l'Oeuvre modifiée avec la même licence.
\end{description}


Pour citer cet ouvrage: Bégin, G. (2022), Circuits logiques
combinatoires et séquentiels. Université du Québec à Montréal. Licence CC BY-SA

\begin{center}
\href{https://uqam.ca/}{\includesvg[width=0.35\linewidth]{Logo_UQAM}} 
\end{center}

\section*{Ressources}
\label{sec:org8c7ac83}

Les logiciels libres suivants ont été utilisés à différentes étapes,
pour la rédaction et la préparation des modèles, des images et pour la
simulation:

\begin{itemize}
\item Rédaction et production
\begin{itemize}
\item \href{https://www.gnu.org/software/emacs/}{Emacs}
\item \href{https://www.latex-project.org/}{\LaTeX{}}
\item \href{https://git-scm.com}{Git}
\item \href{https://pandoc.org/}{Pandoc}
\end{itemize}
\item Schémas
\begin{itemize}
\item \href{https://graphviz.org/}{Graphviz}
\item \href{https://inkscape.org}{Inkscape}
\item \href{https://wavedrom.com/}{Wavedrom}
\item \href{https://schemdraw.readthedocs.io/en/latest/}{Schemdraw}
\item \href{https://ditaa.sourceforge.net/}{Ditaa}
\end{itemize}
\item Simulation logique
\begin{itemize}
\item \href{https://github.com/hneemann/Digital}{Simulateur Digital}
\end{itemize}
\item Coloration syntaxique
\begin{itemize}
\item \href{https://pygments.org/docs/quickstart/}{Pygments}
\end{itemize}
\end{itemize}

Dans le but de faciliter l'adaptation, la réutilisation, la révision
et le remixage de cette ressource éducative libre, les documents
sources utilisés pour produire ce manuel sont accessibles via le dépôt
Github \url{https://github.com/gbegin/circuits\_logiques/}. Le dépôt comporte
également des transparents pouvant être utilisés comme supports
d'enseignement.


\chapter*{Préface}
\label{sec:org683477d}
Ce manuel est une introduction au domaine de la conception des
circuits logiques, qui sont à la base de tous les systèmes numériques
modernes. Il s'adresse tout particulièrement aux personnes qui suivent
un enseignement technique, ou un premier cycle universitaire, ainsi
qu'à tous celles qui s'intéressent à l'ingénierie électronique.
Aucune connaissance préalable n'est requise pour pouvoir en assimiler
les concepts, mais une connaissance de la programmation permettra de
pousser l'expérimentation par simulation.

Les chapitres 1 à 3 de cet ouvrage sont consacrés aux concepts de base
de la logique binaire et des systèmes de numération. Ces notions sont
présentées d'un point de vue relativement abstrait qui n'est pas
étranger au fait que la logique binaire mise en oeuvre dans les
circuits numériques modernes est fondée sur des principes
mathématiques, voire philosophiques établis bien longtemps avant
l'invention de l'électronique.

Dans les trois chapitres suivants, on voit comment la logique peut
s'incarner dans des dispositifs électroniques: d'abord avec des portes
logiques simples (chapitre 4), et plus avant, avec des dispositifs
combinatoires plus complexes (chapitre 6). On présente également les
approches permettant de simplifier les circuits logiques
combinatoires, c'est-à-dire ceux dont le comportement ne dépend pas du
temps (chapitre 5).

Les circuits logiques séquentiels, qui, eux comportent de la
mémoire, sont considérés ensuite. On présente d'abord les loquets et
bascules, composants de base des circuits séquentiels (chapitre 7),
puis on aborde l'analyse (chapitre 8) et la conception (chapitre 9) de
circuits séquentiels synchrones. Le chapitre 10 présente de nombreux
types de circuits séquentiels typiques, alors que le chapitre 11 est
consacré aux différents types de mémoires.

Le chapitre 12 offre une brève introduction aux dispositifs logiques
programmables qui amènent les circuits logiques à un autre degré de
flexibilité et d'intégration.

Dans les chapitres 13 et 14, on s'intéresse à la modélisation de
circuits, en introduisant le langage descriptif VHDL, qui permet de
décrire formellement des circuits logiques pour en faire la
conception, la simulation, voire, la synthèse.

Le manuel se conclut avec des séries d'exercices (chapitre 15) qui
permettront de mettre en pratique les notions abordées.


\setcounter{tocdepth}{3}
\tableofcontents
\listoffigures
\listoftables
\listoflistings

\part{Circuits logiques combinatoires}
\label{sec:orgd0d47aa}
\chapter{Systèmes de numération}
\label{sec:org2695557}


\section{Objectifs}
\label{sec:org5aafb35}

\begin{itemize}
\item Comprendre le fonctionnement du système de numération binaire
\item Pouvoir effectuer des conversions entre nombres en représentation
binaire, octale, hexadécimale
\item Comprendre le rôle des compléments et la représentation de nombres signés
\item Comprendre la notation fractionnaire
\item Se familiariser avec quelques codes courants
\item Pouvoir effectuer des opérations arithmétiques sur des nombres binaires
\end{itemize}

\section{Systèmes numériques}
\label{sec:org4a83e6f}

Les systèmes numériques sont omniprésents dans notre monde
technologique. La grande force des systèmes numériques est leur
capacité à représenter l'information sous toutes ses formes et à
permettre la manipulation de cette information. Tout ensemble dont les
éléments peuvent être dénombrés, comme un alphabet ou un ensemble fini
de couleurs, se prête naturellement à une représentation
numérique. Mais il est également possible de représenter des
informations qui correspondent à des informations provenant
d'ensembles continus, comme par exemple des informations sonores, en
procédant à une numérisation par échantillonnage et codage. 

Une bonne façon de se familiariser avec la représentation numérique de
l'information est d'étudier le système de numération binaire. Dans un
chapitre suivant, nous étudierons les principes fondamentaux de la
logique binaire. C'est sur ces deux bases que nous pourrons établir
notre exploration des circuits logiques.

\section{Nombres binaires}
\label{sec:org4b9f68a}

Les nombres binaires sont essentiellement construits de la même façon
que les nombres décimaux qui nous sont plus familiers. La
différence fondamentale tient au fait qu'il n'est possible d'utiliser
que deux symboles (chiffres), 0 et 1, plutôt que les dix chiffres de 0
à 9. Les chiffres sont nommés bits (contraction de \textbf{b} inary dig
\textbf{it}).

Par exemple, le nombre décimal que nous écrivons \(2843\) correspond à
\(2 \times 1000 + 8 \times 100 + 4 \times 10 + 3 \times 1\). Il s'agit
d'un système positionnel, dans lequel la valeur attribuée à un chiffre
est définie par sa position et par la valeur de la \textbf{base} du système
de numération. Ainsi, pour ce nombre décimal, la base vaut 10 et on a
\(2 \times 10^3 + 8 \times 10^2 + 4 \times 10^1 + 3 \times 10^0\). La
position la plus à gauche est celle dont la valeur est la plus
grande. C'est le \textbf{chiffre le plus significatif}; la position de droite
correspond au \textbf{chiffre le moins significatif}. On peut imaginer une
virgule après le chiffre le moins significatif, pour délimiter la
partie entière du nombre. D'autres chiffres, placés à droite de cette
virgule correspondraient à la partie fractionnaire. Nous y reviendrons.

Les mêmes règles positionnelles permettent d'attribuer une valeur à un
nombre binaire, en tenant compte du fait que la base vaut cette
fois-ci 2. Par exemple, la valeur attribuée au nombre binaire
\(10101\) est 

$$ 1 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1
\times 2^0 = 16+4+1= 21 $$

comme on peut voir dans le tableau \ref{tab:org9f005c9}.

\begin{table}[htbp]
\caption{\label{tab:org9f005c9}Valeur binaire du nombre \(10101\)}
\centering
\begin{tabular}{lrrrrr}
Position & 4 & 3 & 2 & 1 & 0\\[0pt]
\hline
Valeur & \(2^4\) & \(2^3\) & \(2^2\) & \(2^1\) & \(2^0\)\\[0pt]
Valeur déc. & 16 & 8 & 4 & 2 & 1\\[0pt]
Bit & 1 & 0 & 1 & 0 & 1\\[0pt]
\end{tabular}
\end{table}

Nous avons ici le \textbf{bit le plus significatif} à gauche et le \textbf{bit le
moins significatif} à droite. Chaque chiffre vaut deux fois plus que le
chiffre immédiatement placé à sa droite.

\section{Conversion binaire <-> décimal}
\label{sec:org2e01cbd}

Convertir un nombre entier binaire en nombre décimal se fait
naturellement, en s'appuyant sur les valeurs associées à la notation
positionnelle. La conversion en sens inverse, de décimal à binaire,
est un peu moins évidente. La méthode consiste à faire une division
entière du nombre (et des quotients successifs) par 2 et à noter les
restes obtenus. Le premier reste correspond au bit le moins
significatif, et le dernier, au bit le plus significatif.

Par exemple, les opérations pour convertir 37 en binaire sont résumées
dans le tableau \ref{tab:orgd5e85f0}.

\begin{table}[htbp]
\caption{\label{tab:orgd5e85f0}Étapes de conversion de 37 en binaire}
\centering
\begin{tabular}{lrrl}
 & Quotient entier & Reste & Coefficient\\[0pt]
\hline
37/2 & 18 & 1 & \(a_0 = 1\)\\[0pt]
18/2 & 9 & 0 & \(a_1 = 0\)\\[0pt]
9/2 & 4 & 1 & \(a_2 = 1\)\\[0pt]
4/2 & 2 & 0 & \(a_3 = 0\)\\[0pt]
2/2 & 1 & 0 & \(a_4 = 0\)\\[0pt]
1/2 & 0 & 1 & \(a_5 = 1\)\\[0pt]
\end{tabular}
\end{table}

On obtient ainsi 100101.

\section{Notation}
\label{sec:org151c9de}

Puisque les notations de nombres binaires, octaux, hexadécimaux ou
décimaux font appel à des chiffres qui sont tous tirés du même
ensemble, il y a un risque d'ambiguïté si on ne connaît pas la base
utilisée. Par exemple 11 peut soit s'interpréter comme onze (si on
suppose la base 10) ou comme trois (si on suppose la base 2). À
moins que le contexte ne soit absolument clair, il vaut mieux être
explicite pour éviter de telles ambiguïtés. C'est pourquoi on dénote
souvent explicitement la base; par exemple, (11)2 pour le nombre
trois en binaire qui pourra être distingué de (11)10, le nombre onze
en décimal.

\section{Représentations compactes de nombres binaires}
\label{sec:orgdea9d8f}

En comparant un nombre décimal et sa représentation binaire, comme par
exemple ici 37 et 100101, on voit bien que la représentation binaire
est nettement plus encombrante. On utilise souvent des notations plus
compactes mais qui conservent un lien direct avec la représentation
binaire: la représentation \textbf{octale} et la représentation
\textbf{hexadécimale}.

\begin{enumerate}
\item Représentation octale
\label{sec:orge82bd69}

La représentation octale consiste à utiliser la base 8, avec les
chiffres \(0, 1, \ldots, 7\). On voit la correspondance entre les
nombres en binaire et les chiffres de la représentation octale dans le
tableau \ref{tab:org58240a0}.

\begin{table}[htbp]
\caption{\label{tab:org8be63b8}Représentation octale}
\centering
\begin{tabular}{rr}
Binaire & Octal\\[0pt]
\hline
000 & 0\\[0pt]
001 & 1\\[0pt]
010 & 2\\[0pt]
011 & 3\\[0pt]
100 & 4\\[0pt]
101 & 5\\[0pt]
110 & 6\\[0pt]
111 & 7\\[0pt]
\end{tabular}
\end{table}

Pour convertir un nombre binaire en nombre octal, il suffit de
regrouper les bits par groupes de trois bits, en partant de la droite
(bit le moins significatif), et de remplacer chaque groupe par le
chiffre en base 8 correspondant.

Par exemple, pour (1010011110001)2, on aura le découpage du tableau
\ref{tab:orgfea66ed}.

\begin{table}[htbp]
\caption{\label{tab:orgfea66ed}Regroupement pour conversion en octal}
\centering
\begin{tabular}{lrrrrr}
 &  &  &  &  & \\[0pt]
\hline
Binaire & 1 & 010 & 011 & 110 & 001\\[0pt]
Octal & 1 & 2 & 3 & 6 & 1\\[0pt]
\end{tabular}
\end{table}

On obtient le nombre octal (12361)8.

\item Représentation hexadécimale
\label{sec:org8da09cd}

La représentation hexadécimale consiste à utiliser la base 16, avec
les chiffres \(0, 1, \ldots, 9\), auxquels on ajoute les lettres A, B,
C, D, E et F pour représenter les valeurs de dix à quinze
respectivement\footnote{Pour simplifier, dans le contexte, on appellera ici ces cinq
lettres des \emph{chiffres} de la notation hexadécimale.}. On voit la correspondance entre les nombres en binaire et les chiffres de la représentation hexadécimale dans le tableau \ref{tab:org1f192c8}.

\begin{table}[htbp]
\caption{\label{tab:org1f192c8}Représentation hexadécimale}
\centering
\begin{tabular}{rr}
Binaire & Hexadécimal\\[0pt]
\hline
0000 & 0\\[0pt]
0001 & 1\\[0pt]
0010 & 2\\[0pt]
0011 & 3\\[0pt]
0100 & 4\\[0pt]
0101 & 5\\[0pt]
0110 & 6\\[0pt]
0111 & 7\\[0pt]
1000 & 8\\[0pt]
1001 & 9\\[0pt]
1010 & A\\[0pt]
1011 & B\\[0pt]
1100 & C\\[0pt]
1101 & D\\[0pt]
1110 & E\\[0pt]
1111 & F\\[0pt]
\end{tabular}
\end{table}


Pour convertir un nombre binaire en nombre hexadécimal, il suffit de
regrouper les bits par groupes de quatre bits, en partant de la droite
(bit le moins significatif), et de remplacer chaque groupe par le
chiffre en base 16 correspondant.

Par exemple, pour (1010011110001)2, on aura le découpage du tableau
\ref{tab:org3cc9b34}.

\begin{table}[htbp]
\caption{\label{tab:org3cc9b34}Regroupement pour conversion en hexadécimal}
\centering
\begin{tabular}{lrrrr}
 &  &  &  & \\[0pt]
\hline
Binaire & 1 & 0100 & 1111 & 0001\\[0pt]
Hexa & 1 & 4 & F & 1\\[0pt]
\end{tabular}
\end{table}

On obtient le nombre hexadécimal (14F1)16.

\item Conversion en sens inverse
\label{sec:orge91fb4f}

La conversion de octal (respectivement, hexadécimal) à binaire se fait
simplement en remplaçant chaque chiffre octal (resp., hexadécimal) par
le groupe de trois (resp., quatre) bits correspondant, en partant du
moins significatif.
\end{enumerate}

\section{Nombres binaires fractionnaires}
\label{sec:orgab4a9bd}

Il est aussi possible de représenter des nombres fractionnaires en
base 2. En gardant à l'esprit que la position d'un bit détermine sa
valeur, il suffit d'étendre le principe déjà établi aux bits qui
seront placés après la virgule qui sépare la partie entière de la
partie fractionnaire. Les indices des positions à droite de la virgule
seront négatifs.

Le tableau \ref{tab:org94296cd} donne en exemple le détail de l'évaluation
de la valeur du nombre fractionnaire (101,11)2. On obtient comme
valeur \(1 \times 4 + 0 \times 2 + 1 \times 1 + 1 \times 1/2 + 1
\times 1/4 = 5,75\).

\begin{table}[htbp]
\caption{\label{tab:org94296cd}Évaluation de la valeur du nombre fractionnaire (101,11)2}
\centering
\begin{tabular}{lrrrrr}
Position & 2 & 1 & 0 & -1 & -2\\[0pt]
\hline
Valeur & \(2^2\) & \(2^1\) & \(2^0\) & \(2^{-1}\) & \(2^{-2}\)\\[0pt]
Valeur déc. & 4 & 2 & 1 & 1/2 & 1/4\\[0pt]
Bit & 1 & 0 & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{table}

\section{Opérations arithmétiques binaires}
\label{sec:orge7b2963}

Il est possible de transposer les opérations arithmétiques habituelles
pour effectuer différentes opérations arithmétiques: addition,
soustraction, multiplication, division, avec des nombres
binaires. Nous verrons plus loin comment ces opérations s'exécutent
lorsque nous aurons établi les formes d'encodages binaires qui seront
utilisés pour les nombres, notamment la représentation des nombres
signés.

\begin{enumerate}
\item Multiplication et division par deux
\label{sec:orgbbd1727}

Pour multiplier un nombre binaire non signé par deux, il suffit de
décaler tous ses bits d'une position vers la gauche. Si le nombre est
entier, on devra insérer un zéro à la position zéro. Si le nombre est
fractionnaire, le bit le plus significatif de la partie fractionnaire se
retrouvera à la position zéro.

$$ (10011)2 \times 2 = (100110)2 $$

$$ (100,11)2 \times 2 = (1001,1)2 $$

Pour diviser un nombre binaire par deux, il suffit de décaler tous ses
bits d'une position vers la droite. Une division fractionnaire
produira possiblement un nombre fractionnaire, comme dans l'exemple
suivant.

\begin{enumerate}
\item Division fractionnaire
\label{sec:org8d92172}

$$ (10011)2 \div 2 = (1001,1)2 $$

\item Division entière
\label{sec:orgbb584ae}

Pour une division entière (sans fraction), on éliminera le bit qui
aurait été placé après la virgule.

$$ (10011)2 \div 2 = (1001)2 $$

Il est évident de généraliser ces opérations pour les multiplications
ou divisions par des puissances de 2: par 4, 8, 16, etc.
\end{enumerate}
\end{enumerate}

\section{Compléments de nombres}
\label{sec:org99aad12}

Les compléments de nombres jouent un rôle dans la simplification de
certaines opérations mathématiques et logiques. Dans un système de
numération de base \(b\), on considère deux types de compléments: le
complément à \(b\) et le complément à \(b-1\). Pour la base 10, nous
aurons donc le complément à dix et le complément à neuf. Pour les
nombres binaires (base 2), nous aurons le complément à deux et le
complément à un.  Pour évaluer les compléments d'un nombre, on doit
tenir compte du nombre de chiffres que comporte ce nombre.

\begin{enumerate}
\item Complément à neuf et complément à un
\label{sec:orgca0e71b}

Soit un nombre entier \(N\) en base \(b\) constitué de \(n\) chiffres. Le
complément à \(b-1\) de \(N\) est \((b^n-1)-N\).

Par exemple, en base \(b=10\), le complément à neuf pour le nombre décimal
\(N = 4576\) formé de \(n=4\) chiffres sera \((b^n-1)-N = (10^4 -1) -
4576 = 5424\).

En base \(b=2\), le complément à un pour le nombre binaire \(N =
(10011)2 = (19)10\) formé de \(n=5\) bits sera \((b^n-1)-N = (2^5
-1) - 19 = 12\) ce qui donne en binaire: \((12)10 = (1100)2\).

On peut vérifier qu'il est très facile, en binaire, de déterminer le
complément à un, sans effectuer de calculs, en inversant simplement
chacun des bits de la représentation binaire du nombre à
complémenter. Ainsi, avec notre exemple, on trouve:

$$ 10011 $$

$$ 01100 $$

Remarquons ici un zéro non significatif comme premier bit à gauche.

\item Complément à dix et complément à deux
\label{sec:orgf8a4ebf}

Le complément à \(b\) de l'entier \(N\) s'évalue comme
\((b^n)-N\). Cela correspond à ajouter 1 au complément à \(b-1\).

Ainsi, pour notre exemple précédent en base \(b=10\), le complément à
dix pour le nombre décimal \(N = 4576\) formé de \(n=4\) chiffres sera
\((b^n)-N = (10^4) - 4576 = 5425\).

Pour notre autre exemple, en base \(b=2\), le complément à deux pour
le nombre binaire \(N = (10011)2 = (19)10\) formé de \(n=5\) bits
sera \((b^n)-N = (2^5) - 19 = 13\) ce qui donne en binaire:
\((13)10 = (1101)2\).

L'évaluation directe à la main, sans calculs, du complément à deux est
également possible en suivant la démarche suivante:
\begin{enumerate}
\item On parcourt le nombre binaire initial à partir (à droite) du bit le moins
significatif, en retranscrivant les bits rencontrés jusqu'à
atteindre un premier bit 1, que l'on retranscrit également.
\item On continue la retranscription vers la gauche, en inversant cette
fois les bits subséquents.
\end{enumerate}

Par exemple, pour (10110)2, on aura la démarche détaillée dans le
tableau \ref{tab:org59296d8}. Les étapes sont numérotées selon la position
considérée, à partir de la droite.

\begin{table}[htbp]
\caption{\label{tab:org59296d8}Étapes pour complément à deux}
\centering
\begin{tabular}{lrrrrrl}
Nombre & 1 & 0 & 1 & 1 & 0 & \\[0pt]
\hline
Étape 0 &  &  &  &  & 0 & Retranscrit\\[0pt]
Étape 1 &  &  &  & 1 & 0 & Retranscrit\\[0pt]
Étape 2 &  &  & 0 & 1 & 0 & Inversé\\[0pt]
Étape 3 &  & 1 & 0 & 1 & 0 & Inversé\\[0pt]
Étape 4 & 0 & 1 & 0 & 1 & 0 & Inversé\\[0pt]
\end{tabular}
\end{table}

Pour une évaluation par un circuit, on commencera par déterminer le
complément à un par inversion et on lui additionnera 1 pour obtenir le
complément à deux.
\end{enumerate}

\section{Nombres signés et codage}
\label{sec:org919db86}

Représenter des nombres \(\geq 0\) en binaire est donc relativement
naturel. Dans l'optique où on voudra stocker ces nombres dans une
mémoire binaire numérique, il n'y a qu'à prévoir une taille suffisante
(en nombre de bits) pour pouvoir accommoder des nombres assez grands
pour l'application considérée. Avec \(n\) bits, il est possible de
représenter des entiers de \(0\) à \(2^n-1\) avec cette représentation
«naturelle».

Mais on peut se demander comment représenter des nombres négatifs,
c'est-à-dire \(< 0\). Une première observation est le fait que si on
considère des nombres positifs \textbf{et} négatifs, on double en quelque
sorte la quantité de valeurs à représenter. Par exemple, il y a 21
nombres à représenter si on veut pouvoir utiliser les valeurs
comprises entre \(-10\) et \(+10\), comme on peut le voir dans le
tableau \ref{tab:orgd823f79}.

\begin{table}[htbp]
\caption{\label{tab:orgd823f79}Nombre de valeurs à représenter entre \(-10\) et \(+10\)}
\centering
\begin{tabular}{lr}
Gamme & N. de valeurs\\[0pt]
\hline
de -10 à -1 & 10\\[0pt]
0 & 1\\[0pt]
de 1 à 10 & 10\\[0pt]
\hline
Total & 21\\[0pt]
\end{tabular}
\end{table}

Nous devons donc nous assurer d'avoir autant de combinaisons de bits
qu'il sera nécessaire. La deuxième observation est qu'il faudra un
moyen de distinguer les nombres positifs des nombres négatifs. Si on
veut que cette distinction puisse se faire non seulement sur papier,
mais surtout lorsque les nombres seront stockés et manipulés dans un
système électronique, il faut définir un format binaire «tout compris»
qui permette de le faire.

Nous devons donc établir un \textbf{code}, c'est-à-dire une \textbf{convention} qui
permettra de donner un sens à un groupe de bits. Le choix de la
convention devrait être guidé par les usages qui seront ultimement
faits des nombres qui seront représentés.

En fait, lorsque nous avons convenu (implicitement) de représenter des
nombres entiers en utilisant directement la conversion en base 2 des
nombres décimaux, nous avons établi un code de représentation qui,
bien que naturel, n'en est pas moins une convention. Ici, nous devrons
formuler plus explicitement la convention qui sera utilisée pour
représenter les entiers signés.

Une convention de représentation peut être établie totalement
arbitrairement, mais elle sera sans doute plus utile si elle peut
contribuer à faciliter des opérations courantes réalisées avec les
éléments à représenter. Puisqu'il est question ici de nombres entiers
signés, l'opération à considérer en priorité est l'addition. Nous devrions 
aussi considérer les trois points suivants dans notre choix de
convention pour attribuer des codes binaires aux valeurs. (Pour
illustrer notre réflexion, nous allons considérer des nombres pouvant
être représentés par des codes binaires de 4 bits, ce qui permet
en théorie de représenter un total de 16 valeurs.)

\begin{enumerate}
\item Puisqu'il faudra partager notre ensemble de codes binaires en deux,
il serait logique de placer la représentation pour zéro au centre
de ce découpage.

\item Les codes binaires utilisés pour un nombre et pour son inverse
additif devraient être disposés symétriquement autour du code
utilisé pour représenter le zéro. Il est naturel de représenter la
valeur zéro avec le code 0000.

\item L'ordre des codes devrait correspondre à l'ordre des nombres. On
sait bien comment ordonner les nombres entiers, en passant des
nombres négatifs aux nombres positifs.
\end{enumerate}

Quel ordre serait approprié pour les représentations (codes binaires)?
L'ordre naturel, du moins pour les nombres entiers positifs, serait de
passer de 0000 à 0001 à 0010, etc. Il faudra cependant limiter le
nombre de valeurs positives, car il faut réserver des codes pour les
valeurs négatives, et nous avons déjà utilisé un code pour le
zéro. Quel code binaire devrait-on placer juste avant le zéro, pour
représenter -1? Si on dispose l'ensemble des codes binaires entre 0000
et 1111 selon un cycle, comme illustré sur la figure
\ref{fig:org93e534f}, alors le code approprié pour -1 sera 1111. Et le
code pour -2 sera 1110. Un avantage de cette disposition est que, en
ajoutant 1 pour passer de -2 à -1, on parcourt le cycle dans le même
sens qu'en ajoutant 1 pour passer de 1 à 2.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.25]{Sources_images_logiques/images/cycle.png}
\caption{\label{fig:org93e534f}Relations entre les codes dans l'assignation en complément à deux}
\end{figure}

En suivant cette logique, on pourra, comme indiqué sur la figure,
assigner les codes dans les boîtes en ellipses, en jaune, à des
valeurs positives et les codes dans les boîtes en hexagones, en vert,
à des valeurs négatives. Si on assigne autant de valeurs positives que
de valeurs négatives, un seul code binaire ne sera pas utilisable, le
code 1000, dans la boîte en losange. Tout mouvement selon le sens des
flèches (horaire) sur l'illustration correspond à une addition;
tout mouvement en sens inverse correspond à une soustraction. Les nombres
binaires seront ainsi symétriques par rapport à notre zéro.

Nous obtenons ainsi l'assignation du tableau \ref{tab:org7482407}.

\begin{table}[htbp]
\caption{\label{tab:org7482407}Assignation de codes aux nombres de 4 bits}
\centering
\begin{tabular}{rr}
Code & Nombre\\[0pt]
\hline
1001 & -7\\[0pt]
1010 & -6\\[0pt]
1011 & -5\\[0pt]
1100 & -4\\[0pt]
1101 & -3\\[0pt]
1110 & -2\\[0pt]
1111 & -1\\[0pt]
0000 & 0\\[0pt]
0001 & 1\\[0pt]
0010 & 2\\[0pt]
0011 & 3\\[0pt]
0100 & 4\\[0pt]
0101 & 5\\[0pt]
0110 & 6\\[0pt]
0111 & 7\\[0pt]
1000 & aucun\\[0pt]
\end{tabular}
\end{table}

Voici quelques observations importantes sur cette représentation.

\begin{enumerate}
\item Tous les codes des nombres négatifs ont le premier bit à gauche
(qui serait le bit le plus significatif) à la valeur 1, alors que
les autres codes ont la valeur 0. Ce bit peut ainsi servir
d'indicateur de signe, avec la convention habituelle qu'on ne met
pas de signe au zéro. On parlera ainsi de \textbf{bit de signe} pour
dénoter ce bit, qui ne contribue pas à la grandeur (en valeur
absolue) du nombre.

\item L'inverse additif d'un nombre \(n\), c'est-à-dire \(-n\), est
représenté par le \textbf{complément à deux} du nombre. Ceci signifie que
pour trouver l'inverse additif d'un nombre, il suffit de calculer
son complément à deux. Le complément à deux du complément à deux nous
redonnera le nombre initial, conformément à la double négation
\(--n = n\).
\end{enumerate}

Il existe d'autres conventions pour la représentation de nombres
signés, comme la représentation signe+magnitude, mais la
représentation en complément à deux est de loin la plus utilisée.

\section{Opérations arithmétiques binaires}
\label{sec:org288eb3a}

\begin{enumerate}
\item Addition de nombres non signés
\label{sec:org101349c}

En transposant les opérations classiques pour effectuer à la main des
additions ou des soustractions, il est possible d'effectuer des
calculs avec des nombres binaires. Additionner des nombres entiers non
signés ne pose pas de difficultés particulières.

On suppose deux nombres entiers binaires non signés \(A\) et \(B\)
représentés en utilisant le même nombre de bits (si un nombre est plus
petit, on ajoutera des 0 non significatifs à gauche pour compléter la
représentation). Lorsqu'on effectue l'opération bit par bit, en
partant de la position la moins significative, on peut utiliser la
table d'addition suivante. À la position \(i\), on a trois entrées à
prendre en considération: \(A_{i}\) et \(B_{i}\), les bits des nombres
à additionner, et \(R_{i-1}\), la retenue provenant de la position
\(i-1\). En sortie, on a la somme \(S_{i}\) et la retenue \(R_{i}\).
On obtient le tableau de vérité suivant (\ref{tab:org4e0864f}).

\begin{table}[htbp]
\caption{\label{tab:org4e0864f}Tableau de vérité pour l'additionneur binaire}
\centering
\begin{tabular}{rrrrr}
\(A_{i}\) & \(B_{i}\) & \(R_{i-1}\) & \(R_{i}\) & \(S_{i}\)\\[0pt]
\hline
0 & 0 & 0 & 0 & 0\\[0pt]
0 & 0 & 1 & 0 & 1\\[0pt]
0 & 1 & 0 & 0 & 1\\[0pt]
0 & 1 & 1 & 1 & 0\\[0pt]
1 & 0 & 0 & 0 & 1\\[0pt]
1 & 0 & 1 & 1 & 0\\[0pt]
1 & 1 & 0 & 1 & 0\\[0pt]
1 & 1 & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{table}


Exemple:

A: 101110001
B: 001111001
S: 111101010
R: 001110001

S'il y a une retenue non nulle à la suite de l'addition à la position
la plus significative, il y a un \textbf{débordement}, car le résultat est trop
grand pour être représenté avec le nombre de bits initial.

\item Addition de nombres signés
\label{sec:orga4ca5c5}

L'addition de nombres signés codés avec la représentation en complément
à deux est nettement avantageuse. Il suffit d'additionner les deux
nombres comme s'il s'agissait de nombres non signés, en incluant les
bits de signe dans le calcul. La retenue qui émane de la position la
plus significative ne doit pas être prise en compte. 

Exemple 1:

Additionnons \(A=-2\) et \(B=4\), représentés respectivement (1110)2 et (0100)2.

A: 1110
B: 0100
S: 0010
R: 1100

qui nous donne bien le résultat escompté: S = (0010)2 = (2)10.

Exemple 2:

Additionnons \(A=3\) et \(B=-5\), représentés respectivement (0011)2 et (1011)2.

A: 0011
B: 1011
S: 1110
R: 0011

qui nous donne bien le résultat escompté: S = (1110)2 = (-2)10.

On peut vérifier facilement qu'additionner un nombre avec son
complément à deux donne toujours zéro, ce qui revient à faire \(-n + n
= 0\).

Comme avec l'addition de nombres entiers non signés, il faudra se
préoccuper des débordements qui peuvent survenir parce que la capacité
de représentation est limitée par la taille (en nombre de bits) des
codes binaires utilisés.

\item Soustraction de nombres signés
\label{sec:orgd13a3b8}

La soustraction s'effectue en faisant \(A - B = A + (-B)\), comme suit:

\begin{enumerate}
\item On détermine le complément à deux du nombre à soustraire (ici, \(B\)).
\item On additionne ce complément à deux au nombre duquel on soustrait  (ici, \(A\)). La
retenue qui émane de la position la plus significative ne doit pas
être prise en compte.
\end{enumerate}

Le résultat s'interprétera comme un nombre signé en complément à deux. 

\item Extension de signe
\label{sec:org871980f}

Dans la représentation des nombres signés en complément à deux, le bit
de signe (bit le plus à gauche) est une indication directe du signe
d'un nombre. Si on change la taille des nombres, c'est-à-dire, le nombre
de bits utilisés au total pour la représentation, il faut une
opération spécifique pour préserver l'encodage en complément à deux. 

Considérons par exemple le nombre 5, représenté d'abord sur quatre
bits et ensuite sur huit bits. On a pour 5 

$$ 0101 $$

ou encore 

$$ 00000101 $$

Quand on compare ces deux représentations, on observe: 

\begin{itemize}
\item qu'elles se terminent de la même façon, avec les trois bits 101 qui
représentent la grandeur du nombre;
\item que le bit le plus à gauche est 0 dans les deux cas (même signe);
\item que dans la représentation sur huit bits, il y a des bits 0 entre le bit
de signe et les trois derniers bits.
\end{itemize}

Considérons maintenant un nombre négatif, le nombre -5, représenté
d'abord sur quatre bits et ensuite sur huit bits. Le complément à deux
de 5 = (0101)2 est

$$ 1011 $$

alors que le complément à deux de 5 = (00000101)2 est

$$ 11111011 $$

Quand on compare ces deux représentations, on observe: 

\begin{itemize}
\item qu'elles se terminent de la même façon, avec les trois bits 011;
\item que le bit le plus à gauche est 1 dans les deux cas (même signe);
\item que dans la représentation sur huit bits, il y a des bits 1 entre le bit
de signe et les trois derniers bits.
\end{itemize}

Ces constatations nous amènent à conclure que lorsqu'on augmente la
taille de représentation d'un nombre signé, il faut faire une
\textbf{extension de signe} pour intercaler les bonnes valeurs binaires entre
le bit de signe et les bits qui représentent la grandeur du
nombre. Pour un nombre positif, on doit intercaler des bits 0, alors
que pour un nombre négatif, on intercale des bits 1. On peut donc
énoncer la règle comme \emph{on doit intercaler des bits dont la valeur est
la même que le bit de signe.}

Si, à l'inverse, on réduit la taille des nombres signés, on n'aura
qu'à supprimer des bits, tous égaux au bit de signe, entre le bit de
signe et ceux qui représentent la grandeur du nombre. Si les bits à
supprimer ne sont pas tous égaux au bit de signe, c'est une indication
que la réduction de taille n'est pas possible: la nouvelle taille est
insuffisante pour représenter les nombres correctement.
\end{enumerate}


\section{Codes binaires}
\label{sec:org9d34914}

Il n'y a pas que des nombres que l'on voudra représenter en
binaire. Il est maintenant le temps de définir ce qu'on appelle un
\textbf{code binaire}, car cette notion est au centre de tous les encodages
que nous aurons à utiliser.

Un code binaire sur \(n\) bits est typiquement une association entre,
d'une part, les éléments d'un ensemble que l'on cherche à représenter
et d'autre part, les différents groupes ou patrons possibles avec
\(n\) bits. On appelle parfois ces patrons des mots du code (ou par abus
de langage, des codes). Comme il y a \(2^n\) patrons de bits
différents, il est possible d'associer jusqu'à ce nombre
d'éléments.

Une règle, souvent implicite mais essentielle, stipule qu'\textbf{on
ne devrait associer qu'un seul élément à un patron de bits donné.}
Sinon, l'interprétation du code (le décodage) devient ambiguë. Selon
l'application, il n'est pas toujours nécessaire d'associer tous les
patrons de bits à des éléments. Par exemple, si on veut représenter
les chiffres décimaux, il est nécessaire de disposer d'au moins 10
patrons de bits, ce qui est possible avec \(n=4\). Puisque \(2^4 =
16\), il y aura \(16 - 10 = 6\) patrons de bits inutilisés.

La règle spécifique d'association peut être établie arbitrairement,
mais elle est souvent conçue en vue de respecter certaines propriétés
liées aux éléments à représenter ou à la configuration du code
lui-même. C'est ce qu'on a fait, par exemple, pour définir la
convention d'encodage des entiers par complément à deux.

\begin{enumerate}
\item Code Gray
\label{sec:org69df59f}

Lorsqu'on utilise un code binaire pour représenter des valeurs
associées à des phénomènes physiques, il peut être opportun d'utiliser
un encodage dans lequel le nombre de changements de bits est minimal
lorsqu'on passe d'un patron de bits au suivant dans la séquence des
codes. Par exemple, si on cherche à encoder des positions d'un
interrupteur rotatif (comme pour encoder des angles), il est
préférable que lorsqu'on passe d'une position à la suivante en tournant
le commutateur, un seul bit ne change dans la sortie. Ainsi, une
erreur sur un bit n'introduit pas un gros changement dans
l'interprétation de la valeur encodée. Un code Gray permet d'atteindre
cet objectif.

Avec le code Gray du tableau \ref{tab:org8c9e259}, on peut voir par exemple que la
transition entre les codes pour 7 et 8 n'entraîne qu'un changement sur
un bit, de 0110 à 1100. Avec un encodage classique basé sur les
entiers binaires, on aurait observé pour ce cas une transition entre
0111 et 1000, qui comporte quatre changements de valeurs de bits.

\begin{table}[htbp]
\caption{\label{tab:org8c9e259}Code Gray à quatre bits}
\centering
\begin{tabular}{rr}
Code Gray & Valeur\\[0pt]
\hline
0000 & 0\\[0pt]
0001 & 1\\[0pt]
0011 & 2\\[0pt]
0010 & 3\\[0pt]
0110 & 4\\[0pt]
0111 & 5\\[0pt]
0101 & 6\\[0pt]
0100 & 7\\[0pt]
1100 & 8\\[0pt]
1101 & 9\\[0pt]
1111 & 10\\[0pt]
1110 & 11\\[0pt]
1010 & 12\\[0pt]
1011 & 13\\[0pt]
1001 & 14\\[0pt]
1000 & 15\\[0pt]
\end{tabular}
\end{table}


\item Codes alphanumériques et autres
\label{sec:orgd54ce12}

Vous rencontrerez sans doute plusieurs autres encodages courants,
par exemple pour encoder des caractères (code ASCII, codes UTF)
ou pour encoder uniquement des chiffres décimaux (code BCD). Une fois
qu'on a bien compris la règle d'encodage, il n'y a généralement pas de
difficultés à les utiliser.

Certains codes sont construits de manière à permettre d'identifier et
même, dans certains cas, de corriger des erreurs dans le stockage ou
la transmission des données encodées. Ces codes sont construits en
fonction de règles d'encodage, qui, lorsqu'elles ne sont pas
respectées, permettent de constater la présence d'erreurs.
\end{enumerate}

\chapter{Logique binaire, fonctions logiques et algèbre de Boole}
\label{sec:org9785f79}


\section{Objectifs}
\label{sec:orgdc5b57f}
\begin{itemize}
\item Situer les opérations de la logique binaire dans leur contexte algébrique
\item Se familiariser avec les postulats de l'algèbre de Boole, et les
principaux théorèmes
\item Exprimer une fonction logique par un tableau de vérité
\item Formuler une expression logique à partir d'un tableau de vérité
\item Exprimer une fonction logique en \emph{somme de produits}, ou en
\emph{produit de sommes}, et convertir d'une forme à l'autre
\end{itemize}

\section{Logique binaire}
\label{sec:orgc2cb567}

La logique binaire associe une valeur de vérité à des variables, selon
une convention préétablie. Ces valeurs de vérité sont binaires, à
savoir \textbf{vrai} ou \textbf{faux}. Pour représenter ces valeurs de vérité, on
peut utiliser un encodage binaire, par exemple:

\begin{center}
\begin{tabular}{llr}
Valeur de vérité &  & Valeur binaire\\[0pt]
\hline
Vrai &  & 1\\[0pt]
Faux &  & 0\\[0pt]
\end{tabular}
\end{center}


\begin{enumerate}
\item Variable binaire
\label{sec:orge34f251}

Une variable binaire, dénotée par une lettre, permet de désigner une
valeur binaire pouvant assumer une des deux valeurs possible, 0
ou 1. La variable est typiquement associée à une proposition, à l'état
d'un élément ou à toute autre condition pouvant admettre deux états
distincts. En assignant une valeur binaire à la variable, on définit
une valeur de vérité associée à cette variable, et ainsi à la
condition qu'elle représente. Par exemple, soit \(S\) une variable
binaire qui représente la proposition «le soleil est visible». Alors,
\(S=0\) peut s'interpréter comme «le soleil est visible est faux» ou
«le soleil n'est pas visible».

\item Opérations logiques
\label{sec:orgb91c8ca}

Trois opérations logiques de base permettent d'agir sur des variables
binaires, de les combiner et de formuler des expressions logiques à
partir d'elles.

\begin{enumerate}
\item ET: cette opération est représentée (comme la multiplication) par
un point central ou par l'absence de signe d'opérateur entre les
arguments. Par exemple, \(x \cdot y\) ou \(x y\). La valeur de
l'expression est 1 si et seulement si toutes les variables ont la
valeur 1. Sinon, la valeur est 0.
\item OU: cette opération est représentée (comme l'addition) par un signe
+. Par exemple, \(x + y\). La valeur de l'expression est 1 si au
moins une des variables a la valeur 1. Si aucune des variables ne
vaut 1, la valeur de l'expression est 0.
\item NON: cette opération est représentée par un prime, par
exemple \(x^\prime\), ou par une barre au-dessus de la variable,
\(\overline{x}\).  L'opération NON renverse la valeur binaire de
son argument: si \(x =0\) alors \(x^ \prime = 1\); si \(x =1\)
alors \(x^ \prime = 0\). Cette opération de négation, est aussi
appelée complément, car complémenter une valeur binaire revient à
faire basculer sa valeur.
\end{enumerate}

\item Expression logique
\label{sec:org0b8c370}

Une expression logique combine des variables logiques et des
opérations et peut donc assumer une valeur binaire logique. Cette
valeur logique peut être assignée à une autre variable, en créant
ainsi une équation logique. Par exemple, \(z = x \cdot y\) signifie
que \(z\) assume la valeur de l'expression \(x \cdot y\). À partir des
valeurs logiques des variables (entrées) \(x\) et \(y\), on peut donc
déterminer la valeur logique de la sortie \(z\).

\item Tableaux de vérité
\label{sec:orge534fa4}

On peut décrire la valeur logique d'une variable de sortie en
fonction des valeurs possibles des variables d'entrée au moyen
d'un tableau de vérité. Dans un tel tableau, il y a une ligne pour
chaque combinaison possible des valeurs d'entrée et, sur chaque ligne,
on indique la valeur de sortie correspondante. C'est en quelque sorte
une description en extension de la valeur de l'expression de sortie.

Voici par exemple les tableaux de vérité pour les opérations de base.

Opération ET:

\begin{center}
\begin{tabular}{rrlr}
\(x\) & \(y\) &  & \(x \cdot y\)\\[0pt]
\hline
0 & 0 &  & 0\\[0pt]
0 & 1 &  & 0\\[0pt]
1 & 0 &  & 0\\[0pt]
1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{center}

Opération OU:

\begin{center}
\begin{tabular}{rrlr}
\(x\) & \(y\) &  & \(x + y\)\\[0pt]
\hline
0 & 0 &  & 0\\[0pt]
0 & 1 &  & 1\\[0pt]
1 & 0 &  & 1\\[0pt]
1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{center}

Opération complément:

\begin{center}
\begin{tabular}{rlr}
\(x\) &  & \(x^{\prime}\)\\[0pt]
\hline
0 &  & 1\\[0pt]
1 &  & 0\\[0pt]
\end{tabular}
\end{center}
\end{enumerate}

\section{Formalisme mathématique}
\label{sec:org9a15238}

Un formalisme mathématique, élaboré bien avant l'avènement des
circuits électroniques numériques, permet de formuler, analyser et
simplifier les expressions de la logique binaire. Il s'agit de
l'algèbre de Boole. 

\begin{enumerate}
\item Définitions
\label{sec:org139ccc3}

Une algèbre est un système mathématique, défini pour un ensemble
d'éléments auxquels sont associés un ensemble d'opérateurs et qui
respecte un jeu d'axiomes ou postulats. Une algèbre nécessite donc:

\begin{enumerate}
\item Un ensemble \(S\) d'éléments

\item Des opérateurs: \(\cdot\), \(\star\), \(+\)

\item L'application des opérateurs aux différents éléments doit respecter
un certain nombre de propriétés appelées postulats, comme:

\begin{itemize}
\item Fermeture

\item Associativité

\item Commutativité

\item Existence d'élément identité

\item Existence d'élément inverse

\item Distributivité
\end{itemize}
\end{enumerate}

Selon le choix des postulats, on arrive à définir différents types de
systèmes algébriques. Par exemple, les nombres réels qui nous sont
familiers constituent un système algébrique d'un type appelé \textbf{corps}.
\end{enumerate}

\section{Algèbre de Boole}
\label{sec:org0460a6e}

Une algèbre de Boole est un type de système algébrique défini sur un
ensemble \(B\), muni de deux opérateurs dénotés \(+\) et \(\cdot\), et qui
respecte les postulats suivants\footnote{Certains postulats viennent en paires; nous les distinguons ici au
moyen d'étiquettes \(\spadesuit\) ou \(\heartsuit\).} (postulats de Huntington):

\begin{enumerate}
\item Fermeture: tout résultat d'une opération sur un élément de
l'ensemble donne un élément de l'ensemble.

\begin{enumerate}
\item \(\spadesuit\) Fermeture par rapport à \(+\).

\item \(\heartsuit\) Fermeture par rapport à \(\cdot\).
\end{enumerate}

\item Éléments identité

\begin{enumerate}
\item \(\spadesuit\) Élément identité de \(+\), noté 0: on a \(x + 0 = 0 + x = x\).

\item \(\heartsuit\) Élément identité de \(\cdot\), noté 1: on a \(x \cdot 1 = 1 \cdot x = x\).
\end{enumerate}

\item Commutativité

\begin{enumerate}
\item \(\spadesuit\) Commutativité par rapport à \(+\): on a \(x + y = y + x\).

\item \(\heartsuit\) Commutativité par rapport à \(\cdot\): on a \(x \cdot y = y
        \cdot x\).
\end{enumerate}

\item Distributivité

\begin{enumerate}
\item \(\spadesuit\) \(\cdot\) est distributif sur \(+\): on a \(x \cdot (y + z)= (x \cdot y) +
        (x \cdot z)\).

\item \(\heartsuit\) \(+\) est distributif sur \(\cdot\): on a \(x + (y \cdot z)= (x + y) \cdot
        (x + z)\).
\end{enumerate}

\item Pour chaque élément \(x \in B\), il existe un élément
\(x^{\prime} \in B\) (appelé complément de \(x\)) tel que

\begin{enumerate}
\item \(\spadesuit\) \(x + x^{\prime} = 1\).

\item \(\heartsuit\) \(x \cdot x^{\prime} = 0\).
\end{enumerate}

\item Il existe au moins deux éléments \(x, y \in B\) tels que \(x \neq y\).
\end{enumerate}

Observons des différences entre une algèbre de Boole et le corps des réels:

\begin{enumerate}
\item Il n'y a pas de loi d'associativité dans les postulats. On peut en
démontrer une, cependant.

\item L'opération \(+\) est distributive sur \(\cdot\).

\item Il n'y a pas d'inverse multiplicatif ni d'inverse additif, on ne
peut donc pas faire de soustraction ou de division.

\item Il y a un concept de complément.

\item L'ensemble d'éléments est différent. Nous utiliserons pour notre
part l'ensemble \(B: \{0, 1 \}\) pour notre algèbre de Boole.
\end{enumerate}

\section{Algèbre de Boole à deux valeurs}
\label{sec:orgdb00d9f}

L'ensemble de définition: \(B : \{0, 1 \}\).

Opérateur \(\cdot\)

\begin{center}
\begin{tabular}{rrlr}
\(x\) & \(y\) &  & \(x \cdot y\)\\[0pt]
\hline
0 & 0 &  & 0\\[0pt]
0 & 1 &  & 0\\[0pt]
1 & 0 &  & 0\\[0pt]
1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{center}

Opérateur \(+\)

\begin{center}
\begin{tabular}{rrlr}
\(x\) & \(y\) &  & \(x + y\)\\[0pt]
\hline
0 & 0 &  & 0\\[0pt]
0 & 1 &  & 1\\[0pt]
1 & 0 &  & 1\\[0pt]
1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{center}

Règle de complémentation

\begin{center}
\begin{tabular}{rlr}
\(x\) &  & \(x^{\prime}\)\\[0pt]
\hline
0 &  & 1\\[0pt]
1 &  & 0\\[0pt]
\end{tabular}
\end{center}


\section{Vérification des postulats}
\label{sec:org579b16c}

\begin{enumerate}
\item La fermeture est évidente (en regardant les tableaux des opérations).

\item En observant les tableaux de vérité, on constate que

\begin{enumerate}
\item \(0 + 0 = 0\), \(0 + 1 = 1 + 0 = 1\)

\item \(1 \cdot 1 = 1\), \(0 \cdot 1 = 1 \cdot 0 = 0\)
\end{enumerate}

ce qui définit les deux éléments identité: 0 pour \(+\) et 1 pour  \(\cdot\).

\item La commutativité des lois est évidente: les tableaux sont
symétriques.

\item Les lois de distributivité se démontrent aisément en établissant des
tableaux de vérité pour les différentes valeurs de \(x, y\) et \(z\).

\item Par le tableau de complément, on vérifie que

\begin{enumerate}
\item \(x + x^{\prime} = 1\), car \(0 + 0^{\prime} = 0 + 1 = 1\) et \(1 +
        1^{\prime} = 1+ 0 = 1\)

\item \(x \cdot x^{\prime} = 0\) car \(0 \cdot 0^{\prime} = 0 \cdot 1 =
        0\) et \(1 \cdot 1^{\prime} = 1 \cdot 0 = 0\).
\end{enumerate}

\item Le postulat 6 est vérifié car il y a deux éléments distincts: 0 et 1.
\end{enumerate}

\chapter{Théorèmes et propriétés}
\label{sec:orgbb8332e}
\section{Objectifs}
\label{sec:orgea13b79}
\begin{itemize}
\item Bien saisir les relations de dualité entre les opérations
\item Connaître les principaux théorèmes de l'algèbre de Boole et
les appliquer correctement
\item Appliquer les théorèmes de DeMorgan
\item Passer d'une version d'un théorème à sa version duale
\item Connaître les autres fonctions logiques importantes
\item Construire un tableau de vérité
\end{itemize}

\section{Dualité}
\label{sec:org603ac29}

Les postulats ont été formulés en paires, identifiés par \(\spadesuit\) et
\(\heartsuit\). En interchangeant les opérateurs et les éléments identité, on
transforme un postulat de forme \(\spadesuit\) en un postulat de forme
\(\heartsuit\). C'est le principe de \textbf{dualité}. Ainsi, n'importe quelle
expression algébrique demeurera valide si les opérateurs et les
valeurs d'éléments identité sont interchangés.

Puisque notre algèbre ne comporte que deux éléments, les deux éléments
identité sont en fait les deux seuls éléments, 0 et 1. On obtient donc
le dual d'une expression en changeant les 0 pour des 1, les 1 pour des
0 et les ET pour des OU, les OU pour des ET.

\section{Théorèmes de base}
\label{sec:orgd029cbd}

Le tableau \ref{tab:orgeec51e4} résume les postulats et théorèmes de base de
notre algèbre. On présente en parallèle chaque version et sa version
duale.

\begin{table}[htbp]
\caption{\label{tab:orgeec51e4}Théorèmes de l'algèbre de Boole}
\centering
\begin{tabular}{lll}
 & Version  \(\spadesuit\) & Version  \(\heartsuit\)\\[0pt]
\hline
Postulat 2 & \(x+0=x\) & \(x \cdot 1 = x\)\\[0pt]
Postulat 5 & \(x+x^{\prime} = 1\) & \(x \cdot x^{\prime} = 0\)\\[0pt]
Théorème 1 & \(x + x = x\) & \(x \cdot x = x\)\\[0pt]
Théorème 2 & \(x + 1 = 1\) & \(x \cdot 0 = 0\)\\[0pt]
Théorème 3 & \((x^{\prime})^{\prime} = x\) & \\[0pt]
Postulat 3 & \(x + y = y + x\) & \(xy = yx\)\\[0pt]
Théorème 4 & \(x + (y + z) = (x + y ) + z\) & \(x(yz) = (xy)z\)\\[0pt]
Postulat 4 & \(x(y+z) = xy + xz\) & \(x + yz = (x+y)(x+z)\)\\[0pt]
Théorème 5 & \((x + y)^{\prime} = x^{\prime} y^{\prime}\) & \((xy)^{\prime} = x^{\prime} + y^{\prime}\)\\[0pt]
Théorème 6 & \(x + xy = x\) & \(x(x+y) = x\)\\[0pt]
\end{tabular}
\end{table}

\begin{enumerate}
\item Autres fonctions logiques
\label{sec:org94539ca}

Nous avons vu que les opérateurs logiques ET, OU et NON, qu'on peut
aussi appeler fonctions logiques, sont à la base même de la définition
de notre algèbre de Boole. Il est possible de concevoir d'autres
fonctions logiques qui vont s'avérer utiles pour la formulation, la
conception et la réalisation de systèmes logiques. Voici quelques-unes
des plus souvent utilisées.

\begin{enumerate}
\item Fonction NON-ET
\label{sec:orgc3311f9}

La fonction NON-ET, souvent désignée NAND, est obtenue en
complémentant la sortie d'une fonction ET: \((x \cdot y)^\prime\).

\begin{table}[htbp]
\caption{\label{tab:org2980461}Tableau de vérité de la fonction NON-ET}
\centering
\begin{tabular}{rrlr}
\(x\) & \(y\) &  & \((x \cdot y)^\prime\)\\[0pt]
\hline
0 & 0 &  & 1\\[0pt]
0 & 1 &  & 1\\[0pt]
1 & 0 &  & 1\\[0pt]
1 & 1 &  & 0\\[0pt]
\end{tabular}
\end{table}

\item Fonction NON-OU (NOR)
\label{sec:org459dc8b}

La fonction NON-OU, souvent désignée NOR, est obtenue en complémentant
la sortie d'une fonction OU: \((x + y)^\prime\).

\begin{table}[htbp]
\caption{\label{tab:org6c70e86}Tableau de vérité de la fonction NON-OU}
\centering
\begin{tabular}{rrlr}
\(x\) & \(y\) &  & \((x + y)^\prime\)\\[0pt]
\hline
0 & 0 &  & 1\\[0pt]
0 & 1 &  & 0\\[0pt]
1 & 0 &  & 0\\[0pt]
1 & 1 &  & 0\\[0pt]
\end{tabular}
\end{table}

\item Fonction OU-exclusif (XOR)
\label{sec:org7300df7}

La fonction OU-exclusif, souvent désignée XOR, est obtenue en évaluant
\(x \cdot y^\prime + x^\prime \cdot y\). La sortie est 1 seulement si
une seule des entrées est 1. On verra plus loin que cette fonction
joue un rôle important dans la formulation d'un additionneur.

\begin{table}[htbp]
\caption{\label{tab:org4a5588b}Tableau de vérité de la fonction OU-exclusif}
\centering
\begin{tabular}{rrlr}
\(x\) & \(y\) &  & \((x \cdot y^\prime + x^\prime \cdot y)\)\\[0pt]
\hline
0 & 0 &  & 0\\[0pt]
0 & 1 &  & 1\\[0pt]
1 & 0 &  & 1\\[0pt]
1 & 1 &  & 0\\[0pt]
\end{tabular}
\end{table}
\end{enumerate}

\item Fonctions de plusieurs entrées
\label{sec:orge1a331c}

La plupart des fonctions logiques simples peuvent naturellement se
formuler en fonction de plus de deux entrées. Par exemple, \(a \cdot b
\cdot c\) nous donne une fonction ET à trois entrées, et on peut
facilement imaginer des fonctions ET ou des fonctions OU avec encore
plus d'entrées.

\item Expressions et fonctions binaires
\label{sec:org5512ecb}

Une fonction binaire peut être décrite par une expression algébrique
booléenne. Selon les valeurs des variables, la valeur de l'expression
booléenne détermine la valeur de la fonction. Par exemple, \(F_1\) est
une fonction de trois entrées \(a\), \(b\) et \(c\) définie par
l'expression

$$ F_1 = a + b \cdot c^\prime $$

La priorité des opération dans les expressions algébriques est (1)
parenthèses, (2) NON, (3) ET, (4) OU.

Il est possible de construire le tableau de vérité pour \(F_1\) en
évaluant la fonction pour les \(2^3 = 8\) combinaisons d'entrées
possibles, comme dans le tableau \ref{tab:orgbbfc355}.

\begin{table}[htbp]
\caption{\label{tab:orgbbfc355}Fonction de trois variables}
\centering
\begin{tabular}{rrrlr}
\(a\) & \(b\) & \(c\) &  & \(F_1\)\\[0pt]
\hline
0 & 0 & 0 &  & 0\\[0pt]
0 & 0 & 1 &  & 0\\[0pt]
0 & 1 & 0 &  & 1\\[0pt]
0 & 1 & 1 &  & 0\\[0pt]
1 & 0 & 0 &  & 1\\[0pt]
1 & 0 & 1 &  & 1\\[0pt]
1 & 1 & 0 &  & 1\\[0pt]
1 & 1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{table}

En général, pour une fonction à \(n\) entrées, le tableau de vérité
comportera \(2^n\) lignes.
\end{enumerate}

\section{Théorèmes de DeMorgan}
\label{sec:org94d3bc7}

Le complément d'une fonction \(F\), \(F^\prime\), s'obtient en
remplaçant tous les 0 par des 1 et tous les 1 par des 0 dans les
valeurs de la fonction. Par exemple, en complémentant ainsi les
valeurs dans le tableau de vérité, on effectue ce changement.

On peut aussi effectuer ce changement en appliquant les théorèmes de
DeMorgan (Théorème 5 \(\spadesuit\) et \(\heartsuit\) du tableau \ref{tab:orgeec51e4}) qui
peuvent se généraliser à plus de deux variables.

\chapter{Portes logiques}
\label{sec:orgb12d442}

\section{Objectifs}
\label{sec:org80d8fab}
\begin{itemize}
\item Se familiariser avec les symboles usuels des portes logiques
\item Se familiariser avec les conventions et règles de dessin de schémas
logiques
\item Faire la différence entre niveau de signal et valeur logique
\item Expliquer les différences entre le fonctionnement idéalisé
et la réalité physique des portes logiques
\end{itemize}

\section{Niveaux logiques}
\label{sec:org63e8108}

Une porte logique est un dispositif électronique qui implémente une
fonction logique en agissant sur des signaux électriques selon une
convention préétablie. En général, on établit des valeurs binaires en
se basant sur la tension des signaux, en définissant une
correspondance entre des gammes de tensions et les valeurs logiques 0
et 1. Par exemple, pour une tension d'alimentation \(V_{DD}\), on
pourrait avoir les correspondances suivantes:

\begin{center}
\begin{tabular}{ll}
Gamme de tensions & Niveau\\[0pt]
\hline
de 0 à  \(V_{DD}/3\) & Niveau bas\\[0pt]
de \(2V_{DD}/3\) à  \(V_{DD}\) & Niveau haut\\[0pt]
\end{tabular}
\end{center}

Les portes logiques sont manufacturées selon différents standards
technologiques qu'on appelle communément des \textbf{familles logiques}. Au
sein d'une même famille, les portes respectent les mêmes références de
niveaux pour pouvoir fonctionner ensemble adéquatement. Une porte peut
comporter une ou plusieurs entrées et agit généralement sur une seule
sortie.

\section{Logique négative ou positive}
\label{sec:orgfd1ecd5}

On associe ensuite une valeur binaire à chacun des niveaux selon une
certaine convention, par exemple:
\begin{center}
\begin{tabular}{lr}
Niveau & Valeur logique\\[0pt]
\hline
Niveau bas & 0\\[0pt]
Niveau haut & 1\\[0pt]
\end{tabular}
\end{center}
qui correspond à une logique positive. La convention inverse nous
donne la logique négative.

Certains signaux seront considérés comme actifs lorsque leur niveau
logique sera 0. On parlera alors de signaux \textbf{actifs bas}. La
convention implicite est généralement que les signaux sont \textbf{actifs
haut}.

\section{Symboles}
\label{sec:org4589f59}

On a défini des symboles pour représenter graphiquement les portes
logiques courantes. Dans un schéma logique, les portes sont
interconnectées au moyen de symboles de conducteurs
(fils) qui permettent d'acheminer les valeurs logiques d'une porte à
l'autre.

\begin{enumerate}
\item Porte ET
\label{sec:orgba655c8}

À deux entrées \(S =  A \cdot B\)

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/and_logique}
\caption{\label{fig:org2aec91f}Porte ET à deux entrées}
\end{figure}

Les portes qui réalisent des fonctions qui sont associatives et
commutatives peuvent aussi se définir avec plus de deux entrées. C'est
le cas avec les fonctions ET et OU.

À trois entrées \(S =  A \cdot B \cdot C\)

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/and3_logique}
\caption{\label{fig:org1391af9}Porte ET à trois entrées}
\end{figure}

\item Porte OU
\label{sec:orgb19eed9}

À deux entrées \(S =  A + B\)

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/or_logique}
\caption{\label{fig:orgfdc1702}Porte OU à deux entrées}
\end{figure}

\item Porte inverseur
\label{sec:org7c5f02f}

L'opération NON qui consiste à complémenter une valeur binaire
s'effectue avec une porte appelée \textbf{inverseur}.  Il n'y a toujours
qu'une entrée. \(B = A^\prime\)

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/not_logique}
\caption{\label{fig:org14dd1ae}Porte inverseur}
\end{figure} 

\item Porte NON-OU (NOR)
\label{sec:org53ed393}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/nor_logique}
\caption{\label{fig:org01c0dcf}Porte NOR à deux entrées}
\end{figure}

\item Porte NON-ET (NAND) et NON-OU (NOR)
\label{sec:orga6b3d9a}

Les fonctions NAND et NOR ne sont pas associatives. Par exemple,

$$
(x \operatorname{Nor} y) \operatorname{Nor} z \neq x \operatorname{Nor} (y \operatorname{Nor} z) 
$$

On peut néanmoins définir des versions à plusieurs entrées de ces
fonctions en ajustant la priorité d'évaluation. Pour une porte NAND à
trois entrées, on fera \(S = (A \cdot B \cdot C)^\prime\).

Pour une porte NOR à trois entrées, on fera \((A + B + C)^\prime\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/nand3_logique}
\caption{\label{fig:org2150810}Porte NAND à trois entrées}
\end{figure}

\item Entrées inversées
\label{sec:orge1814e7}

On utilise souvent l'élément symbolique qui est placé à la sortie de
l'inverseur (un petit cercle) pour indiquer l'inversion d'une entrée
ou d'une sortie d'une porte. C'est le cas à la sortie des portes NAND
et NOR comme on vient de le voir. Un autre exemple est la porte NAND
de la figure \ref{fig:org226ba60}, où une des entrées est également
inversée. La porte évalue donc \(S =  (A^\prime \cdot B  \cdot C)^\prime\)

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/nand3_logique_invin1}
\caption{\label{fig:org226ba60}Porte NAND à trois entrées dont une inversée}
\end{figure} 

\item NAND et NOR, représentations équivalentes
\label{sec:org7fb0ad2}

En vertu du théorème de DeMorgan, on sait que \((x + y)^{\prime} =
x^{\prime} y^{\prime}\) et que \((xy)^{\prime} = x^{\prime} +
y^{\prime}\). On peut donc représenter les portes NAND et NOR de deux
façons équivalentes.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/NANDequiv}
\caption{\label{fig:org6699a97}Deux représentations équivalentes pour une porte NAND}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/NORequiv}
\caption{\label{fig:org9c76792}Deux représentations équivalentes pour une porte NOR}
\end{figure}

\item Porte OU-exclusif (XOR)
\label{sec:orgf30621d}

La porte XOR à deux entrées donne une sortie 1 seulement lorsque ses
deux entrées sont différentes. Il est possible de définir des portes
XOR à plus de deux entrées, mais il y a différentes interprétations de
ce qu'une telle porte devrait avoir comme comportement. De plus, comme
la réalisation pratique de cette fonction n'est pas aussi simple que
pour les autres fonctions, on se retrouve la plupart du temps à devoir
mettre des portes à deux entrées en cascade pour augmenter le nombre
d'entrées, ce qui rend moins intéressantes les portes XOR avec entrées
nombreuses.

$$ S= A \cdot B^\prime + A^\prime \cdot B $$  

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exor_logique}
\caption{\label{fig:org226d26b}Porte XOR à deux entrées}
\end{figure}

\item Porte NON-OU-exclusif ou Équivalence (XNOR)
\label{sec:orgf8511a3}

La porte \textbf{Équivalence} produit une sortie 1 lorsque ses entrées ont la
même valeur (et sont donc équivalentes). Comme pour les portes XOR,
les portes XNOR à plus de trois entrées peuvent s'interpréter de
différentes façons.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/xnor_logique}
\caption{\label{fig:orgdd5ee08}Porte XNOR}
\end{figure}
\end{enumerate}

\section{Universalité des NAND et NOR}
\label{sec:org8cf0053}

En faisant appel uniquement à des portes de type NAND ou NOR, il est
possible de réaliser n'importe quelle fonction logique, puisqu'il est
possible de réaliser les trois opérateurs de base.

\begin{enumerate}
\item Pour réaliser un inverseur, on utilise une porte NAND à une seule
entrée (ou dont toutes les entrées sont reliées ensemble).
\item Pour réaliser une porte ET, on fait suivre une porte NAND d'un
inverseur.
\item Pour réaliser une porte OU, on place un inverseur devant chaque
entrée d'une porte NAND.
\end{enumerate}

Nous verrons plus loin qu'il est aussi possible de réaliser
avantageusement des fonctions quelconques avec des portes NAND en
exploitant la forme \emph{somme de produits}.

\section{Limites physiques}
\label{sec:org983fc5a}

Les portes logiques qu'on utilisera en pratique sont des dispositifs
électroniques dont le fonctionnement correspond, dans les grandes
lignes, aux comportements idéalisés des modèles abstraits de l'algèbre
de Boole. Mais il faut toujours garder à l'esprit que la
correspondance entre modèle et réalité physique n'est jamais
parfaite. En raffinant nos modèles pour y incorporer des
caractéristiques, limites ou contraintes appropriées, il sera possible
de mieux tenir compte de la réalité physique.

\begin{enumerate}
\item Sortance (\emph{Fan-out})
\label{sec:orgc04c49d}

La sortance (\emph{fan-out}) d'une porte logique mesure sa capacité à commander
d'autres portes reliées à sa sortie. Puisque les portes sont des
dispositifs électroniques qui doivent faire circuler un certain
courant électrique pour concrétiser les niveaux de tensions qui
définissent leurs valeurs d'entrée et de sortie, il y a une limite
pratique à la capacité d'une porte de fournir le courant nécessaire
pour faire réagir la sortie des portes qu'elle devrait commander. La sortance 
mesure cette limite, en nombre de portes à commander. Si on
connecte plus d'entrées à une sortie que sa valeur de sortance, cette
sortie ne pourra pas atteindre le niveau de tension adéquat, et les
opérations logiques seront faussées.

\item Modèles de délai
\label{sec:org5f07caa}

Dans la mesure où on respecte ses contraintes d'utilisation, notamment
de sortance, une porte logique se comporte globalement de la façon
attendue, étant donné sa fonction et les conventions de niveaux de
signal établies. Par exemple, le niveau signal à la sortie d'un
inverseur correspondra au niveau de signal attendu pour le complément
de la valeur logique à son entrée. Mais il faut garder à l'esprit que
les portes sont des dispositifs électroniques, et donc physiques,
sujets à des «imperfections» qui diffèrent du comportement idéalisé.

Une de ces «imperfections» dont on doit impérativement tenir compte
est le \textbf{délai de propagation} qui se manifeste comme un retard entre
le moment où le signal à l'entrée de la porte assume (se stabilise à)
son niveau de signal et le moment où la sortie de la porte atteint
son niveau de signal attendu. C'est en quelque sorte le délai entre
une action à l'entrée et son effet sur la sortie. Ce délai limite la
vitesse à laquelle on peut utiliser notre circuit logique. Si on
essaie d'effectuer des transitions plus rapides que le délai, le
comportement ne sera plus conforme aux attentes de conception. On doit
donc respecter une vitesse de commutation maximale imposée par les
délais de propagation.

Le délai de propagation peut dépendre de plusieurs facteurs: la
famille logique, le type de porte, le sens de la transition, la
sortance effective, les caractéristiques d'interconnexions, etc. Pour
faciliter l'analyse, on fait appel à des modèles de délais plus ou
moins sophistiqués. Un modèle très simple consiste à supposer un délai
de propagation moyen, constant pour toutes les portes d'une famille
donnée. Un modèle un peu plus subtil pourrait prendre en compte des
délais de propagation moyens différents par types de portes. Le délai
de propagation moyen est une caractéristique clé qui différencie les
différentes familles logiques. Les délais sont typiquement de l'ordre
de nanosecondes, permettant des vitesses de commutation dans les
dizaines, centaines, voire des milliers de MHz.

Lorsqu'un signal doit se propager à travers plusieurs portes, les
délais de propagation s'accumulent, limitant encore davantage la
vitesse de commutation de l'ensemble du circuit. La vitesse qui pourra
être atteinte pour l'ensemble d'un circuit sera typiquement déterminée
par le plus lent chemin (c'est-à-dire celui qui cumule le plus long
temps de propagation).

\begin{enumerate}
\item Modèles simples
\label{sec:orgf906f9a}

À titre d'exemple, considérons une porte ET à deux entrées \(S = A B\). 
Le modèle le plus simple suppose une porte idéale, sans aucun délai:
le chronogramme suivant montre la sortie qui commute immédiatement
lorsque les conditions d'entrée changent.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/chronopasdelais}
\caption{\label{fig:orgd2ceb66}Porte ET sans délai}
\end{figure}

\begin{enumerate}
\item Modèle avec délai en sortie
\label{sec:org565b118}

Le modèle avec délai en sortie consiste à considérer un délai fixe,
qui affecte la sortie de la porte: la commutation prend effet en
sortie après un délai \(t_p\).


\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/chrononodelaisortie}
\caption{\label{fig:orgcfefee1}Porte ET avec délai en sortie}
\end{figure}

\item Modèle avec délai en entrée
\label{sec:orga0c36e2}

Le modèle avec délai en entrée est plus nuancé, car il permet de
spécifier un délai différent selon l'entrée qui entraîne le changement
à la sortie.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/chrononodelaientree}
\caption{\label{fig:org2cb97fb}Porte ET avec délai aux entrées}
\end{figure}

\item Modèle combiné
\label{sec:orgba58675}

Le modèle combiné consiste à considérer des délais différents par
entrée et, en plus, un délai global en sortie.
\end{enumerate}

\item Condition de course et aléas
\label{sec:org931ca52}

Un autre effet néfaste potentiel des délais à considérer est ce qu'on
appelle une \textbf{condition de course}. Considérons le circuit de la figure
\ref{fig:org49d4dac}.  La sortie de la porte est \(s = a \cdot a^\prime\) qui
devrait normalement donner systématiquement 0. Mais le chemin menant
de l'entrée \(a\) à l'entrée du haut de la porte ET est plus court (en
termes de délais) que le chemin qui mène à l'entrée du bas. En effet,
le signal \(a^\prime\) est retardé d'un délai de propagation
\(t_{p1}\) par rapport à \(a\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/course}
\caption{\label{fig:org49d4dac}Cas à risque de condition de course}
\end{figure}

En pratique, on pourrait observer un chronogramme qui s'apparente à
celui de la figure suivante (figure \ref{fig:orga8582ce}), où on voit
que les deux signaux à l'entrée de la porte ET sont simultanément
égaux à 1 pendant une courte période. Une courte impulsion 1 sera donc
générée sur le signal \(s\) en sortie de la porte ET, après le délai
de propagation \(t_{p2}\) de celle-ci. Cette impulsion, qui ne
correspond à rien selon la logique du circuit est appelée un \textbf{aléa} (ou
en anglais, \emph{glitch}).

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/chronocourse}
\caption{\label{fig:orga8582ce}Chronogramme montrant une condition de course}
\end{figure}

Ces aléas peuvent être la source de problèmes et de dysfonctionnements
qui sont parfois difficiles à diagnostiquer, et il faut vraiment s'en
méfier. Une telle impulsion, quasi imperceptible, pourrait par exemple
déclencher le basculement de la valeur d'une cellule mémoire plus loin
dans le circuit.
\end{enumerate}

\item Porte tampon
\label{sec:orgba8d4cd}

La valeur binaire à la sortie d'une porte tampon est la même qu'à
l'entrée. La porte n'agit pas sur la valeur logique mais permet de
reconditionner le signal à son entrée pour le rendre, en sortie,
davantage conforme aux niveaux électriques de référence. Une porte
tampon est essentiellement utilisée pour renforcer et stabiliser le
niveau du signal. Une façon pratique de réaliser une porte tampon est
de placer deux inverseurs l'un à la suite de l'autre. L'utilisation de
portes tampons est un des moyens de s'assurer de respecter les
conditions de sortance.
\end{enumerate}


\chapter{Simplification logique}
\label{sec:orgc185c51}


\section{Objectifs}
\label{sec:org7bd563f}
\begin{itemize}
\item Formuler une expression logique en forme canonique \emph{Produit
de sommes} ou \emph{Somme de produits}, et convertir entre les deux formes
\item Simplifier une expression au moyen d'un diagramme de
Karnaugh
\item Simplifier une expression par la méthode Quine-McCluskey
\item Se familiariser avec les approches d'implémentation des fonctions
simplifiées
\end{itemize}


\section{Expressions équivalentes}
\label{sec:org90f47b3}

Un des aspects ennuyeux des expressions logiques est que la
correspondance entre expression et fonction logique n'est pas
biunivoque: plusieurs expressions différentes peuvent correspondre à
une seule et même fonction. De plus, certaines des expressions
équivalentes peuvent être plus complexes que d'autres. Lorsque vient
le temps d'implémenter avec des portes une fonction logique, il est la
plupart du temps plus efficace d'implémenter selon une expression plus
simple, voire minimale. On doit donc considérer des approches
systématiques et efficaces pour simplifier les expressions logiques.

Quand une expression booléenne est implémentée avec des portes
logiques, chaque terme nécessite une porte et chaque variable au sein
d'un terme correspond à une entrée de la porte. On appelle \textbf{littéral}
une variable qui apparaît dans un terme, sous forme complémentée ou
non. Par exemple, l'expression \(F = x^\prime y^\prime z + xz +
xy^\prime z\) compte huit littéraux. Si on réduit le nombre de
termes, le nombre de littéraux, ou les deux, on obtiendra une
expression qui sera plus simple à implémenter avec des portes.

\section{Formes canoniques}
\label{sec:org12a858d}

\begin{enumerate}
\item Minterms et maxterms
\label{sec:org999a84c}

Dans une expression, une variable \(x\) peut apparaître telle quelle
\(x\) ou complémentée \(x^\prime\). Si on considère les combinaisons
possibles de deux variables via un opérateur ET, on a alors quatre
possibilités: \(x^\prime y^\prime, x^\prime y, x y^\prime,x
y\). Chacun de ces quatre termes s'appelle un \textbf{minterm}.

De façon équivalente (duale, en vérité), \(n\) variables reliées par
une fonction OU peuvent donner lieu à \(2^n\) termes distincts,
appelés \textbf{maxterms}. 

De façon générale, pour \(n\) variables, on aura \(2^n\) minterms ou
\(2^n\) maxterms différents possibles.

Pour étiqueter les différents minterms ou maxterms, on a établi une
convention de numérotation. Le numéro d'étiquette d'un minterm est
construit de la façon suivante. Une variable complémentée amène un bit
d'étiquette 0, une variable telle quelle amène un bit d'étiquette 1.
En ordonnant les bits selon l'ordre alphabétique des variables, on
obtient un vecteur de bits qui donnera le numéro à assigner au
minterm.  Par exemple, le minterm \(x y^\prime z\) donnera l'étiquette
101, donc le numéro de minterm (en équivalent décimal) 5.

La règle pour les maxterms est duale: une étiquette 0 pour une
variable telle quelle, et une étiquette 1 pour une variable
complémentée. Chaque maxterm est le complément du minterm
correspondant (de même numéro), et \emph{vice versa}.

Dans le tableau \ref{tab:org41997db}, on montre les symboles de la forme
\(m_j\) pour les minterms et \(M_j\) pour les maxterms, avec \(j\) qui
est l'équivalent décimal de la combinaison de bits correspondante.

\begin{table}[htbp]
\caption{\label{tab:org41997db}Minterms et maxterms pour trois variables}
\centering
\begin{tabular}{rrrllll}
\(x\) & \(y\) & \(z\) & Minterm & Symb. & Maxterm & Symb.\\[0pt]
\hline
0 & 0 & 0 & \(x^\prime y^\prime z^\prime\) & \(m_0\) & \(x+ y+ z\) & \(M_0\)\\[0pt]
0 & 0 & 1 & \(x^\prime y^\prime z\) & \(m_1\) & \(x+ y+ z^\prime\) & \(M_1\)\\[0pt]
0 & 1 & 0 & \(x^\prime y z^\prime\) & \(m_2\) & \(x+ y^\prime+ z\) & \(M_2\)\\[0pt]
0 & 1 & 1 & \(x^\prime y z\) & \(m_3\) & \(x+ y^\prime+ z^\prime\) & \(M_3\)\\[0pt]
1 & 0 & 0 & \(x y^\prime z^\prime\) & \(m_4\) & \(x^\prime+ y+ z\) & \(M_4\)\\[0pt]
1 & 0 & 1 & \(x y^\prime z\) & \(m_5\) & \(x^\prime+ y+ z^\prime\) & \(M_5\)\\[0pt]
1 & 1 & 0 & \(x y z^\prime\) & \(m_6\) & \(x^\prime+ y^\prime+ z\) & \(M_6\)\\[0pt]
1 & 1 & 1 & \(x y z\) & \(m_7\) & \(x^\prime + y^\prime+ z^\prime\) & \(M_7\)\\[0pt]
\end{tabular}
\end{table}

Pour la fonction \(F_1\) dont le tableau de vérité est le suivant: 

\begin{table}[htbp]
\caption{\label{tab:orgeb71576}Fonction de trois variables}
\centering
\begin{tabular}{rrrlr}
\(x\) & \(y\) & \(z\) &  & \(F_1\)\\[0pt]
\hline
0 & 0 & 0 &  & 0\\[0pt]
0 & 0 & 1 &  & 0\\[0pt]
0 & 1 & 0 &  & 1\\[0pt]
0 & 1 & 1 &  & 0\\[0pt]
1 & 0 & 0 &  & 1\\[0pt]
1 & 0 & 1 &  & 1\\[0pt]
1 & 1 & 0 &  & 1\\[0pt]
1 & 1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{table}

on peut donc écrire

$$ F_1 = x^\prime y
z^\prime + x y^\prime z^\prime + x y^\prime z + x y z^\prime + x y z =
m_2 + m_4 + m_5 + m_6 + m_7 $$

puisque ce sont les termes pour lesquels la fonction vaut 1. Cette
forme d'expression est une forme canonique appelée \emph{somme de
produits}.

Pour simplifier la notation, on peut écrire de façon plus compacte  

$$F_1 = \sum (2, 4, 5, 6, 7)$$

où on ne met que les numéros des minterms participant à la somme.

Si on veut exprimer le complément d'une fonction, on peut lire dans le
tableau de vérité les combinaisons pour lesquelles la fonction
vaut 0. En prenant un minterm pour chaque combinaison où la fonction
vaut 0 et en faisant un OU de ces termes, on obtient une expression en
\emph{somme de produits} pour le complément de la fonction. Ainsi, pour la
fonction \(F_1^\prime\), on a

$$ F_1^\prime = m_0 + m_1 + m_3 = x^\prime y^\prime z^\prime +
x^\prime y^\prime z + x^\prime y z $$

Si on complémente \(F_1^\prime\), on obtiendra naturellement
\(F_1\). En appliquant le théorème de DeMorgan à chaque terme, on
trouve

\(F_1 = (x+ y+ z)(x + y + z^\prime)(x + y^\prime + z^\prime) = M_0
\cdot M_1 \cdot M_3\)

Cette forme d'expression est aussi une forme canonique appelée
\emph{produit de sommes}.

Pour simplifier la notation, on peut écrire de façon plus compacte  

\(F_1 = \prod (0,1,3)\)

où on ne met cette fois que les numéros des maxterms participant au
produit.

\item Somme de produits
\label{sec:org0a785f9}

Pour \(n\) variables binaires, on a \(2^n\) minterms différents
possibles. Les minterms qui participent à la somme dans l'expression
en forme canonique \emph{somme de produits} sont ceux qui produisent un 1
dans le tableau de vérité de la fonction. Puisque la fonction peut
valoir 0 ou 1 pour chaque minterm, le nombre total de fonctions
différentes qui peuvent être définies avec \(n\) variables est de
\(2^{2^n}\).

Si on veut convertir en forme canonique \emph{somme de produits} l'expression
pour une fonction qui ne serait pas sous cette forme, on commence par
faire l'expansion de l'expression en forme \emph{somme de produits}. Ensuite,
on vérifie chaque terme pour voir si toutes les variables en font
partie. S'il manque une ou des variables, on peut faire un ET du
terme avec une expression du type \(x + x^\prime\) dans laquelle \(x\)
est une variable manquante. Ce ET ne change pas la valeur de la
fonction puisque \(x + x^\prime = 1\).

Évidemment, on peut toujours trouver la formulation en forme canonique
en se basant sur le tableau de vérité.

\item Produit de sommes
\label{sec:org104f013}

Si on veut convertir en forme canonique \emph{produit de sommes}
l'expression pour une fonction qui ne serait pas sous cette forme, on
commence par faire l'expansion de l'expression en forme \emph{produit de
sommes}. Pour ce faire, on peut avantageusement faire appel à la
distributivité de \(+\) sur \(\cdot\). Ensuite, on vérifie chaque
terme pour voir si toutes les variables en font partie. S'il manque
une ou des variables, on peut faire un OU du terme avec une expression
du type \(x \cdot x^\prime\) dans laquelle \(x\) est une variable
manquante. Ce OU ne change pas la valeur de la fonction puisque \(x
\cdot x^\prime = 0\).

\item Conversion entre formes canoniques
\label{sec:org0ebac75}

Prenons notre exemple précédent \(F_1 = \sum (2, 4, 5, 6, 7)\). On
sait que \(F_1^\prime = \sum (0,1,3)\). Si on prend le complément de
\(F_1^\prime\) par le théorème de DeMorgan, on obtient \(F_1 = (m_0 +
m_1 + m_3)^\prime = m_0^\prime \cdot m_1^\prime \cdot m_3^\prime = M_0
\cdot M_1 \cdot M_3 = \prod (0,1,3)\).

En effet, de minterm à maxterm, on a \(m_j^\prime = M_j\). Le maxterm
d'indice \(j\) est le complément du minterm de même indice \(j\), et
\emph{vice versa}.

\item Formes standard
\label{sec:org8fcfad1}

Les expressions canoniques en \emph{somme de produits} et en \emph{produit de
sommes} ne sont généralement pas simples, car toutes les variables
doivent être présentes. Pour l'implémentation, on cherchera des
expressions en formes \emph{somme de produits} ou \emph{produit de sommes} dans
lesquelles les termes pourront être simplifiés. C'est-à-dire que les
termes pourront comporter une, deux, trois, etc. variables plutôt
qu'obligatoirement \textbf{toutes} les variables. Toujours pour notre
fonction exemple, on peut écrire

\(F_1 = x + y z^\prime\)

Lorsqu'on implémente une telle fonction avec des portes logiques, il
faut une porte ET pour chaque terme produit (qui comporte plus d'une
variable) et une porte OU pour faire la somme finale. On obtient une
implémentation à deux niveaux.

De façon duale, on peut également obtenir une formulation en \emph{produit
de sommes} qui aboutira à une implémentation à deux niveaux avec une
porte OU par terme et une porte ET pour le produit final.
\end{enumerate}


\section{Objectifs de minimisation}
\label{sec:org6f48f4c}

Étant donné une fonction logique de \(n\) variables \(z(x_1, x_2, \ldots,
x_n)\), on veut déterminer une expression pour cette fonction sous la
forme \emph{somme de produits} (S de P) ou \emph{produit de sommes} (P de S) qui

\begin{enumerate}
\item comporte un nombre minimum de termes produits (pour la forme S de P)
ou de termes sommes (pour la forme P de S);

\item est telle qu'aucune expression pour \(z\) comportant le même nombre
de termes n'utilise moins de littéraux.
\end{enumerate}

\section{Diagrammes de Karnaugh}
\label{sec:orgc002cb6}

Une méthode visuelle permet de simplifier l'expression logique d'une
fonction en systématisant une procédure faisant appel à un diagramme
qui fait ressortir les simplifications possibles.

Un diagramme de Karnaugh (diag-K) est constitué d'un regroupement de
cellules carrées, chaque cellule correspondant à un minterm
possible. Les cellules sont organisées de façon à ce que lorsqu'on
passe d'une cellule à une cellule adjacente (horizontalement ou
verticalement), un seul bit du minterm change, ce qui revient à dire
qu'une seule variable passe de telle quelle à complémentée.

Cela fait en sorte que si la fonction est 1 pour deux minterms
adjacents, la somme des deux minterms pourra être simplifiée en un
seul terme dans lequel la variable correspondant au bit qui change est
absente. Par exemple, on pourrait avoir pour deux minterms adjacents
\(m_5 + m_7 = xy^\prime z + xyz = xz(y^\prime + y) = xz\). Ici, les
deux minterms adjacents diffèrent par la variable \(y\), qui sera donc
supprimée du terme produit résultant.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap2}
\caption{\label{fig:orgc915756}Diag-K à deux variables}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap3minterms}
\caption{\label{fig:org818d05b}Diag-K à trois variables, avec minterms}
\end{figure}

Sur un diag-K à trois variables, on voit que les bits \(AB\) sont
ordonnés selon un code Gray, de façon à ce qu'un seul des bits change
lorsqu'on passe d'une cellule à la suivante
horizontalement. L'adjacence se poursuit en bout de diagramme: par
exemple, la cellule 100 (\(m_4\)) est adjacente horizontalement à la
cellule 000 (\(m_0\)). On peut imaginer le diagramme comme replié sur
lui-même pour visualiser cette adjacence.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap3_repli}
\caption{\label{fig:org472a194}Diag-K avec adjacence horizontale}
\end{figure}

Sur un diag-K à quatre variables, l'adjacence repliée est aussi bien horizontale
que verticale.

Pour plus de quatre variables, il devient difficile d'utiliser cette
méthode: les diagrammes sont de grande taille et, surtout, les règles
d'adjacence ne sont plus aussi facilement observables. Les risques
d'erreurs sont plus grands.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap4}
\caption{\label{fig:org9a82d03}Diag-K à quatre variables}
\end{figure}

\begin{enumerate}
\item Procédure de simplification
\label{sec:org0fe6d66}

Pour utiliser un diag-K pour minimiser une fonction logique, 

\begin{enumerate}
\item Les minterms de la fonction à minimiser sont identifiés en insérant
un 1 dans la cellule correspondant à chaque minterm.
\item On cherche dans le diagramme pour trouver des regroupements de deux
cellules adjacentes qui sont marquées d'un 1.
\item Chaque groupe de deux cellules 1 adjacentes est marqué comme
groupe. Un même minterm peut être incorporé à plus d'un groupe.
\item Il est aussi possible de regrouper les groupes: deux groupes de 2
qui sont adjacents peuvent ainsi se regrouper en un groupe
de 4. Les tailles de groupes doivent être des puissances de 2. Il
est ainsi possible de créer des groupes de 2, 4, 8 ou 16 minterms.
\item Une fois tous les regroupements identifiés, il est possible de lire
l'expression de la fonction en \emph{somme de produits}. Chaque groupement
correspond à un terme produit, et la ou les variables dont le bit ne
change pas dans le groupe sont conservées; les autres sont
éliminées.
\end{enumerate}

Considérons par exemple la fonction \(F(A,B,C) = \sum (0, 4, 6,
7)\). Après la première étape, on obtient

\begin{center}
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap3fonct}
\label{org2cb79ec}
\end{center}

Après les regroupements, on obtient un diag-K comportant trois regroupements

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap3fonctsimp}
\caption{\label{fig:org64e1593}Diagramme après les regroupements}
\end{figure}

Le groupe en rouge correspond au produit \(B^\prime C^\prime\), celui
en bleu correspond à \(A B\) et celui en vert correspond à \(A
C^\prime\). L'expression finale en \emph{somme de produits} est donc \(F =
B^\prime C^\prime + A B + A C^\prime\).

\item Cas facultatifs
\label{sec:orgae69405}

Certaines fonctions sont incomplètement définies, dans le sens où
certaines combinaisons d'entrées ne se produiront jamais ou seront
sans conséquences si elles se produisent. On parle de \textbf{cas
indifférents} ou \textbf{facultatifs} (en anglais, \emph{don't care}). Pour la
simplification, ces cas pourront être traités tantôt comme des 0,
tantôt comme des 1, selon ce qui sera le plus avantageux.

Pour tenir compte de ces cas, les minterms seront notés avec un X dans
le diagramme de Karnaugh. Dans l'exemple à quatre variables suivant,
sur deux cas facultatifs, un seul, celui correspondant à \(m_{7}\), a
été traité comme un 1, ce qui a permis de créer le regroupement en
bleu. L'autre cas facultatif, correspondant à \(m_{2}\), n'a pas servi
dans un regroupement, ce qui signifie qu'il a été traité comme
un 0. La fonction résultante est donc \(A C^\prime D^\prime + BD + AB\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap4fonct}
\caption{\label{fig:org1aa487f}Diag-K avec cas facultatifs}
\end{figure}


\item Impliquants
\label{sec:orgb8be54c}

Le choix des regroupements à utiliser doit toujours viser à s'assurer que:
\begin{enumerate}
\item Tous les minterms de la fonction sont couverts par les regroupements choisis.
\item Le nombre de termes retenus pour l'expression est minimal.
\item Il n'y a pas de termes redondants, c'est-à-dire qui couvrent
uniquement des minterms déjà couverts.
\end{enumerate}

Il y a parfois plus d'une expression qui satisfait ces
critères. Il est possible de systématiser le choix des termes en
prenant en compte le caractère essentiel des termes.

Soit \(p(X)\) un terme produit de littéraux tirés de l'ensemble de
variables \(X\). Si, pour une fonction logique \(z(X)\) définie pour le
même ensemble de variables, la relation

\begin{quote}
pour tout \(A\) tel que \(p(A)=1\), \(z(A)=1\)
\end{quote}

tient, alors \(p\) est un \textbf{impliquant} de \(z\). Cela signifie que la
vérité du terme produit \(p\) implique celle de \(z\). \emph{Tout minterm de
\(p\) est aussi un minterm de \(z\).}

Exemple:

$$z_1 = ab + bc + a b^{\prime} c$$ 

\(a b\), \(b c\), \(a b^{\prime} c\) sont des impliquants évidents de \(z_1\).

\(a^{\prime} b c\), \(a b c^{\prime}\), \(a b c\), \(a c\) sont aussi des
impliquants de \(z_1\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap3fonctimp}
\caption{\label{fig:org47e5a71}Diag-K pour l'exemple des impliquants}
\end{figure}

\item Impliquant premier
\label{sec:org2890e80}

Un impliquant \(p\) de la fonction \(z\) est \textbf{premier} si n'importe quel
terme produit obtenu de \(p\) en supprimant un littéral n'est pas un
impliquant de \(z\).

Ici, \(a b\) est un impliquant premier de \(z_1\), car ni \(a\) ni \(b\) ne
sont des impliquants de \(z_1\). Mais \(a b^{\prime} c\) n'est pas un
impliquant premier de \(z_1\), car \(a c\) est un impliquant de \(z_1\).
Sur un diagramme de Karnaugh, un impliquant premier (i.p.) est un
groupe qui n'est contenu dans aucun autre groupe plus grand.

\item Couverture d'une fonction
\label{sec:org6cad502}

Un sous-ensemble d'i.p. qui contient tous les minterms d'une fonction
\textbf{couvre} la fonction.

Une \textbf{couverture minimale} est une couverture avec

\begin{enumerate}
\item le nombre minimal d'impliquants premiers,

\item le moins de littéraux parmi les couvertures avec nombre minimum
d'impliquants.
\end{enumerate}

\item Impliquant premier essentiel
\label{sec:orgdf6e9ef}

Un i.p. est \textbf{essentiel} si et seulement s'il couvre un minterm de la
fonction qui ne peut être couvert par un autre i.p. de la fonction.
Une couverture de la fonction \textbf{doit} contenir tous les impliquants
premiers essentiels (i.p.e.).

Un \textbf{impliquant premier absolument inessentiel} est un i.p. qui couvre
des minterms qui sont tous couverts par les i.p.e. de la fonction.

\item Sélection des impliquants
\label{sec:orga506120}

Règles de sélection des impliquants

\begin{enumerate}
\item Mettre de côté tous les i.p.e. Ils seront utilisés dans la solution
finale.

\item Éliminer tous les i.p. absolument inessentiels.

\item Il reste à choisir parmi les i.p. inessentiels pour obtenir une
couverture minimale.
\end{enumerate}

Lorsque le problème est de taille réduite, on peut faire une recherche
exhaustive de toutes les solutions possibles pour choisir la solution
minimale.

\item Minimisation avec cas facultatifs
\label{sec:org94d8276}

\begin{enumerate}
\item Lorsqu'on détermine les i.p., on doit considérer les X comme des
1, de façon à pouvoir utiliser les i.p. rendus possibles par les
cas facultatifs.

\item Lors de la sélection des i.p. pour obtenir une couverture
minimale, on ne doit pas essayer de couvrir les X.
\end{enumerate}

\item Minimisation avec plusieurs fonctions
\label{sec:org1bc1e85}

Si deux fonctions \(z_i\) et\(z_j\) ont des expressions minimales qui
comportent un terme commun, une seule porte suffira pour générer ce
terme au profit des deux fonctions.

Exemple:

$$z_1 = a c + a^{\prime} b c^{\prime} + a^{\prime} c^{\prime} d$$

$$z_2 = a c + a^{\prime}  b c^{\prime} d^{\prime} +
a^{\prime} b^{\prime} c^{\prime} d$$

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap4z1}
\caption{\label{fig:org592ae5c}Fonction \(z_1\)}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap4z2}
\caption{\label{fig:orga8ac1f3}Fonction \(z_2\)}
\end{figure}

Il est alors préférable de réutiliser les termes communs et de générer
seulement les termes manquants pour la seconde fonction. Dans cet
exemple, le terme \(a c\) sera calculé une seule fois. Les termes
\(a^{\prime} b c^{\prime} d^{\prime}\) et \(a^{\prime} b^{\prime}
c^{\prime} d\) sont nécessaires pour \(z_2\). Alors, pour \(z_1\), on
fera

$$ z_1 =  a c + a^{\prime}  b c^{\prime} d^{\prime} +
a^{\prime} b^{\prime} c^{\prime} d +
a^{\prime} b c^{\prime} d $$

qui ne nous coûtera que le dernier terme produit et une somme de
quatre termes.
\end{enumerate}


\section{Tableau de couverture Quine-McCluskey}
\label{sec:orgf82b64e}

La méthode de Quine-McCluskey systématise la sélection des impliquants
en se basant sur des relations qui s'expriment en fonction d'un
tableau de couverture.

Un \textbf{tableau de couverture} comporte une ligne pour chaque i.p. et une
colonne pour chaque minterm de la fonction à minimiser \(z\). Un \(\checkmark\) est
inscrit à l'intersection de la ligne \(i\) et de la colonne  \(j\) si
l'i.p.  \(P_i\) de la ligne  \(i\) couvre le minterm  \(m_j\) de la colonne
 \(j\).

Le problème de minimisation devient alors: trouver une couverture pour
la fonction \(z\) qui

\begin{enumerate}
\item contient le nombre minimum de lignes

\item est telle qu'aucune autre couverture à nombre de lignes minimum
comprend moins d'entrées 1 et 0 dans ses codes d'impliquants de
ligne.
\end{enumerate}

Dans le tableau de couverture, on identifie facilement les i.p.e. par
les colonnes qui ne contiennent qu'un \(\checkmark\). L'i.p. qui couvre une colonne
qui ne contient qu'un \(\checkmark\) est un i.p.e.

Puisque les i.p.e. doivent faire partie de la solution finale, toutes
les colonnes couvertes par des i.p.e. seront couvertes dans n'importe
quelle solution. On peut donc éliminer ces colonnes de la suite de la
recherche de la solution, de même que les lignes correspondant aux
i.p.e. On obtient ainsi un tableau de couverture \textbf{réduit}.

\textbf{Il ne faut cependant pas oublier de mettre les i.p.e. dans la solution
finale.}

\begin{enumerate}
\item Tableau de couverture réduit
\label{sec:org52082fb}

Le tableau de couverture réduit permet de se concentrer sur la
sélection des i.p. dont la sélection n'est pas évidente \emph{a
priori}. Pour illustrer la discussion, considérons le tableau de
couverture réduit suivant. \(m_c\) est sans doute couvert par un
i.p.e. qui n'est pas montré ici.

\begin{table}[htbp]
\caption{\label{tab:orgf4e22dd}Tableau réduit}
\centering
\begin{tabular}{lllllllll}
 & \(m_a\) & \(m_b\) & \(m_c\) & \(m_d\) & \(m_e\) & \(m_f\) & \(m_g\) & \(m_h\)\\[0pt]
\hline
\(P_A\) &  & \(\checkmark\) &  &  & \(\checkmark\) &  & \(\checkmark\) & \(\checkmark\)\\[0pt]
\(P_B\) & \(\checkmark\) & \(\checkmark\) &  &  &  & \(\checkmark\) &  & \(\checkmark\)\\[0pt]
\(P_C\) & \(\checkmark\) &  &  &  & \(\checkmark\) &  & \(\checkmark\) & \(\checkmark\)\\[0pt]
\(P_D\) &  & \(\checkmark\) &  &  &  &  &  & \(\checkmark\)\\[0pt]
\(P_E\) & \(\checkmark\) & \(\checkmark\) &  & \(\checkmark\) & \(\checkmark\) & \(\checkmark\) & \(\checkmark\) & \(\checkmark\)\\[0pt]
\end{tabular}
\end{table}


\item Dominance de lignes
\label{sec:org49448e5}

Une ligne \(P_i\) domine une ligne \(P_j\) (ce qui est noté \(P_i \supseteq
P_j\)) si la ligne \(P_i\) contient un \(\checkmark\) dans toutes les colonnes où
la ligne \(P_j\) contient un \(\checkmark\). Ici, on a \(P_B \supseteq P_D\) mais
\(P_B\) ne domine pas \(P_A\). On peut voir aussi que \(P_E\) domine
plusieurs lignes.

En général, une \(P_i\) dominante contient plus de \(\checkmark\) que \(P_j\). Si
elles ont le même nombre de \(\checkmark\) (dans les mêmes colonnes), on a \(P_i =
P_j\). Il n'y a pas de cas d'égalité ici.

Une ligne \textbf{dominée} par une autre peut être éliminée du tableau de
couverture à condition que son nombre de littéraux soit supérieur ou
égal à celui de la ligne dominante.

\item Dominance de colonnes
\label{sec:orgf27f8b9}

Une colonne \(m_i\) domine une colonne \(m_j\) (ce qui est noté \(m_i \supseteq
m_j\)) si la colonne \(m_i\) contient un \(\checkmark\) dans toutes les lignes où
la colonne \(m_j\) contient un \(\checkmark\). Ici, la colonne \(m_h \supseteq
m_g\) mais \(m_b\) ne domine pas \(m_a\). 

Une colonne \textbf{dominant} une autre colonne peut être éliminée du tableau de
couverture, car le fait que la solution finale couvre la colonne
dominée assure que la colonne dominante sera couverte aussi. Donc ici,
la colonne \(m_h\) peut être éliminée.

En cas d'égalité, comme on a ici pour \(m_e = m_g\), on peut librement
choisir quelle colonne éliminer.
\end{enumerate}

\section{Implémentation des fonctions simplifiées}
\label{sec:org9a136d7}

Les circuits logiques simplifiés en forme \emph{produit de sommes} ou
\emph{somme de produits} sont souvent mis en oeuvre au moyen de portes NAND
ou NOR plutôt qu'avec des portes ET et OU. La raison en est qu'il est
plus simple en pratique de réaliser ces portes.

\begin{enumerate}
\item Implémentation à deux niveaux
\label{sec:orge1cbe21}

Une fonction en forme \emph{somme de produits} s'implémente évidemment avec
des portes ET pour les produits et une porte OU pour la somme
finale. Considérons par exemple \(F = AB + CD\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/somme_produits}
\caption{\label{fig:org9e5e4f7}\emph{Somme de produits} pour \(F = AB + CD\)}
\end{figure} 

La fonction peut aussi s'implémenter tout naturellement en faisant
appel uniquement à des portes NAND. On peut vérifier facilement que le
circuit suivant implémente la même fonction \(F = ((AB)^\prime \cdot
(CD)^\prime)^\prime = AB + CD\)

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/somme_produitsNAND2}
\caption{\label{fig:orgddd0b3e}\emph{Somme de produits} NAND}
\end{figure} 

Cette configuration s'interprète plus facilement en représentant la
porte de sortie comme une porte NOR avec les entrées complémentées
(version équivalente de la porte NAND). En effet, la complémentation
de chaque sortie de somme est compensée par la complémentation à
l'entrée de la porte de sortie.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/somme_produitsNAND}
\caption{\label{fig:orge78dd26}\emph{Somme de produits} NAND plus évidente}
\end{figure}
\end{enumerate}

\chapter{Circuits combinatoires typiques}
\label{sec:org5f592e3}
\section{Objectifs}
\label{sec:org9c62375}
\begin{itemize}
\item Analyser un circuit combinatoire à partir de son schéma
\item Concevoir un circuit combinatoire à partir d'une spécification
\item Connaître différentes approches de réalisation
\item Se familiariser avec les principaux circuits combinatoires courants et
leurs fonctions: additionneur, décodeur, multiplexeur, encodeur,
comparateur
\item Comprendre le fonctionnement d'une chaîne d'addition binaire et les
mécanismes de propagation et d'anticipation de retenue
\end{itemize}

\section{Circuit combinatoire}
\label{sec:org73a5bfc}

Un circuit logique combinatoire est une combinaison de portes logiques
dont la sortie à un instant donné ne dépend que des valeurs des
entrées à cet instant. Un circuit combinatoire à \(n\) entrées et
\(m\) sorties peut être représenté par un schéma-bloc, dans lequel on
place généralement les entrées à gauche et les sorties à droite.

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{Sources_images_logiques/images/circuit_comb.png}
\caption{\label{fig:org107fe41}Circuit combinatoire}
\end{figure}

Avec \(n\) entrées, il est possible de créer \(2^n\) combinaisons
différentes des entrées binaires. Pour chaque combinaison, le circuit
peut donner une sortie 0 ou 1. On peut donc préciser la fonction
réalisée par le circuit au moyen d'un tableau de vérité comportant \(2^n\)
lignes. Comme nous avons \(m\) sorties différentes, il y aura \(m\)
colonnes dans le tableau de vérité pour les fonctions de
sortie. Traditionnellement, on présente les entrées en ordre croissant
de combinaisons binaires.

\section{Analyse d'un circuit logique combinatoire}
\label{sec:org81ef8eb}

Si on se trouve devant le schéma d'un circuit logique dont on ne
connaît pas la fonction, on doit en faire l'analyse. La première étape
consiste à vérifier qu'il s'agit bien d'un circuit combinatoire. Si le
schéma ne comporte pas de cellules de mémoire ou de boucles de
rétroaction, on peut conclure que le circuit est combinatoire. Une
boucle de rétroaction consiste en un chemin du circuit par
lequel une valeur d'entrée d'une porte provient, directement ou
indirectement (par l'intermédiaire d'autres portes), de la sortie de
la même porte. La présence de rétroaction est une caractéristique des
circuits logiques séquentiels, que nous étudierons plus loin.

Pour interpréter le comportement du circuit, nous devons déterminer
les expressions logiques qu'il met en oeuvre ou établir son tableau de
vérité.

Pour déterminer l'expression logique, on procède ainsi:
\begin{enumerate}
\item Étiqueter toutes les sorties des portes qui sont alimentées par les
variables d'entrée du système. Les noms de variables seront
arbitraires, mais devraient être choisis de façon à faciliter
l'interprétation par la suite. Déterminer les fonctions logiques
pour ces variables.
\item Étiqueter les sorties des portes qui sont alimentées par les
variables d'entrée et par les sorties étiquetées à l'étape
précédente. Déterminer les fonctions logiques pour ces nouvelles
variables.
\item Répéter l'étape 2 jusqu'à arriver aux variables de sortie du système.
\item En substituant les expressions logiques des fonctions identifiées,
déterminer l'expression logique pour les sorties du système en
fonction des entrées du système.
\end{enumerate}

\begin{enumerate}
\item Exemple
\label{sec:orgba0067c}

Analysons le circuit combinatoire illustré à la figure
suivante.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circuit_logique_inconnu}
\caption{\label{fig:orgd79d03f}Circuit combinatoire à analyser}
\end{figure}

\begin{enumerate}
\item Il n'est pas la peine d'étiqueter la sortie de la porte
inverseur. Comme variables intermédiaire, on considère \(I_1\) en
sortie de la porte ET à trois entrées et \(I_2\) en sortie de la
porte NOR. On trouve que \(I_1 = A^\prime \cdot B \cdot C\) et que
\(I_2 = (A + D)^\prime = A^\prime \cdot D^\prime\).

\item On aura donc \(F_1 = I_1 \cdot I_2\).

\item En substituant, \(F_1 = ( A^\prime \cdot B \cdot C ) \cdot (
   A^\prime \cdot D^\prime) = A^\prime \cdot B \cdot C \cdot
   D^\prime\).

\item En simplifiant, on obtient finalement \(F_1 = A^\prime \cdot B
   \cdot C \cdot D^\prime\).
\end{enumerate}

\begin{table}[htbp]
\caption{\label{tab:orgd033be4}Tableaux de vérité des fonctions intermédiaires et de la sortie}
\centering
\begin{tabular}{rrrrlrrr}
\(A\) & \(C\) & \(B\) & \(D\) &  & \(I_1\) & \(I_2\) & \(F_1\)\\[0pt]
\hline
0 & 0 & 0 & 0 &  & 0 & 0 & 0\\[0pt]
0 & 0 & 0 & 1 &  & 0 & 0 & 0\\[0pt]
0 & 1 & 0 & 0 &  & 0 & 1 & 0\\[0pt]
0 & 1 & 0 & 1 &  & 0 & 0 & 0\\[0pt]
0 & 0 & 1 & 0 &  & 0 & 1 & 0\\[0pt]
0 & 0 & 1 & 1 &  & 0 & 0 & 0\\[0pt]
0 & 1 & 1 & 0 &  & 1 & 1 & 1\\[0pt]
0 & 1 & 1 & 1 &  & 1 & 0 & 0\\[0pt]
1 & 0 & 0 & 0 &  & 0 & 0 & 0\\[0pt]
1 & 0 & 0 & 1 &  & 0 & 0 & 0\\[0pt]
1 & 1 & 0 & 0 &  & 0 & 0 & 0\\[0pt]
1 & 1 & 0 & 1 &  & 0 & 0 & 0\\[0pt]
1 & 0 & 1 & 0 &  & 0 & 0 & 0\\[0pt]
1 & 0 & 1 & 1 &  & 0 & 0 & 0\\[0pt]
1 & 1 & 1 & 0 &  & 0 & 0 & 0\\[0pt]
1 & 1 & 1 & 1 &  & 0 & 0 & 0\\[0pt]
\end{tabular}
\end{table}
\end{enumerate}


\section{Conception d'un circuit combinatoire}
\label{sec:org5b9ef5f}

Concevoir un circuit logique commence avec la formulation de la ou des
fonctions du système et se termine avec une implémentation en portes
logiques des fonctions logiques correspondantes. Voici les étapes à
suivre.

\begin{enumerate}
\item À partir de l'expression du besoin ou des spécifications du
système, déterminer combien d'entrées et de sorties sont
requises, puis leur assigner des noms de variables. Le choix des noms
devrait faciliter leur interprétation en lien avec leur fonction.

\item Formuler le tableau de vérité qui décrit les valeurs logiques que
doivent assumer les sorties en fonction des différentes
combinaisons d'entrées.

\item Simplifier les expressions logiques pour les différentes fonctions,
en tenant éventuellement compte des partages possibles d'éléments
intermédiaires.

\item Tracer le circuit logique résultant et le valider (à la main ou
mieux, par simulation).
\end{enumerate}

L'étape 2 est cruciale, car ce qui sera implémenté (s'il n'y a pas
d'erreurs) est exactement ce que le tableau de vérité stipule. On
doit donc s'assurer que le tableau est correctement rempli et
représente véritablement les besoins identifiés. Si des hypothèses ou
des choix doivent être faits, notamment dans le cas où l'expression
informelle des besoins est incomplète ou ambiguë, ces choix doivent
être clairement identifiés et documentés, permettant le cas échéant de
les modifier lorsque le système est mis à l'épreuve en fonctionnement.

N'importe quelle méthode de simplification peut être utilisée pour
l'étape 3, mais il faut aussi prendre en compte le type de portes
disponibles pour l'implémentation, les délais de propagation à
travers les portes, le nombre d'interconnexions entre sorties et
entrées de portes, et tout autre facteur pratique susceptible
d'orienter les décisions.

\section{Alternatives d'implémentation}
\label{sec:orgcb3e027}

Considérons la fonction logique \(Y\) correspondant au diag-K de la
figure suivante.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap3altern}
\caption{\label{fig:orgfda2575}Diag-K d'une fonction combinatoire \(Y\) à réaliser}
\end{figure} 

\begin{enumerate}
\item Implémentations via la fonction directe
\label{sec:orgdd96a99}

\begin{enumerate}
\item Implémentation en \emph{somme de produits}
\label{sec:org6b5e1f2}

En \emph{somme de produits}, on a \(Y = bc + a^\prime b + a b^\prime
c^\prime\) pour la fonction et \(Y^\prime = a^\prime b^\prime +
b^\prime c + a b c^\prime\) pour son complément. Les implémentations
possibles pour la fonction directe sont illustrées ci-dessous.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_1}
\caption{\label{fig:org682b024}Implémentation de \(Y\) en \emph{somme de produits}}
\end{figure} 


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_2}
\caption{\label{fig:orgc527dac}Implémentation (en NAND) de \(Y\) en \emph{somme de produits}}
\end{figure} 


\item Implémentation en \emph{produit de sommes}
\label{sec:org8a4321c}

En \emph{produit de sommes}, on a \(Y =(a + b ) (b + c^\prime ) (a^\prime +
ba^\prime + c)\) pour la fonction et \(Y^\prime = (b^\prime +c^\prime
)(a+b^\prime )(a^\prime +b+c)\) pour son complément.  Les implémentations
possibles pour la fonction directe sont illustrées ci-dessous.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_ps1}
\caption{\label{fig:orge4b7f55}Implémentation de \(Y\) en \emph{produit de sommes}}
\end{figure} 

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_ps2}
\caption{\label{fig:orgc179d31}Implémentation (en NOR) de \(Y\) en \emph{produit de sommes}}
\end{figure}
\end{enumerate}


\item Implémentations via la fonction complémentaire
\label{sec:orga0cc793}

On peut aussi implémenter la fonction à partir de la fonction
complémentaire \(Y^\prime\), en se basant sur le complément \(Y^\prime
= (b^\prime +c^\prime )(a+b^\prime )(a^\prime +b+c)\) et en inversant
la sortie. Voici les implémentations que l'on obtient alors.

\begin{enumerate}
\item Implémentation en \emph{somme de produits}
\label{sec:orgba075be}

En \emph{somme de produits}, on a utilisé une porte NOR en sortie pour
obtenir finalement \(Y\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_comp_sp1}
\caption{\label{fig:org8b5a39e}Implémentation via \(Y^\prime\) en \emph{somme de produits}}
\end{figure} 

Une autre forme fait appel à des portes NAND au premier niveau.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_comp_sp2}
\caption{\label{fig:org49308ba}Implémentation via \(Y^\prime\) en \emph{somme de produits}}
\end{figure} 

\item Implémentation en \emph{produit de sommes}
\label{sec:org38764e3}

En \emph{produit de sommes}, en se basant sur le complément \(Y^\prime =
(b^\prime +c^\prime )(a+b^\prime )(a^\prime +b+c)\). On a encore ici
deux variantes selon le type de portes utilisées.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_comp_ps1}
\caption{\label{fig:org9c31faa}Implémentation via \(Y^\prime\) en \emph{produit de sommes}}
\end{figure} 


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/circ_altern_comp_ps2}
\caption{\label{fig:org9818a25}Implémentation via \(Y^\prime\) en \emph{produit de sommes}}
\end{figure}
\end{enumerate}
\end{enumerate}


\section{Circuits logiques combinatoires classiques}
\label{sec:orge6e15b9}

Nous allons maintenant nous intéresser à un certain nombre de
fonctions typiques que l'on rencontre fréquemment en circuits
logiques. Ce sera aussi l'occasion de mettre en pratique les approches
de conception que nous avons vues.


\section{Additionneur binaire}
\label{sec:orgbd3fac8}

Une des opérations binaires les plus utilisées est l'addition (et la
soustraction). Nous avons présenté à la section \ref{sec:org101349c} le tableau de vérité pour un additionneur binaire dont les
entrées sont \(a_{i}\) et \(b_{i}\), les bits des nombres à
additionner, et aussi \(r_{i-1}\), la retenue provenant de la position
\(i-1\). En sortie, on aura la somme \(S_{i}\) et la retenue
\(R_{i}\). Notez que pour bien distinguer la retenue d'entrée de la
retenue de sortie, nous utilisons un symbole minuscule, \(r_{i-1}\),
pour l'entrée et un symbole majuscule, \(R_{i}\), pour la sortie. 

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{Sources_images_logiques/images/additionneur.png}
\caption{\label{fig:org7266a4c}Schéma-bloc d'un additionneur complet}
\end{figure}

\begin{table}[htbp]
\caption{\label{tab:orgccb1d56}Tableau de vérité pour l'additionneur binaire}
\centering
\begin{tabular}{rrrlrr}
\(a_{i}\) & \(b_{i}\) & \(r_{i-1}\) &  & \(R_{i}\) & \(S_{i}\)\\[0pt]
\hline
0 & 0 & 0 &  & 0 & 0\\[0pt]
0 & 0 & 1 &  & 0 & 1\\[0pt]
0 & 1 & 0 &  & 0 & 1\\[0pt]
0 & 1 & 1 &  & 1 & 0\\[0pt]
1 & 0 & 0 &  & 0 & 1\\[0pt]
1 & 0 & 1 &  & 1 & 0\\[0pt]
1 & 1 & 0 &  & 1 & 0\\[0pt]
1 & 1 & 1 &  & 1 & 1\\[0pt]
\end{tabular}
\end{table}


\begin{enumerate}
\item Demi-additionneur
\label{sec:org583a956}

Un circuit logique qui effectue l'addition de deux bits est appelé un
demi-additionneur. Mais ce qu'il nous faut vraiment, c'est un
\textbf{additionneur complet}, c'est-à-dire un circuit de trois entrées qui
fait l'addition de trois bits, puisqu'il faudra pouvoir tenir compte
de la retenue du niveau précédent pour effectuer l'addition sur un
niveau. Il est possible d'implémenter l'additionneur complet avec deux
demi-additionneurs.

\begin{table}[htbp]
\caption{\label{tab:org8b2afa0}Tableau de vérité pour un demi-additionneur}
\centering
\begin{tabular}{rrlrr}
\(a_{i}\) & \(b_{i}\) &  & \(R_{i}\) & \(S_{i}\)\\[0pt]
\hline
0 & 0 &  & 0 & 0\\[0pt]
0 & 1 &  & 0 & 1\\[0pt]
1 & 0 &  & 0 & 1\\[0pt]
1 & 1 &  & 1 & 0\\[0pt]
\end{tabular}
\end{table}


À partir du tableau de vérité, on peut trouver que pour un
demi-additionneur, \(S_{i} = a_i b_i^\prime + a_i^\prime b_i = a_i
\operatorname{Xor} b_i\) et \(R_{i} = a_i b_i\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/demi_add2}
\caption{\label{fig:orgc359188}Circuit demi-additionneur (en S de P)}
\end{figure}


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/demi_add}
\caption{\label{fig:org665957b}Circuit demi-additionneur avec porte XOR}
\end{figure}

\item Additionneur complet
\label{sec:org4f93230}

Une addition binaire complète de deux arguments constitués de \(n\)
bits procède du bit le moins significatif vers le bit le plus
significatif, en additionnant à chaque étape trois bits: \(a_{i}\),
\(b_{i}\) et \(r_{i-1}\) et en produisant une somme \(S_{i}\) et une
retenue \(R_{i}\).


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmapSi_fulladder}
\caption{\label{fig:orgee24805}Diag-K pour \(S_i\), additionneur complet}
\end{figure}


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap3fulladderR}
\caption{\label{fig:orga6d944a}Diag-K pour \(R_i\), additionneur complet}
\end{figure}


Les expressions simplifiées sont 

$$ S_{i} = a_i^\prime b_i^\prime r_{i-1} + a_i^\prime b_i
r_{i-1}^\prime + a_i b_i^\prime r_{i-1}^\prime + a_i b_i r_{i-1} $$

$$ R_{i} = a_i b_i + a_i r_{i-1} + b_i r_{i-1} $$

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/fulladderS}
\caption{\label{fig:org29de340}Circuit additionneur complet pour \(S_i\)}
\end{figure}



\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/fulladderR}
\caption{\label{fig:org465990e}Circuit additionneur complet pour \(R_i\)}
\end{figure}


Comme nous le disions précédemment, il est possible de combiner deux
demi-additionneurs pour réaliser un additionneur complet, comme on
peut le voir ici.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/fulladderxor}
\caption{\label{fig:org0282406}Circuit additionneur complet comportant deux demi-additionneurs et une porte OU}
\end{figure}

\item Additionneur binaire pour \(n\) bits
\label{sec:orgcfa0011}

Un additionneur binaire est un circuit logique qui permet d'évaluer la
somme arithmétique de deux nombres binaires de \(n\) bits. Il peut
être conçu en combinant des additionneurs complets en cascade, en
reliant la retenue de sortie provenant de la position 0 (la moins
significative) à l'entrée de retenue de la position 1, la retenue de
sortie provenant de la position 1 à l'entrée de retenue de la position
2, \ldots{}, la retenue de sortie provenant de la position \(i-1\) à l'entrée
de retenue de la position \(i\), etc. (figure \ref{fig:orgb6ebc19}).

Pour en faire un circuit général pouvant également se combiner en
chaîne, on prévoit une entrée pour une retenue au niveau 0, \(r_0\) et
une sortie pour une retenue du dernier niveau \(n-1\), \(R_{n-1}\). On
doit donc, pour le chaînage, acheminer la sortie retenue du niveau
courant à l'entrée de retenue du niveau suivant.


\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{Sources_images_logiques/images/additionneur_cascade.png}
\caption{\label{fig:orgb6ebc19}Chaîne d'addition}
\end{figure}

Cette réalisation en forme de chaîne, en réutilisant de façon
systématique un bloc élémentaire, est avantageuse du point de vue de
la complexité et de la flexibilité. Imaginons par exemple le défi de
concevoir un additionneur binaire pour des nombres de quatre bits avec
la méthode classique. Comme il faudrait considérer neuf entrées, le
tableau de vérité comporterait \(2^9= 512\) lignes!

\item Propagation de retenue
\label{sec:orgf16b48c}

L'approche en cascade ne comporte pas que des avantages. Lorsqu'on
effectue l'addition de deux nombres, les bits d'entrée des deux
arguments et la retenue d'entrée sont présentés en même temps à
l'additionneur.  Comme dans tout circuit combinatoire, il faut un
certain délai avant que les sorties n'atteignent leur niveau de sortie
final.  Ce délai de propagation dépend de la profondeur du circuit, en
nombre de portes élémentaires à franchir de l'entrée vers la
sortie.  Et c'est évidemment le chemin le plus long qui détermine le
délai de propagation global.  

Dans le cas de l'additionneur, le chemin de propagation le plus long
est celui qui mène à la dernière retenue finale \(R_{n-1}\).  En
effet, pour pouvoir calculer \(R_{n-1}\), bien que les valeurs de
\(a_{n-1}\) et \(b_{n-1}\) soient déjà disponibles, il faut attendre
que la valeur de \(r_{n-1} = R_{n-2}\) soit stabilisée avant que le
calcul puisse s'effectuer avec les bonnes valeurs. Il en est de même
avec le bloc précédent et ainsi, en remontant la chaîne vers \(r_0\),
on trouve le chemin de propagation de retenue comme chemin le plus
long.

Pour déterminer le nombre de portes à franchir pour le chemin de
propagation de retenue, nous avons ajouté deux sorties intermédiaires
à notre circuit d'additionneur complet, \(P_i\) et \(G_i\), permettant
de récrire la sortie comme \(S_i = P_i  \operatorname{Xor} r_i\) et la retenue de
sortie comme \(R_i = P_i r_i + G_i\). Les signaux \(P_i\) et \(G_i\)
ne dépendent que des entrées et sont donc disponibles après le délai
des portes ET et XOR. Le chemin de \(r_i\) à \(R_i\) passe par une
porte ET et une porte OU. Pour un additionneur de \(n\) bits
comprenant \(n\) additionneurs complets, on aura une profondeur de
retenue totale de \(2n\) portes.


\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/fulladderxorPG}
\caption{\label{fig:org10698c1}Circuit additionneur complet montrant les signaux intermédiaires \(P_i\) et \(G_i\)}
\end{figure}

\item Anticipation de retenue
\label{sec:orgdff1606}

Les valeurs calculées par le circuit complet en chaîne ne seront
valides et ne devront être prises en compte que lorsque le délai
maximal se sera écoulé. Entre-temps, les valeurs binaires présentes
aux différentes sorties assumeront typiquement des valeurs changeantes
jusqu'à la stabilisation finale. Le délai de propagation de retenue est
un facteur qui limite la vitesse à laquelle on pourra calculer la
somme de deux nombres. Et comme l'addition est une opération 
souvent utilisée, parfois à répétition, pour réaliser d'autres
opérations arithmétiques, cette limitation est problématique. 

Il serait en théorie possible de ramener à un minimum le délai de
calcul de la retenue finale en réalisant cette fonction en deux
niveaux, par exemple avec un \emph{produit de sommes}. Cette option n'est pas
réaliste, car le nombre d'entrées à considérer en parallèle est prohibitif.

Comme solutions de compromis intermédiaires, un certain nombre de
mécanismes ont été élaborés, dont l'approche par anticipation de
retenue, que nous allons explorer ici. On fait appel aux deux signaux
\(P_i = a_i \operatorname{Xor} b_i\) et \(G_i = a_i b_i\), qui donnent
respectivement pour la sortie et la retenue de sortie

$$ S_i = P_i \operatorname{Xor} r_{i-1} $$
$$ R_i = P_i r_{i-1} + G_i $$

\(G_i\) est le signal qui indique la \textbf{génération} de retenue,
produisant une retenue lorsque \(a_i\) et \(b_i\) sont tous deux à 1,
sans égard à la valeur de la retenue d'entrée \(r_{i-1}\). Le signal
\(P_i\) est l'indicateur de \textbf{propagation} de retenue, parce qu'il
détermine si la retenue du niveau précédent \(r_{i-1}\) sera propagée
à \(R_i\).

En partant du niveau 0, voici les expressions pour les différentes retenues:

$$ R_0 = r_0 = \operatorname{in}$$
$$ R_1 = G_0 + P_0 R_0 $$
$$ R_2 = G_1 + P_1 R_1 = G_1 + P_1 (G_0 + P_0 R_0) = G_1 + P_1 G_0 + P_1 P_0 R_0 $$
$$ R_3 = G_2 + P_2 R_2 = G_2 + P_2 G_1 + P_2 P_1 G_0 + P_2 P_1 P_0 R_0 $$
etc.

Les expressions pour les retenues successives sont en forme \emph{somme de
produits}, ce qui mène à une implémentation à deux niveaux pour
calculer les retenues rapidement. Contrairement à l'approche de
propagation de retenue, toutes les retenues sont obtenues après un
même délai équivalent à une profondeur de deux portes.  En calculant
d'abord les différentes valeurs de \(P_i\) et \(G_i\) pour chaque
niveau et en utilisant ces résultats intermédiaires pour, d'une part,
alimenter le circuit d'anticipateur de retenue et, d'autre part,
effectuer \(S_i = P_i  \operatorname{Xor} r_i\), on obtient un additionneur parallèle
plus rapide que la configuration en cascade.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/lookahead1}
\caption{\label{fig:org5685442}Circuit d'anticipateur de retenue pour \(n= 4\)}
\end{figure}


\item Soustraction
\label{sec:org2af545e}

Pour effectuer une soustraction \(A - B\), il faut effectuer \(A +
(-B)\), c'est-à-dire additionner le complément à deux de \(B\) à
\(A\). On détermine le complément à deux en obtenant d'abord le
complément à un en complémentant chaque bit et en additionnant ensuite
1 à cette valeur par le biais de l'entrée de retenue de l'additionneur. Il
est ainsi possible de concevoir un additionneur/soustracteur commandé
par un signal de contrôle \(O\). Si \(O=0\), le circuit calcule \(A +
(B)\) et si \(O=1\), le circuit calcule \(A + (-B)\).

La complémentation de \(B\) se fait au moyen de portes XOR qui
calculent \(O \operatorname{Xor} b_i\) et dont la sortie est acheminée
à l'entrée \(B\) de l'additionneur. Lorsque \(O=1\), leur sortie vaut
\(b_i^\prime\).

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/add_sous}
\caption{\label{fig:org7cb03ed}Circuit additionneur/ soustracteur 4 bits}
\end{figure}

\item Débordements
\label{sec:orgba948d3}

Un additionneur ou un soustracteur est conçu en fonction d'une
taille de nombres \(n\). Lorsque le résultat de l'opération dépasse la
limite pouvant être représentée, on doit détecter cette condition et
la signaler par un signal binaire.

Le cas de l'addition de nombres non signés est le plus simple. Il
suffit de surveiller la retenue du niveau le plus significatif. Une
retenue de 1 signifie un débordement de l'addition.

Les calculs avec des nombres signés en complément à deux peuvent aussi
occasionner des débordements, mais la détection doit tenir compte des
bits qui indiquent le signe des nombres.

L'addition de deux nombres de signes différents ne peut pas
occasionner de débordement, puisque la valeur absolue du résultat sera
nécessairement moindre que celle du plus grand des nombres
initiaux. Un débordement ne peut donc se produire que si les deux
nombres additionnés sont de même signe, deux positifs ou deux
négatifs.

Prenons le cas de nombres représentés sur huit bits en complément à
deux. La gamme représentable va de -128 à +127 avec un bit qui
représente le signe. Si on additionne (+50)10 = (00110010)2 avec
(+100)10 = (01100100)2, on aura un débordement, car \(150 > 127\). On
voit dans le tableau suivant les bits qui seront produits par
l'addition, avec en évidence les retenues des deux derniers
niveaux. Le bit de signe a été séparé des autres.

\begin{table}[htbp]
\caption{\label{tab:orgdc22722}Addition de (+50)10 + (+100)10 = (00110010)2 + (01100100)2}
\centering
\begin{tabular}{lrrl}
Retenues & 0 & 1 & \\[0pt]
\hline
 &  & 0 & 011 0010\\[0pt]
 &  & 0 & 110 0100\\[0pt]
\hline
 &  & 1 & 001 0110\\[0pt]
\end{tabular}
\end{table}

Refaisons le même exercice avec deux nombres négatifs: on additionne
(-50)10 = (1100 1110)2 avec (-100)10 = (1001 1100)2, qui créera aussi un
débordement.

\begin{table}[htbp]
\caption{\label{tab:org4c345d6}Addition de (-50)10 + (-100)10 = (1100 1110)2 + (1001 1100)2}
\centering
\begin{tabular}{lrrl}
Retenues & 1 & 0 & \\[0pt]
\hline
 &  & 1 & 100 1110\\[0pt]
 &  & 1 & 001 1100\\[0pt]
\hline
 &  & 0 & 110 1010\\[0pt]
\end{tabular}
\end{table}

On peut dans les deux cas détecter le débordement en observant que la
retenue du dernier niveau et la retenue de l'avant-dernier niveau sont
différentes. On peut vérifier facilement que les autres cas sans
débordement donnent des retenues égales. Donc, si on fait un
OU-exclusif entre ces deux retenues, un résultat 1 indiquera un
débordement. Ce mécanisme de détection de débordement a été ajouté au
circuit additionneur/soustracteur 4 bits dans la figure suivante pour
générer le signal \(D\) qui indique un débordement.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/add_sous_deb}
\caption{\label{fig:org51da7ec}Circuit additionneur/soustracteur 4 bits avec débordement}
\end{figure}
\end{enumerate}


\section{Multiplexeur}
\label{sec:orgd4ec199}

Un multiplexeur est un circuit combinatoire qui sélectionne le signal
qui provient d'une de ses entrées, et fait que sa sortie est égale à
l'entrée sélectionnée. Les signaux de sélection fonctionnent
typiquement selon un encodage binaire, ce qui suppose un nombre
d'entrées de la forme \(2^n\). On désigne le multiplexeur par le
nombre de signaux d'entrées à sélectionner.

\begin{enumerate}
\item Multiplexeur deux-vers-un
\label{sec:org80307d3}

Le multiplexeur le plus simple utilise un seul signal de sélection
\(S\) qui permet de choisir une de deux entrées \(I_0\) ou \(I_1\)
pour agir sur la sortie \(Y\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/mux2b}
\caption{\label{fig:org9f16e8e}Circuit du multiplexeur deux-vers-un}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/mux2symb}
\caption{\label{fig:orgc507f20}Symbole du multiplexeur deux-vers-un}
\end{figure}

\item Multiplexeur quatre-vers-un
\label{sec:org7f28bfb}

Un multiplexeur quatre-vers-un permet de choisir une de quatre entrées
en utilisant deux signaux de sélection. Pour simplifier la
représentation symbolique, les deux signaux de sélection sont
représentés comme un seul fil, qui correspond en fait à une paire de
signaux \(S_0\) et \(S_1\). Pour un multiplexeur à \(2^n\) entrées, on
aurait un vecteur de \(n\) signaux de sélection.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/mux4}
\caption{\label{fig:org9f4421c}Circuit du multiplexeur quatre-vers-un}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/mux4symb}
\caption{\label{fig:orge0e279e}Symbole du multiplexeur quatre-vers-un}
\end{figure}

\begin{table}[htbp]
\caption{\label{tab:org673083b}Tableau de vérité du multiplexeur quatre-vers-un}
\centering
\begin{tabular}{rrll}
\(S_1\) & \(S_0\) &  & \(Y\)\\[0pt]
\hline
0 & 0 &  & \(I_0\)\\[0pt]
0 & 1 &  & \(I_1\)\\[0pt]
1 & 0 &  & \(I_2\)\\[0pt]
1 & 1 &  & \(I_3\)\\[0pt]
\end{tabular}
\end{table}
\end{enumerate}



\section{Décodeur}
\label{sec:orgc4764d9}

Un décodeur est un circuit combinatoire qui sert à interpréter des
données encodées, le plus souvent en binaire. Il prend un groupe
(vecteur) de \(n\) bits en entrée, et active une sortie parmi jusqu'à
\(2^n\) sorties différentes. Dans le cas où certaines combinaisons
d'entrées ne sont pas utilisées, moins de \(2^n\) sorties peuvent être
produites.

Dans un décodeur générique, chaque combinaison binaire distincte
activera une seule sortie. Il y a une correspondance directe entre
chaque sortie possible et un minterm d'entrée.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/decod3_8}
\caption{\label{fig:org5d30a36}Circuit du décodeur trois-vers-huit}
\end{figure}


\begin{table}[htbp]
\caption{\label{tab:org7b81548}Tableau de vérité du décodeur trois-vers-huit}
\centering
\begin{tabular}{rrrlrrrrrrrr}
\(x\) & \(y\) & \(z\) &  & \(D_0\) & \(D_1\) & \(D_2\) & \(D_3\) & \(D_4\) & \(D_5\) & \(D_6\) & \(D_7\)\\[0pt]
\hline
0 & 0 & 0 &  & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\[0pt]
0 & 0 & 1 &  & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0\\[0pt]
0 & 1 & 0 &  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\[0pt]
0 & 1 & 1 &  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0\\[0pt]
1 & 0 & 0 &  & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\[0pt]
1 & 0 & 1 &  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0\\[0pt]
1 & 1 & 0 &  & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0\\[0pt]
1 & 1 & 1 &  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\[0pt]
\end{tabular}
\end{table}

\begin{enumerate}
\item Décodeur avec sortie active basse et signal de contrôle
\label{sec:orgb020eb8}

On peut aussi concevoir des décodeurs basés sur des portes NAND et
dont la sortie sélectionnée est active au niveau bas. Une autre
fonction utile est un signal de contrôle \(E\) qui n'active une sortie
que lorsqu'il est activé.

Le décodeur deux-vers-quatre, dont le circuit est présenté ci-dessous,
comporte ces deux caractéristiques. Comme on peut voir dans le tableau
de vérité, tant que le signal de contrôle est inactif ( \(E = 1\)
puisque ce signal est également actif bas), les sorties sont inactives
(au niveau 1) quelles que soient les entrées \(x\) et \(y\). Lorsque
\(E = 0\), une seule sortie passe à 0, selon le code binaire présent
aux entrées \(x\) et \(y\). Notez que ce décodeur a été conçu et
étiqueté en fonction d'entrées \(x\) et \(y\) qui sont actives haut.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/decode2_4_enable}
\caption{\label{fig:org04f3279}Décodeur à sortie active basse}
\end{figure}


\begin{table}[htbp]
\caption{\label{tab:org4ef495c}Tableau de vérité, décodeur 2 vers 4 avec sortie active basse}
\centering
\begin{tabular}{rrrlrrrr}
\(E\) & \(x\) & \(y\) &  & \(D_0\) & \(D_1\) & \(D_2\) & \(D_3\)\\[0pt]
\hline
0 & 0 & 0 &  & 0 & 1 & 1 & 1\\[0pt]
0 & 0 & 1 &  & 1 & 0 & 1 & 1\\[0pt]
0 & 1 & 0 &  & 1 & 1 & 0 & 1\\[0pt]
0 & 1 & 1 &  & 1 & 1 & 1 & 0\\[0pt]
1 & 0 & 0 &  & 1 & 1 & 1 & 1\\[0pt]
1 & 0 & 1 &  & 1 & 1 & 1 & 1\\[0pt]
1 & 1 & 0 &  & 1 & 1 & 1 & 1\\[0pt]
1 & 1 & 1 &  & 1 & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{table}


\item Implémentation de fonctions arbitraires au moyen d'un décodeur
\label{sec:org5b93a11}

Puisqu'un décodeur active sélectivement les \(2^n\) minterms possibles
à partir de ses \(n\) entrées, il est possible d'implémenter, en \emph{somme
de produits}, une fonction quelconque en acheminant les minterms de la
fonction à une porte OU. Il est même possible d'implémenter plusieurs
fonctions différentes, en leur consacrant chacune une porte OU de
sortie.

Voici par exemple une fonction réalisée à partir d'un décodeur
trois-vers-huit. L'entrée \(I\) correspond à un vecteur de trois bits. Le
tableau de vérité correspondant est donné. On peut voir que les
minterms choisis permettent d'implémenter

$$ Y = \sum(0,2,5,6)$$

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/fonct_arbit_decod}
\caption{\label{fig:org5364d42}Fonction arbitraire réalisée au moyen d'un décodeur}
\end{figure}


\begin{table}[htbp]
\caption{\label{tab:org87319d5}Tableau de vérité pour la fonction arbitraire}
\centering
\begin{tabular}{rrrlr}
\(I_2\) & \(I_1\) & \(I_0\) &  & \(Y\)\\[0pt]
\hline
0 & 0 & 0 &  & 1\\[0pt]
0 & 0 & 1 &  & 0\\[0pt]
0 & 1 & 0 &  & 1\\[0pt]
0 & 1 & 1 &  & 0\\[0pt]
1 & 0 & 0 &  & 0\\[0pt]
1 & 0 & 1 &  & 1\\[0pt]
1 & 1 & 0 &  & 1\\[0pt]
1 & 1 & 1 &  & 0\\[0pt]
\end{tabular}
\end{table}

Une fonction qui comporte de nombreux minterms exige l'utilisation
d'une porte OU avec un grand nombre d'entrées. Si la fonction à
réaliser exige plus de \(2^n/2\) minterms, il est alors plus
avantageux d'implémenter le complément de la fonction, qui nécessitera
moins de \(2^n/2\) minterms, et d'inverser ensuite la sortie pour
obtenir la fonction.
\end{enumerate}

\section{Encodeur}
\label{sec:orgb1453b0}

Un encodeur effectue le travail inverse du décodeur: lorsqu'une de ses
\(2^n\) (ou moins) entrées est activée, il donne le code binaire
correspondant sur ses \(n\) sorties vues comme un vecteur binaire. Le
circuit ne nécessite pas vraiment d'entrée pour \(D_0\).


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/encode1}
\caption{\label{fig:org916aa71}Encodeur 3 bits}
\end{figure}


\begin{table}[htbp]
\caption{\label{tab:orga8674ac}Tableau de vérité pour l'encodeur 3 bits}
\centering
\begin{tabular}{rrrrrrrrlrrr}
\(D_0\) & \(D_1\) & \(D_2\) & \(D_3\) & \(D_4\) & \(D_5\) & \(D_6\) & \(D_7\) &  & \(x\) & \(y\) & \(z\)\\[0pt]
\hline
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 &  & 0 & 0 & 0\\[0pt]
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 &  & 0 & 0 & 1\\[0pt]
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 &  & 0 & 1 & 0\\[0pt]
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 &  & 0 & 1 & 1\\[0pt]
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 &  & 1 & 0 & 0\\[0pt]
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 &  & 1 & 0 & 1\\[0pt]
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 &  & 1 & 1 & 0\\[0pt]
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 &  & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{table}

Cette configuration d'encodeur exige qu'une seule entrée soit
activée à la fois. Activer plus d'une entrée ne correspond en effet à
rien de valide: comment donner un sens à une telle combinaison au
moyen d'un vecteur de \(n\) bits? Les sorties produites alors seront
des vecteurs binaires sans signification.

\begin{enumerate}
\item Encodeur à priorité
\label{sec:orge5d2cab}

Un encodeur à priorité met en oeuvre une priorité entre les
entrées. S'il y a plus d'une entrée 1 en même temps, la sortie sera
celle qui correspond à l'entrée active qui a la plus grande
priorité. Voici le tableau de vérité pour un encodeur 2 bits à priorité,
dans lequel on a ajouté une sortie \(V\) qui indique la validité des
sorties. Si aucune entrée n'est active, \(V=0\) et les sorties \(x\)
et \(y\) ne doivent pas être prises en compte.

Lorsque des entrées sont activées, c'est celle qui a le plus grand
indice qui est prioritaire.

\begin{table}[htbp]
\caption{\label{tab:org0ad34dc}Tableau de vérité pour encodeur 2 bits à priorité}
\centering
\begin{tabular}{lrrrlrrr}
\(D_0\) & \(D_1\) & \(D_2\) & \(D_3\) &  & \(x\) & \(y\) & \(V\)\\[0pt]
\hline
0 & 0 & 0 & 0 &  & X & X & 0\\[0pt]
1 & 0 & 0 & 0 &  & 0 & 0 & 1\\[0pt]
X & 1 & 0 & 0 &  & 0 & 1 & 1\\[0pt]
X & X & 1 & 0 &  & 1 & 0 & 1\\[0pt]
X & X & X & 1 &  & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{table}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap4foncencode_pri_x}
\caption{\label{fig:orgb78be0a}Diag-K pour \(x\) de l'encodeur à priorité}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/kmap4foncencode_pri_y}
\caption{\label{fig:orgd8da07e}Diag-K pour \(y\) de l'encodeur à priorité}
\end{figure}

En simplifiant, on trouve les expressions suivantes:

$$ x = D_2 + D_3 $$

$$ y = (D_1 D_2^\prime) + D_3 $$

$$ V = D_0 + D_1 + D_2 + D_3 $$

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/encode_pri}
\caption{\label{fig:org0296f03}Encodeur 2 bits à priorité, en P de S}
\end{figure}

Puisque le terme \(x = D_2 + D_3\) est déjà calculé pour \(x\), on
peut le réutiliser pour construire le terme pour \(V\), tel
qu'illustré ci-dessous, ce qui évite d'utiliser une porte OU à quatre
entrées.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/encode_pri2}
\caption{\label{fig:orgd68beb9}Encodeur 2 bits à priorité avec ré-utilisation d'un des termes}
\end{figure}
\end{enumerate}


\section{Comparateur de magnitude}
\label{sec:org3540ce5}

Comparer la magnitude de deux nombres binaires est une opération qui
peut se systématiser, comme on l'a fait pour l'addition. Considérons
deux nombres binaires non signés, \(A\) et \(B\) de même taille \(n\),
avec leurs bits respectifs \(a_i\) et \(b_i\). Nous voulons que notre
comparateur active une des trois sorties, selon le cas: \(A < B\), \(A
= B\) ou \(A > B\). Pour illustrer, nous considérerons \(n = 4\).

$$ a_3 a_2 a_1 a_0 $$

$$ b_3 b_2 b_1 b_0 $$

Nous aurons besoin d'une fonction qui permet de déterminer si deux
bits sont égaux. Cette fonction correspond à la fonction \textbf{Équivalence}
ou NOR-exclusif \(a_i b_i + a_i^\prime b_i^\prime\).  Si les bits
diffèrent en position \(i\), \(a_i = 1\) nous permet de conclure que
\(A > B\) et, à l'inverse, \(a_i = 0\) nous indique que \(A < B\). Nous avons ainsi
les éléments qui permettent d'effectuer une comparaison pour un bit,
comme on peut en voir l'implémentation sur la figure suivante.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/comparateur}
\caption{\label{fig:orgfce9b5b}Comparateur de magnitude}
\end{figure}

Notre démarche de conception pour \(n\) bits sera calquée sur la
procédure que nous utilisons intuitivement pour faire une telle
comparaison. La comparaison commence au niveau du bit le plus
significatif. Si ces bits sont égaux, on considère la position
suivante, jusqu'à atteindre une position \(i\) où les bits diffèrent
ou jusqu'à atteindre la fin des nombres (c'est-à-dire \(i=0\)). Si les
bits diffèrent en position \(i\), \(a_i = 1\) nous permet de conclure
que \(A > B\), alors que \(a_i = 0\) nous indique que \(A < B\).

Les signaux intermédiaires \(x_i = a_i b_i + a_i^\prime b_i^\prime\)
qui indiquent si deux bits d'une position sont égaux seront mis à
profit pour alimenter un réseau de conditions en forme \emph{somme de
produits} qui mettront en application les règles énoncées. Les signaux
de sortie binaires sont \((A = B), (A < B), (A > B)\).  D'une part,
la régularité des opérations simplifie la conception et, d'autre part,
l'implémentation sera simplifiée du fait que certains des termes
nécessaires peuvent être réutilisés.

$$ (A = B) = x_3 x_2 x_1 x_0 $$ 

$$ (A < B) = a_3^\prime b_3 + x_3  a_2^\prime b_2  +  x_3 x_2  a_1^\prime b_1 +  x_3 x_2 x_1  a_0^\prime b_0 $$

$$ (A > B) = a_3 b_3^\prime + x_3  a_2 b_2^\prime  +  x_3 x_2  a_1 b_1^\prime +  x_3 x_2 x_1  a_0 b_0^\prime $$

On obtient ainsi un comparateur pour des nombres de quatre bits, tel qu'illustré.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/comparateur_4b}
\caption{\label{fig:org686cd83}Comparateur de magnitude 4 bits}
\end{figure}

\section{Démultiplexeur}
\label{sec:org13a89c9}

Un démultiplexeur achemine la valeur logique de son entrée à une
sortie (parmi \(2^n\) sorties) sélectionnée par un code binaire de
sélection. Le démultiplexeur de la figure suivante comporte trois bits
de sélection et permet donc d'acheminer la valeur de l'entrée \(I\)
vers une des huit sorties \(O_i, i = 0, \ldots, 7\). On peut aussi
interpréter ce circuit comme un décodeur trois-vers-huit avec une
entrée signal de contrôle (\emph{enable}) \(I\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/demux8}
\caption{\label{fig:org9e3c909}Démultiplexeur un-vers-huit}
\end{figure}

\section{Encodeurs divers}
\label{sec:orgfb9ec01}

Il est possible de concevoir des encodeurs pour des fonctions
spécialisées, comme des encodeurs pour commander des affichages. La
démarche de conception s'apparente largement à celles que nous avons
vues dans les exemples précédents.


\section{Portes à trois états et tampon de bus}
\label{sec:org1fde717}

Les portes à trois états ajoutent un troisième état de fonctionnement
aux sorties: en plus des niveaux logiques bas et haut conventionnels,
un troisième état appelé \textbf{haute impédance} fait en sorte que la sortie
se comporte comme si elle n'était plus connectée au circuit. La sortie
n'agit pas sur le reste du circuit, les autres portes dont les entrées
sont alimentées par la porte en haute impédance ne sont aucunement
affectées par celle-ci. Pour activer cet état de sortie
haute impédance, une entrée de contrôle est ajoutée.


Le figure ci-dessous montre une porte tampon à trois états. Avec
\texttt{Contrôle} = 0, la sortie est en haute impédance; avec  \texttt{Contrôle} = 1,
la sortie est égale à l'entrée.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/buf_3s}
\caption{\label{fig:orgdc087c6}Porte tampon à trois états}
\end{figure}

En plaçant des tampons à trois états à chaque sortie d'un décodeur, on
peut réaliser un multiplexeur \(n\)-vers-un en reliant les sorties des
tampons à une sortie unique. Ainsi, lorsqu'une entrée est
sélectionnée au moyen des entrées de sélection, c'est sa valeur qui se
retrouve à la sortie du dispositif. La valeur Z représente l'état
haute impédance.  Lorsque l'entrée de contrôle \(E = 0\), la sortie est
en haute impédance.

\begin{table}[htbp]
\caption{\label{tab:org2847469}Tableau de vérité pour un  multiplexeur quatre-vers-un trois états}
\centering
\begin{tabular}{rrrlllllll}
\(s_1\) & \(S_0\) & \(E\) &  & \(I_0\) & \(I_1\) & \(I_2\) & \(I_3\) &  & \(Y\)\\[0pt]
\hline
X & X & 0 &  & X & X & X & X &  & Z\\[0pt]
0 & 0 & 1 &  & \(I_0\) & X & X & X &  & \(I_0\)\\[0pt]
0 & 1 & 1 &  & X & \(I_1\) & X & X &  & \(I_1\)\\[0pt]
1 & 0 & 1 &  & X & X & \(I_2\) & X &  & \(I_2\)\\[0pt]
1 & 1 & 1 &  & X & X & X & \(I_3\) &  & \(I_3\)\\[0pt]
\end{tabular}
\end{table}


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/mux_4_1_3s}
\caption{\label{fig:org30ef9ad}Multiplexeur quatre-vers-un trois états}
\end{figure}

La fonctionnalité trois-états permet aussi de concevoir un
émetteur-récepteur de bus. Ce dispositif, illustré à la figure
suivante (\ref{fig:org15ece8b}), permet d'établir une connexion
bidirectionnelle entre \texttt{I/O} et \texttt{O/I}. Lorsque l'entrée de contrôle
\(E = 0\), c'est le tampon du haut de la figure qui est actif, et
\texttt{O/I} détermine la valeur de \texttt{I/O}. Lorsque \(E = 1\), c'est le tampon
du bas qui est actif, et \texttt{I/O} détermine la valeur de \texttt{O/I}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/bus_trans}
\caption{\label{fig:org15ece8b}Émetteur-récepteur de bus}
\end{figure}


\part{Circuits logiques séquentiels}
\label{sec:org3433c65}
\chapter{Circuits séquentiels}
\label{sec:org5d91284}

\section{Objectifs}
\label{sec:org5889105}
\begin{itemize}
\item Identifier un circuit logique séquentiel
\item Faire la distinction entre les circuits séquentiels synchrones et asynchrones
\item Se familiariser avec les principaux types de loquets, en expliquer
le fonctionnement
\item Se familiariser avec les principaux types de bascules, en expliquer
le fonctionnement
\end{itemize}

\section{Modèle d'un circuit séquentiel}
\label{sec:org9385cbd}

Les circuits logiques séquentiels sont ceux qui comportent de la
mémoire. Le modèle général d'un circuit séquentiel est illustré sur la
figure \ref{fig:org296e48e}. On y voit qu'il y a une boucle de rétroaction,
qui fait que les valeurs binaires stockées dans les éléments de
mémoire contribuent au calcul des sorties. Les sorties du circuit à un
instant donné ne dépendent donc pas seulement des entrées présentes à
ce moment, mais aussi de ces valeurs qui sont mémorisées dans le
système. Pour décrire cette situation dans laquelle se trouvent les
valeurs stockées en mémoire, on parle de l'\textbf{état} du système. Selon
les entrées et l'état à un instant donné, le système pourra changer
d'état selon les changements qui seront apportés par la portion
combinatoire aux valeurs mémorisées.

On verra donc le système évoluer au fil du temps, passant d'un état à
un autre, et générant des sorties en fonction des entrées et de l'état
du moment. Intuitivement, on peut penser que le nombre d'états
distincts sera fonction du nombre de valeurs binaires qui seront
mémorisées. Le comportement d'un système séquentiel est donc
caractérisé par une séquence temporelle d'entrées, de sorties et de
valeurs internes d'état.

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{Sources_images_logiques/images/circuit_seq.png}
\caption{\label{fig:org296e48e}Modèle de circuit séquentiel}
\end{figure}

On peut distinguer les circuits séquentiels selon la relation de
synchronisation qui existe entre les différents signaux du
système. Dans un circuit séquentiel \textbf{synchrone}, le comportement du
système peut se définir en fonction des valeurs de ses signaux à des
instants discrets prédéterminés. 

Le comportement d'un circuit séquentiel \textbf{asynchrone} dépend à tout
moment des signaux d'entrée et de l'ordre dans lequel ces signaux
changent.

Un circuit séquentiel synchrone fait appel à un signal spécial appelé
\textbf{horloge} qui rythme les changements d'état et de sorties afin qu'ils se
produisent à des instants discrets. Les éléments de mémoire qui
stockent les valeurs binaires sont appelés \textbf{bascules} (\emph{flip-flops} en
anglais). Il existe différents types de bascules. Nous les étudierons
en détail, car elles sont à la base des circuits séquentiels les plus
utilisés. La figure \ref{fig:org73c3829} présente le modèle général d'un
circuit séquentiel synchrone.

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{Sources_images_logiques/images/circuit_seq_sync.png}
\caption{\label{fig:org73c3829}Modèle de circuit séquentiel synchrone}
\end{figure}

Le signal d'horloge est typiquement une onde carrée, comme illustré
sur la figure \ref{fig:org972e7e0}.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/horloge}
\caption{\label{fig:org972e7e0}Signal d'horloge}
\end{figure}

\section{Éléments de mémoire}
\label{sec:orgb1848f4}

Un élément de mémoire peut maintenir son état binaire indéfiniment (à
condition, évidemment, qu'il soit alimenté). Son état est observable
par l'intermédiaire de ses sorties. On doit agir via la ou les entrées
de l'élément pour le faire changer d'état. Les différents types
d'éléments de mémoire sont caractérisés par le nombre et le type
d'entrées.

Les éléments de mémoire qui sont contrôlés par les niveaux de leurs
entrées sont appelés des \textbf{loquets} (\emph{latches} en anglais). Les
éléments contrôlés par des changements ou \textbf{transitions} de niveaux
sont appelés des bascules. Les transitions sont appliquées à une
entrée spéciale d'horloge qui sert à déclencher les changements d'état
à des instants précis. Les loquets sont des ingrédients de base dans
la conception des bascules. Nous les étudierons en premier.

\section{Loquets}
\label{sec:orge956ab2}

\begin{enumerate}
\item Loquet SR
\label{sec:orgebe7ac2}

Le loquet SR est formé de deux portes NOR interconnectées et comporte
deux entrées: \(S\) pour \texttt{Set}, qui permet de mémoriser une valeur 1,
et \(R\) pour \texttt{Reset}, qui permet de mémoriser une valeur 0. Le schéma
classique du loquet SR montré sur la figure \ref{fig:orga95543d} ne fait pas
ressortir la boucle de rétroaction, mais si on déplace un peu les
éléments sans changer les connexions, on voit mieux le lien de retour
caractéristique de la boucle. Sur la figure \ref{fig:orgfd57cb7}, la porte reliée
à \(S\) a été placée devant, mais nous aurions pu tout aussi bien
mettre l'autre porte en avant. Aucune des deux n'est vraiment devant
l'autre, puisqu'il s'agit d'une boucle n'ayant ni début ni fin.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/SRlatch}
\caption{\label{fig:orga95543d}Schéma du loquet SR avec portes NOR}
\end{figure}


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/SRlatch_bouc}
\caption{\label{fig:orgfd57cb7}Schéma du loquet SR NOR mettant la boucle en évidence}
\end{figure}

Quand les sorties sont \(Q=1, Q^\prime=0\), on dit que le loquet est
dans l'état activé (\texttt{set}). Lorsque \(Q=0, Q^\prime=1\), le loquet
est désactivé (\texttt{reset}). Les sorties \(Q\) et \(Q^\prime\) sont
normalement complémentaires. Si on active la condition d'entrée \(S=1,
R=1\), les deux sorties seront à 0, mais lorsqu'on relâchera les
entrées, le loquet passera à un état imprévisible, voire
instable. Dans une application normale, on voudra éviter le cas
d'entrée \(S=1, R=1\). 

En fonctionnement normal, à moins de vouloir changer l'état, on garde
les deux entrées à \(S=0, R=0\) et l'état du loquet se maintient. En
appliquant le niveau 1 pendant un certain temps à \(S\) seulement, le
loquet s'active, peu importe l'état dans lequel il se trouvait
auparavant. On doit s'assurer de ramener l'entrée \(S\) à 0 avant
d'apporter d'autres changements aux entrées, pour éviter le cas
interdit \(S=1, R=1\).

De même, en appliquant le niveau 1 pendant un certain
temps à \(R\) seulement, le loquet se désactive, peu importe l'état
dans lequel il se trouvait auparavant.

\begin{table}[htbp]
\caption{\label{tab:org16edc4d}Loquet SR NOR: tableau de fonctionnement}
\centering
\begin{tabular}{rrlrrl}
\(S\) & \(R\) &  & \(Q\) & \(Q^\prime\) & \\[0pt]
\hline
1 & 0 &  & 1 & 0 & \\[0pt]
0 & 0 &  & 1 & 0 & après \(s=1, R=0\)\\[0pt]
0 & 1 &  & 0 & 1 & \\[0pt]
0 & 0 &  & 0 & 1 & après \(s=0, R=1\)\\[0pt]
1 & 1 &  & 0 & 0 & interdit\\[0pt]
\end{tabular}
\end{table}

On peut aussi concevoir un loquet avec des portes NAND, comme sur la
figure \ref{fig:orge6f96bc}. Le fonctionnement est sensiblement le même,
si ce n'est que les niveaux sont inversés par rapport au loquet NOR
comme on peut le voir sur le tableau de fonctionnement (tableau
\ref{tab:orgdce47ab}). Par exemple, on garde les deux entrées à \(S=1, R=1\)
pour maintenir l'état du loquet.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/SRlatch_nand}
\caption{\label{fig:orge6f96bc}Loquet SR en portes NAND}
\end{figure}

\begin{table}[htbp]
\caption{\label{tab:orgdce47ab}Loquet SR NAND: tableau de fonctionnement}
\centering
\begin{tabular}{rrlrrl}
\(S\) & \(R\) &  & \(Q\) & \(Q^\prime\) & \\[0pt]
\hline
1 & 0 &  & 0 & 1 & \\[0pt]
1 & 1 &  & 0 & 1 & après \(s=1, R=0\)\\[0pt]
0 & 1 &  & 1 & 0 & \\[0pt]
1 & 1 &  & 1 & 0 & après \(s=0, R=1\)\\[0pt]
0 & 0 &  & 1 & 1 & interdit\\[0pt]
\end{tabular}
\end{table}

On peut ajouter un signal de contrôle d'entrée \(E\) (\emph{enable}) pour
contrôler \textbf{quand} le loquet pourra être affecté par les signaux
d'entrée. Le circuit est représenté à la figure \ref{fig:org349d078}. Comme
on peut voir dans le tableau \ref{tab:org2eab2d0}, les sorties des portes
NAND d'entrée demeurent à 1 tant que \(E = 0\), et le loquet ne peut
pas être affecté par les entrées \(S\) et \(R\). Quand on active \(E
= 1\), le circuit peut être actionné par les entrées \(S\) et \(R\). La condition pour activer est \(S=1, R=0\); pour désactiver,
c'est \(S=0, R=1\). Lorsque \(E = 1\), on ne doit pas faire \(S=1,
R=1\), car on mettrait le loquet dans un état indéterminé.

Le loquet SR avec contrôle est surtout important comme
ingrédient de base pour la conception de bascules.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/SRlatch_nand_en}
\caption{\label{fig:org349d078}Loquet SR NAND avec signal de contrôle}
\end{figure}

\begin{table}[htbp]
\caption{\label{tab:org2eab2d0}Loquet SR avec signal de contrôle: tableau de fonctionnement}
\centering
\begin{tabular}{rrrll}
\(E\) & \(S\) & \(R\) &  & Prochain \(Q\)\\[0pt]
\hline
0 & X & X &  & inchangé\\[0pt]
1 & 0 & 0 &  & inchangé\\[0pt]
1 & 0 & 1 &  & \(Q = 0\)\\[0pt]
1 & 1 & 0 &  & \(Q = 1\)\\[0pt]
1 & 1 & 1 &  & indéterminé\\[0pt]
\end{tabular}
\end{table}

\item Loquet D
\label{sec:org5b70d8b}
Une option pour éliminer la condition qui fait apparaître un état
indéterminé est de s'assurer de toujours commander \(S\) et \(R\)
avec des signaux complémentaires. C'est ainsi qu'on arrive au loquet
D, illustré sur la figure \ref{fig:org5b44f51}, qui ne comporte qu'une entrée de
donnée \(D\) et une entrée de contrôle \(E\). La valeur de \(D\) est
reflétée à \(Q\) lorsque \(E=1\) et se maintient après que \(E\) passe
à 0 (tableau \ref{tab:org469e823}).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/Dlatch}
\caption{\label{fig:org5b44f51}Schéma du loquet D}
\end{figure}

\begin{table}[htbp]
\caption{\label{tab:org469e823}Loquet D: tableau de fonctionnement}
\centering
\begin{tabular}{rrll}
\(E\) & \(D\) &  & Prochain \(Q\)\\[0pt]
\hline
0 & X &  & inchangé\\[0pt]
1 & 0 &  & \(Q = 0\)\\[0pt]
1 & 1 &  & \(Q = 1\)\\[0pt]
\end{tabular}
\end{table}

Le symbole graphique d'un loquet D est illustré à la figure \ref{fig:orgbb29894}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/schema_latchD}
\caption{\label{fig:orgbb29894}Symbole du loquet D}
\end{figure}
\end{enumerate}

\section{Application: rebonds d'interrupteurs}
\label{sec:org1c9b0ae}

Lorsqu'on utilise un interrupteur pour commuter un signal entre les
niveaux qui correspondent aux valeurs logiques 0 et 1, le contact ne
se fait pas de façon franche sans hésitations, et le signal observé
rebondit plusieurs fois avant de se stabiliser à sa valeur, comme on
peut le voir sur la partie de gauche de la figure \ref{fig:org3b29660}. Ces
rapides allers-retours entre les niveaux peuvent bien souvent
déclencher un circuit logique et le mettre dans un état
imprévisible. Pour éviter ce problème, on peut faire appel à un loquet
selon la configuration de la partie droite de la figure. Le loquet
réagit dès que l'entrée B passe à 0. Même si cette entrée remonte à 1,
la valeur \(Q\) est maintenue. On obtient donc une transition franche sur
\(Q\).

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/debounce}
\caption{\label{fig:org3b29660}Contacts et rebonds}
\end{figure}

\section{Bascules (Flip-flops)}
\label{sec:org072a76a}

Les loquets peuvent remplir le rôle de mémoriser des valeurs binaires,
mais le fait que les changements d'état soient activés par un \textbf{niveau}
pose des difficultés. En effet, si les valeurs à l'entrée changent
pendant que le signal de contrôle est actif, la valeur qui sera
mémorisée par la rétroaction sera la dernière qui aura eu le temps de
s'y établir, qui ne sera pas nécessairement la valeur souhaitée. Si la
sortie du loquet est acheminée, directement ou à travers un circuit
combinatoire, vers ses entrées ou les entrées d'autres loquets
(activés par le même signal de contrôle) dans une boucle du circuit
séquentiel, il se peut que les délais de propagation et de prise en
compte des entrées fassent que la sortie globale du circuit séquentiel
soit imprévisible.

La conception des bascules vise à corriger ce problème, en établissant
un instant précis et prévisible de déclenchement où les valeurs
d'entrée seront prises en compte systématiquement. Le concept
essentiel est que l'état d'une bascule est modifié uniquement au
moment où il y a un changement dans son signal de contrôle. Ce
changement momentané est appelé \textbf{transition} et on dit que c'est la
transition qui provoque le changement d'état qui \textbf{déclenche} la
bascule.

On parlera de déclenchement sur le \textbf{front montant} lorsque la
transition qui provoque le déclenchement passe d'un niveau bas vers un
niveau élevé, et de déclenchement sur le \textbf{front descendant} dans le
cas d'une transition du haut vers le bas.  On illustre parfois le
front de déclenchement au moyen d'une flèche, comme on peut le voir
sur la figure \ref{fig:org79d1855}.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/horlogeP}
\caption{\label{fig:org79d1855}Signaux d'horloge avec fronts de déclenchement}
\end{figure}

\begin{enumerate}
\item Bascule D
\label{sec:orgc5635c5}

Le secret pour isoler la valeur mémorisée par l'élément de mémoire des
changements qui pourraient survenir sur les entrées consiste à
utiliser un mécanisme semblable à celui d'un sas. Selon le \emph{Larousse}, la
définition d'un sas est

\begin{quote}
Enceinte ou passage clos, muni de deux portes ou systèmes de fermeture
dont on ne peut ouvrir l'un que si l'autre est fermé et qui permet de
passer ou de faire passer d'un milieu à un autre en maintenant ceux-ci
isolés l'un de l'autre.
\end{quote}

Dans notre contexte, nous utiliserons deux loquets en série, avec la
sortie du premier, appelé \textbf{maître}, reliée à l'entrée du second,
appelé \textbf{esclave}. Le loquet maître sera activé par le signal d'horloge,
alors que le loquet esclave sera activé par le complément du signal
d'horloge. De cette façon, un seul des loquets sera actif à la fois,
comme dans un sas. La figure \ref{fig:orgeadbe10} illustre la
configuration pour réaliser une bascule D maître-esclave.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_mast_slave_sanst}
\caption{\label{fig:orgeadbe10}Bascule D maître-esclave}
\end{figure}

Lorsque le signal d'horloge est au niveau haut, seul le loquet maître
pourra réagir au signal d'entrée. Puis, lorsque le signal d'horloge
sera au niveau bas, ce premier loquet sera désactivé, sa sortie sera
maintenue, et le deuxième loquet sera activé. Comme l'entrée du loquet
esclave est alimentée par le loquet maître dont la sortie est
maintenue, c'est la valeur mémorisée par le maître qui sera mémorisée
dans l'esclave et qui apparaîtra donc en sortie de l'ensemble.

La valeur qui sera ultimement mémorisée est celle qui se trouvait tout
juste avant la transition de l'horloge passant du niveau haut vers le
niveau bas. Nous avons donc créé une bascule sensible au front
descendant.

En résumé:
\begin{enumerate}
\item La sortie \(Q\) ne changera qu'une fois par cycle d'horloge.
\item Un changement de valeur sera causé par la valeur d'entrée présente
juste avant le front descendant de l'horloge.
\item La valeur de sortie changera effectivement (s'il y a lieu) pendant
la demi-période basse de l'horloge.
\end{enumerate}

D'autres configurations permettent de réaliser ce comportement de
sas. Par exemple, le circuit de la figure \ref{fig:org8999427} utilise
trois éléments en loquet SR NAND: les deux premiers sont activés par
le signal de donnée \(D\) et l'horloge, et le dernier mémorise et
fournit le signal de sortie \(Q\). Cette configuration réalise une
bascule D à déclenchement sur front montant.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_front_montant}
\caption{\label{fig:org8999427}Bascule D à déclenchement sur front montant}
\end{figure}

Pour bien comprendre le comportement du circuit, la série de figures
suivantes permet d'en suivre le fonctionnement. Sur les figures,
les valeurs binaires sont indiquées par des couleurs: un signal en
vert sombre dénote la valeur 0 et un signal en vert clair représente
la valeur 1.

Comme on peut le voir sur la figure \ref{fig:org13473a9}, lorsque \(clk = 0\), les
entrées intermédiaires \(S\) et \(R\) sont maintenues au niveau 1,
quelle que soit la valeur de l'entrée \(D\), ce qui assure de
maintenir la valeur de sortie en \(Q\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_c0_d0}
\caption{\label{fig:org13473a9}Bascule au repos  \(clk = 0, D=0\)}
\end{figure}

Même lorsque l'entrée de donnée \(D\) change, la valeur de sortie est
maintenue, comme on le voit sur la figure \ref{fig:orgef391f6}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_c0_d1}
\caption{\label{fig:orgef391f6}Bascule au repos  \(clk = 0, D \rightarrow 1\)}
\end{figure}

Si l'entrée de donnée \(D = 0\) lorsque \(clk\) passe à 1, \(R\)
devient 0, ce qui met \(Q\) à 0 (opération \emph{reset}) (figure
\ref{fig:org14ac0e7}).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_c1_d0}
\caption{\label{fig:org14ac0e7}Bascule  \emph{reset} \(clk \rightarrow 1, D=0\)}
\end{figure}

Si l'entrée de donnée \(D\) change pendant que \(clk = 1\), comme sur
la figure \ref{fig:orgef5c928}, \(R\) reste à 0, parce que la porte NAND à
trois entrées a ses trois entrées à 1: par le signal \(clk = 1\), par
la rétroaction du signal \(S\) et par le signal de sortie de la porte
NAND du bas.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_c1_dchange}
\caption{\label{fig:orgef5c928}Bascule   \(clk = 1, D \rightarrow 1\)}
\end{figure}

Quand \(clk\) revient à 0, on a \(S=1, R=1\) et la sortie \(Q\) ne
peut plus changer.

La figure \ref{fig:org9f65668} présente la bascule dans l'état \(Q=0\)
avec l'entrée de donnée \(D = 1\), juste avant que \(clk\) passe
à 1. On voit que les deux portes NAND du haut sont prêtes à provoquer
un changement d'état de \(S\) lorsque l'horloge passera à 1.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_c0_d1_avant}
\caption{\label{fig:org9f65668}Bascule   \(clk =0, D = 1\)}
\end{figure}

Si l'entrée de donnée \(D = 1\) lorsque \(clk\) passe à 1, on voit
que \(S\) est devenu 1, ce qui a amené \(Q\) à 1 (opération \emph{set})
(figure \ref{fig:orge8037a3}).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_c1_d1}
\caption{\label{fig:orge8037a3}Bascule  \emph{set} \(clk \rightarrow 1, D=1\)}
\end{figure}

La figure \ref{fig:orgc265302} présente un chronogramme qui montre la bascule
qui passe de l'état 0 à l'état 1 et retourne, au cycle suivant, à
l'état 0.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/chron_D}
\caption{\label{fig:orgc265302}Chronogramme pour une bascule D}
\end{figure}

\item Délais et réponse temporelle
\label{sec:orga4a3e6c}

Comme dans tout circuit logique, les changements de valeurs logiques
dans les différentes portes qui constituent une bascule ne sont pas
instantanés. Il faut donc laisser le temps nécessaire pour que les
changements puissent se propager, être pris en compte et se stabiliser.

Sur la figure \ref{fig:org7bc9865}, on indique le délai \(t_{setup}\) entre le
moment où la valeur à l'entrée de donnée D est modifiée et la
prochaine transition de déclenchement de l'horloge. Pour assurer un
fonctionnement adéquat de la bascule, on doit respecter un temps de
\textbf{mise en place} (\emph{setup}) minimum pendant lequel la valeur à l'entrée
de donnée D doit être maintenue \textbf{avant} la transition de
déclenchement.

On montre aussi sur la figure le délai \(t_{hold}\) entre le moment de
déclenchement et un prochain changement de valeur à l'entrée de
donnée D. Pour un fonctionnement adéquat, on doit également respecter
un temps de \textbf{maintien} (\emph{hold}) minimum pendant lequel la valeur à
l'entrée de donnée D doit être maintenue \textbf{après} la transition de
déclenchement de l'horloge.

Enfin, la figure montre le délai de propagation à la sortie de la
bascule \(t_{prop}\), qui se mesure entre le moment du déclenchement et
le moment où la sortie se stabilise à sa nouvelle valeur.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/D_setup}
\caption{\label{fig:org7bc9865}Chronogramme avec temps et délais}
\end{figure}

Le symbole graphique d'une bascule D comporte un petit triangle à
l'entrée d'horloge pour indiquer que le déclenchement se fait sur une
transition. Un déclenchement sur front descendant est indiqué par un
petit cercle d'inversion à l'entrée d'horloge.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/schema_bascules}
\caption{\label{fig:orgeeb0a03}Symboles de bascules}
\end{figure}

\item Autres bascules
\label{sec:org95f9b4e}

Il y a essentiellement trois opérations possibles pour une bascule:
mettre sa sortie à 1 (\emph{set}), mettre sa sortie à 0 (\emph{reset}) ou faire
basculer son état de sortie (\emph{toggle}).

\item Bascule JK
\label{sec:orga051235}

Une bascule JK comporte deux entrées, ce qui permet de lui faire
exécuter les trois opérations. Activer seulement l'entrée \(J\) fait
un \emph{set}, activer seulement l'entrée \(K\) fait un \emph{reset} et activer
les deux entrées fait un \emph{toggle}. On peut réaliser une bascule JK
comme sur la figure \ref{fig:org2322e34}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/bascule_JK}
\caption{\label{fig:org3ec2e67}Bascule JK}
\end{figure}

La figure \ref{fig:orgf0f5e33} montre le chronogramme de fonctionnement
d'une bascule JK. La bascule fait d'abord un \emph{set}, puis un \emph{reset} et
enfin trois \emph{toggles} de suite.

\begin{figure}[htbp]
\centering
\includesvg[width=.9\linewidth]{Sources_images_logiques/images/chron_JK}
\caption{\label{fig:orgf0f5e33}Chronogramme de la bascule JK}
\end{figure}

\item Bascule T
\label{sec:org10b3f8b}

La bascule T (T pour \emph{toggle}) change d'état à chaque déclenchement
lorsque l'entrée \(T\) est activée. On peut la réaliser à partir d'une
bascule D ou d'une bascule JK (figure \ref{fig:org3b09036}).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/basculeT}
\caption{\label{fig:org3b09036}Bascule T}
\end{figure}

\item Tableaux caractéristiques
\label{sec:org624f622}

On résume le fonctionnement des différentes bascules au moyen de
tableaux qui décrivent, selon les conditions d'entrée et l'état
présent, quel sera le prochain état après le déclenchement. \(Q(t)\)
représente l'état présent et \(Q(t+1)\) l'état suivant.

\begin{table}[htbp]
\caption{\label{tab:org6e7e400}Bascule D}
\centering
\begin{tabular}{rrll}
\(D\) & \(Q(t+1)\) &  & \\[0pt]
\hline
0 & 0 &  & \emph{reset}\\[0pt]
1 & 1 &  & \emph{set}\\[0pt]
\end{tabular}
\end{table}

\begin{table}[htbp]
\caption{\label{tab:org19ca048}Bascule JK}
\centering
\begin{tabular}{rrlll}
\(J\) & \(K\) &  & \(Q(t+1)\) & \\[0pt]
\hline
0 & 0 &  & \(Q(t)\) & pas de changement\\[0pt]
0 & 1 &  & 0 & \emph{reset}\\[0pt]
1 & 0 &  & 1 & \emph{set}\\[0pt]
1 & 1 &  & \(Q^\prime(t)\) & basculement\\[0pt]
\end{tabular}
\end{table}

\begin{table}[htbp]
\caption{\label{tab:orge71572c}Bascule T}
\centering
\begin{tabular}{rlll}
\(T\) &  & \(Q(t+1)\) & \\[0pt]
\hline
0 &  & \(Q(t)\) & pas de changement\\[0pt]
1 &  & \(Q^\prime(t)\) & basculement\\[0pt]
\end{tabular}
\end{table}

\item Équations caractéristiques
\label{sec:org16dd7aa}

On peut de même formuler des équations qui décrivent le comportement
des bascules. Pour une bascule D, on a

$$ Q(t+1) = D $$

Pour une bascule JK, on a

$$ Q(t+1) =J Q^\prime + K^\prime Q $$

Pour une bascule T, on a

$$ Q(t+1) = T \operatorname{Xor} Q = T Q^\prime + T^\prime Q $$

\item Entrées asynchrones
\label{sec:org5216025}

Certaines bascules sont aussi munies d'entrées asynchrones, dont
l'effet n'est pas soumis à l'horloge. Ces entrées sont typiquement
utilisées pour faire un \emph{reset} ou un \emph{set} de la bascule, par exemple
pour une remise à zéro initiale d'un circuit séquentiel. Une
configuration typique est illustrée par la bascule de la figure
\ref{fig:org00f69a5} qui comporte une entrée \texttt{Reset'}, laquelle
permet de forcer l'état en agissant sur une porte NAND de chacune des
paires de portes. Cette entrée est active au niveau bas, c'est
pourquoi il y a une indication de complément dans son symbole.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/D_front_montant_setasyn}
\caption{\label{fig:org00f69a5}Bascule D avec reset asynchrone}
\end{figure}
\end{enumerate}

\chapter{Analyse de circuits logiques séquentiels synchrones}
\label{sec:org167b719}
\section{Objectifs}
\label{sec:org0ead4bd}
\begin{itemize}
\item Analyser en détail le comportement d'un circuit séquentiel
synchrone à partir de son schéma, selon différents types de bascules
employés
\item Établir les équations de transition qui commandent les bascules
\item Se familiariser avec la notion de tableau d'excitation
\item Tracer un diagramme d'état
\item Interpréter le comportement du système à partir de son
diagramme d'état
\item Faire la distinction entre les deux modèles de circuits séquentiels
(Mealy et Moore)
\end{itemize}

\section{Démarche d'analyse}
\label{sec:org0dff05d}

Analyser un circuit logique séquentiel a pour but de déterminer le
comportement qu'aura le circuit selon les séquences d'entrée qui lui
seront appliquées et l'état dans lequel il se trouve initialement. On
voudra aussi connaître quelles séquences de sortie seront produites.

Dans la mesure où un circuit comporte une ou des bascules (peu importe
le type) et un signal d'horloge, on peut considérer qu'il s'agit d'un
circuit séquentiel synchrone. Le type de bascule sera pris en compte
pour l'analyse, qui consistera à déterminer, pour un état présent
donné, quels seront les prochains états possibles selon les valeurs
d'entrée.

Les grandes lignes de la démarche sont les suivantes.

\begin{enumerate}
\item Identification des éléments fonctionnels:

\begin{enumerate}
\item entrées externes

\item éléments de mémoire

\item décodeur de prochain état

\item sorties externes

\item décodeur de sortie
\end{enumerate}
\item Expressions logiques du décodeur de prochain état: établies pour
chaque entrée des bascules, en fonction des entrées externes et des
variables d'état
\item Expressions logiques des sorties externes, établies en fonction des
entrées externes et des variables d'état
\item Construction du tableau d'excitation
\item Diagramme d'état
\item Interprétation du comportement du circuit séquentiel
\end{enumerate}

Au centre de ce processus se trouve l'analyse des circuits
combinatoires qui déterminent ce que seront les entrées des
bascules. Nous chercherons à établir les \textbf{équations de transition} qui
précisent ce que sera le prochain état en fonction des entrées et de
l'état présent.

\section{Exemple d'analyse}
\label{sec:orgbf4c3b2}

Nous allons appliquer la démarche à un exemple qui nous permettra de
mieux expliquer chacune des étapes. Considérons le circuit de la
figure \ref{fig:orgfc9ac4b}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemple_seq1}
\caption{\label{fig:orgfc9ac4b}Circuit séquentiel synchrone à analyser}
\end{figure}

\begin{enumerate}
\item Identification des éléments fonctionnels:

\begin{enumerate}
\item Il y a une seule entrée externe \(I\)
\item Il y a deux éléments de mémoire, étiquetés \(Z_0^n\) et  \(Z_1^n\)
\item On a un décodeur de prochain état pour deux bascules D
\item Il y a deux sorties externes: \(S\) et \(U\)
\item Il y a un décodeur de sortie
\end{enumerate}

\item Expressions logiques pour le décodeur de prochain état:
\end{enumerate}
$$ Z_0^{n+1} = I \cdot (Z_1^n)^\prime  + I \cdot Z_0^n $$

$$ Z_1^{n+1} = I \cdot Z_1^n +  Z_0^n  $$

\begin{enumerate}
\item Expressions logiques des sorties externes:
\end{enumerate}
$$ S =  Z_0^n \cdot (Z_1^{n})^\prime $$

$$ U =  Z_0^n \cdot Z_1^{n} $$

\begin{enumerate}
\item Tableau d'excitation: chaque ligne du tableau d'excitation (tableau \ref{tab:org99da585}) montre, à gauche,
\end{enumerate}
un état présent (identifiable par les valeurs des bascules) et une
combinaison de valeurs d'entrée, et à droite, le prochain état et les
valeurs de sortie produites.

\begin{table}[htbp]
\caption{\label{tab:org99da585}Tableau d'excitation pour l'exemple}
\centering
\begin{tabular}{rrrlrrrr}
\(Z_1^n\) & \(Z_0^n\) & \(I\) &  & \(Z_1^{n+1}\) & \(Z_0^{n+1}\) & \(S\) & \(U\)\\[0pt]
\hline
0 & 0 & 0 &  & 0 & 0 & 0 & 0\\[0pt]
0 & 0 & 1 &  & 0 & 1 & 0 & 0\\[0pt]
0 & 1 & 0 &  & 1 & 0 & 1 & 0\\[0pt]
0 & 1 & 1 &  & 1 & 1 & 1 & 0\\[0pt]
1 & 0 & 0 &  & 0 & 0 & 0 & 0\\[0pt]
1 & 0 & 1 &  & 1 & 0 & 0 & 0\\[0pt]
1 & 1 & 0 &  & 1 & 0 & 0 & 1\\[0pt]
1 & 1 & 1 &  & 1 & 1 & 0 & 1\\[0pt]
\end{tabular}
\end{table}

\begin{enumerate}
\item Diagramme d'état: le diagramme d'état représente de façon schématique le comportement du
\end{enumerate}
circuit séquentiel. Les cercles correspondent aux différents états
dans lesquels le système peut se trouver. On peut utiliser des
étiquettes à l'intérieur des cercles pour nommer les états. On peut
aussi y indiquer les numéros d'état (soit en vecteurs de bits, soit
avec des nombres binaires comme ici sur la figure). Les sorties
produites par le système sont aussi indiquées dans les cercles.  Les
transitions entre les états sont indiquées par des flèches. Une flèche
qui revient vers le même cercle signifie que l'état ne change pas.

Les conditions appliquées aux entrées pour déclencher les transitions
sont indiquées sur les flèches. Dans la figure, on voit aussi l'état
initial, identifié par une flèche partant d'un gros point noir.

Le diagramme d'état se construit aisément à partir du tableau
d'excitation.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemple_seq1_fsm}
\caption{\label{fig:org5a03247}Diagramme d'état}
\end{figure}

\begin{enumerate}
\item Interprétation du comportement du circuit séquentiel: le système est initialement à l'état \emph{a}. Tant que l'entrée \(I\) est 0,
\end{enumerate}
il demeure dans cet état. Lorsque \(I=1\), on passe à l'état \emph{b}. Si
\(I\) reste à 1, on passe à l'état \emph{d} et on boucle sur l'état \emph{d}. Si
\(I\) revient à 0, de l'état \emph{b} ou \emph{d}, on passe à l'état \emph{c}. De l'état \emph{c},
si \(I = 1\), on reste dans l'état \emph{c}. Sinon (\(I = 0\)), on retourne à
l'état \emph{a}.

La figure \ref{fig:org84cc3ce} montre une trace des formes d'onde
observées en fonctionnement pour le système. Dans cet exemple, le
système boucle d'abord sur l'état \emph{a} (valeur 0 sur la trace), puis
passe à l'état \emph{b} (valeur 1) et ensuite à l'état \emph{d} (valeur 3),
boucle sur l'état \emph{d} et passe ensuite à l'état \emph{c} (valeur 2) pour
finalement revenir à l'état \emph{a}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemple_seq1_run}
\caption{\label{fig:org84cc3ce}Exemple de fonctionnement}
\end{figure}

\section{Analyse pour des bascules JK}
\label{sec:org5fe1129}

Pour analyser un circuit séquentiel utilisant des bascules JK, on
détermine d'abord les expressions \(J_A\) et \(K_A\), \(J_B\) et
\(K_B\), etc., pour chacune des bascules. On doit ensuite se référer
au tableau caractéristique pour ce type de bascule (tableau
\ref{tab:org19ca048}) pour déterminer quelles seront les prochaines valeurs
de sortie pour chacune des bascules. L'exemple suivant illustre la
procédure.

\begin{enumerate}
\item Exemple avec bascules JK
\label{sec:orga191d6a}
Considérons le circuit séquentiel de la figure \ref{fig:org74326fe}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/seq_JK}
\caption{\label{fig:org74326fe}Exemple de circuit séquentiel avec des bascules JK}
\end{figure}

À partir des expressions des entrées \(J\) et \(K\) suivantes:

$$ J_0 = (q_1^{n})^\prime $$

$$ K_0 = q_0^{n} \cdot (q_1^{n})^\prime $$

$$ J_1 = q_0^{n} $$

$$ K_1 = (q_0^{n})^\prime \cdot q_1^{n} $$

on peut remplir le tableau d'excitation (tableau \ref{tab:org4a4c2af}).

\begin{table}[htbp]
\caption{\label{tab:org4a4c2af}Tableau d'excitation circuit séquentiel JK}
\centering
\begin{tabular}{rrrrrrlrr}
\(q_1^{n+1}\) & \(q_0^n\) & \(J_0\) & \(K_0\) & \(J_1\) & \(K_1\) &  & \(q_1^{n+1}\) & \(q_0^{n+1}\)\\[0pt]
\hline
0 & 0 & 1 & 0 & 0 & 0 &  & 0 & 1\\[0pt]
0 & 1 & 1 & 1 & 1 & 0 &  & 1 & 0\\[0pt]
1 & 0 & 0 & 0 & 0 & 1 &  & 0 & 0\\[0pt]
1 & 1 & 0 & 0 & 1 & 0 &  & 1 & 1\\[0pt]
\end{tabular}
\end{table}

À partir du tableau d'excitation, on peut tracer le diagramme d'état
(figure \ref{fig:org6bc38c4}).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/seq_JKb_FSM}
\caption{\label{fig:org6bc38c4}Diagramme d'état du circuit séquentiel avec bascules JK}
\end{figure}
\end{enumerate}

\section{Modèles de machines séquentielles}
\label{sec:org0a7c18e}

On appelle les modèles abstraits de systèmes séquentiels des
\textbf{automates finis} ou des \textbf{machines à état fini} (en anglais, \emph{Finite
State Machines} (FSM)).  On distingue deux modèles de circuits
séquentiels, selon la façon dont les sorties sont obtenues. Dans le
modèle de Mealy, les sorties dépendent à la fois des entrées et des
variables d'état présent (figure \ref{fig:orgbd8cead}). Dans le modèle de Moore,
les sorties ne dépendent que des variables d'état présent (figure
\ref{fig:orgc43f99f}).

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{Sources_images_logiques/images/mealy.png}
\caption{\label{fig:orgbd8cead}Machine de Mealy}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{Sources_images_logiques/images/moore.png}
\caption{\label{fig:orgc43f99f}Machine de Moore}
\end{figure}

\chapter{Conception de circuits logiques séquentiels}
\label{sec:orge1521b6}
\section{Objectifs}
\label{sec:org5adafb8}
\begin{itemize}
\item Concevoir un circuit logique séquentiel synchrone à partir
d'une spécification fonctionnelle
\item Construire un diagramme d'état en fonction d'un besoin
\item Construire un tableau d'état en fonction d'un diagramme d'état
\item Réduire le nombre d'états nécessaires
\item Assigner des codes binaires aux états et choisir une approche
\item Concevoir un décodeur de prochain état et un décodeur de sortie
\end{itemize}

\section{Conception d'un circuit séquentiel synchrone}
\label{sec:org0265850}

Concevoir un circuit logique séquentiel permet de répondre à un besoin
pratique qui ne peut pas être satisfait par un circuit combinatoire.
Le point de départ est une description, la plus précise possible, du
besoin à satisfaire: quelles doivent être la ou les entrées, sorties
ou conditions qui font passer d'un état au suivant, etc. Pour un
besoin donné, une multitude de solutions fonctionnellement
équivalentes sont possibles; ainsi, il faudra établir des critères ou
identifier des contraintes qui permettront d'orienter la conception et
le choix final d'une solution. Deux systèmes peuvent avoir un même
comportement vu de l'extérieur, mais comporter des nombres d'états
internes différents.

Des considérations pratiques nous amèneront souvent à vouloir réduire
le nombre d'états nécessaires, et à simplifier les différents circuits
combinatoires utilisés. Réduire le nombre de bascules utilisées ne se
traduit pas toujours par un système plus simple, car les décodeurs
d'état et de sortie peuvent alors s'en trouver plus complexes.

\section{Spécification fonctionnelle}
\label{sec:org9a6f99e}

Comme dans tout problème de conception, la formulation en mots de la
spécification du système est cruciale. Appliquer parfaitement une
procédure de conception en se basant sur une spécification erronée ne
peut pas conduire à un système adéquat.

Il faudra un bon bagage d'expérience et d'intuition au concepteur ou à
la conceptrice pour pouvoir interpréter une description informelle,
très souvent incomplète, ambiguë et imprécise, et la traduire
correctement en un design concret qui répond à un besoin
maladroitement exprimé. Il revient à cette personne de s'assurer que
ce qu'elle a compris correspond bien à ce qui était demandé.

La première question à poser est: \emph{Que doit faire le système?}
Suivront d'autres questions, amenant à définir davantage de détails:
\emph{Doit-il y avoir des entrées? Si oui, combien? Combien de sorties sont
nécessaires?} Le comportement du système pourra être essentiellement
caractérisé en répondant à la question: \emph{Quelle doit être la séquence
des sorties, pour une certaine séquence d'entrées?} Mais comme les
séquences d'entrées peuvent être en nombre infini, il faudra
identifier des patrons qui permettront de résumer le comportement du
système.

\section{Diagramme d'état}
\label{sec:orgb50a07a}

Un diagramme d'état préliminaire est un bon point de départ pour
définir et étudier le comportement du système. On identifiera les
différents états par des lettres pour les distinguer sans faire
référence à des variables binaires associées à des éléments de
mémoire. Il s'agit dans un premier temps d'un diagramme préliminaire,
parce que le diagramme final qui sera implémenté sera potentiellement
différent.

À partir du diagramme d'état, il est possible de vérifier quelle
séquence de sortie correspond à une séquence d'entrée donnée, et ainsi
de valider le comportement.

\chapter{Tableau d'état}
\label{sec:org9872e2a}

Un tableau d'état comporte une ligne par état présent et combinaison
d'entrées. Selon les combinaisons d'entrées possibles, on donne le
prochain état et les valeurs de sortie.

\section{Réduction du nombre d'états}
\label{sec:orga2bfa92}

Deux états sont équivalents si, pour chaque combinaison d'entrées, ils
produisent la même sortie et amènent le système dans le même état ou
dans un état équivalent. Considérons le diagramme d'état de la figure
\ref{fig:org3f98a9a} et le tableau d'état correspondant (tableau 
\ref{tab:orgb5506f3}). On peut voir qu'il s'agit ici d'une machine de
Mealy, car les valeurs de sortie sont associées aux transitions.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemp_simplif_net}
\caption{\label{fig:org3f98a9a}Diagramme d'état avant réduction}
\end{figure}


\begin{table}[htbp]
\caption{\label{tab:orgfc80432}Tableau d'état initial}
\centering
\begin{tabular}{lrllr}
État présent & \(x\) &  & État suivant & \(S\)\\[0pt]
\hline
a & 0 &  & b & 1\\[0pt]
a & 1 &  & f & 1\\[0pt]
b & 0 &  & d & 0\\[0pt]
b & 1 &  & c & 1\\[0pt]
c & 0 &  & d & 0\\[0pt]
c & 1 &  & e & 0\\[0pt]
d & 0 &  & b & 1\\[0pt]
d & 1 &  & c & 1\\[0pt]
e & 0 &  & e & 1\\[0pt]
e & 1 &  & a & 1\\[0pt]
f & 0 &  & d & 0\\[0pt]
f & 1 &  & e & 0\\[0pt]
\end{tabular}
\end{table}

En inspectant les différents états, on voit que les états \emph{c} et \emph{f}
sont équivalents. En remplaçant l'état \emph{f} par l'état \emph{c}, on obtient
le nouveau tableau d'état (tableau \ref{tab:orgb5506f3}).

\begin{table}[htbp]
\caption{\label{tab:orgb5506f3}Tableau d'état après une simplification}
\centering
\begin{tabular}{lrllr}
État présent & \(x\) &  & État suivant & \(S\)\\[0pt]
\hline
a & 0 &  & b & 1\\[0pt]
a & 1 &  & c & 1\\[0pt]
b & 0 &  & d & 0\\[0pt]
b & 1 &  & c & 1\\[0pt]
c & 0 &  & d & 0\\[0pt]
c & 1 &  & e & 0\\[0pt]
d & 0 &  & b & 1\\[0pt]
d & 1 &  & c & 1\\[0pt]
e & 0 &  & e & 1\\[0pt]
e & 1 &  & a & 1\\[0pt]
\end{tabular}
\end{table}

On voit maintenant que les états \emph{a} et \emph{d} sont équivalents. En
remplaçant l'état \emph{d} par l'état \emph{a}, on obtient le tableau d'état
simplifié (tableau \ref{tab:org3fe9b70}). Il n'y a plus de simplification
possible. Nous sommes passés de six états à quatre.

\begin{table}[htbp]
\caption{\label{tab:org3fe9b70}Tableau d'état simplifié}
\centering
\begin{tabular}{lrllr}
État présent & \(x\) &  & État suivant & \(S\)\\[0pt]
\hline
a & 0 &  & b & 1\\[0pt]
a & 1 &  & c & 1\\[0pt]
b & 0 &  & d & 0\\[0pt]
b & 1 &  & c & 1\\[0pt]
c & 0 &  & d & 0\\[0pt]
c & 1 &  & e & 0\\[0pt]
e & 0 &  & e & 1\\[0pt]
e & 1 &  & a & 1\\[0pt]
\end{tabular}
\end{table}

Il faut bien s'assurer que le tableau d'état simplifié produit les
séquences de sortie désirées selon les séquences d'entrée appliquées.

\begin{enumerate}
\item Tableau d'implication
\label{sec:org133840f}

La méthode du tableau d'implication facilite l'identification des
états redondants à éliminer. Considérons le tableau d'état suivant,
qui correspond cette fois-ci à une machine de Moore dont nous allons
réduire le nombre d'états.

\begin{table}[htbp]
\caption{\label{tab:org07bb4a6}Tableau d'état (machine de Moore)}
\centering
\begin{tabular}{llllr}
État présent & État suivant &  & État suivant & \(S\)\\[0pt]
 & \(x=0\) &  & \(x=1\) & \\[0pt]
\hline
a & g &  & c & 0\\[0pt]
b & f &  & h & 0\\[0pt]
c & e &  & d & 1\\[0pt]
d & a &  & c & 0\\[0pt]
e & c &  & a & 1\\[0pt]
f & f &  & b & 1\\[0pt]
g & a &  & c & 0\\[0pt]
h & c &  & g & 1\\[0pt]
\end{tabular}
\end{table}

Un tableau d'implication comporte une entrée pour chaque paire d'états
dans le tableau d'état. Avec \(n\) états initialement (ici on a
\(n=8\)), on étiquettera les colonnes avec les \(n-1\) premiers états,
et les lignes avec les \(n-1\) derniers états. La première case vide,
en haut à gauche, sera notée [a;b] et la dernière en bas à droite sera
[g;h]. Voici le tableau avant d'être rempli (tableau
\ref{tab:orgbfda734}). Seules les cases qui ne comportent pas de \_
peuvent être remplies. Il n'y a par exemple rien d'utile à mettre dans
une case étiquetée [b;b], et on mettra l'information qui irait dans la
case [c;b] dans la case [b;c].

\begin{table}[htbp]
\caption{\label{tab:orgbfda734}Tableau d'implication}
\centering
\begin{tabular}{lllllllll}
b &  &  & \_ & \_ & \_ & \_ & \_ & \_\\[0pt]
c &  &  &  & \_ & \_ & \_ & \_ & \_\\[0pt]
d &  &  &  &  & \_ & \_ & \_ & \_\\[0pt]
e &  &  &  &  &  & \_ & \_ & \_\\[0pt]
f &  &  &  &  &  &  & \_ & \_\\[0pt]
g &  &  &  &  &  &  &  & \_\\[0pt]
h &  &  &  &  &  &  &  & \\[0pt]
\hline
 &  & a & b & c & d & e & f & g\\[0pt]
\end{tabular}
\end{table}

\begin{enumerate}
\item On applique la procédure en considérant chaque case du tableau, ce
qui permet de comparer chaque paire de lignes du tableau d'état.

\begin{itemize}
\item On vérifie dans un premier temps si les sorties sont
différentes. Si c'est le cas, on met un \(\checkmark\) dans la
case. Par exemple ici, \emph{a} et \emph{c}, \emph{a} et \emph{e}, \emph{a} et \emph{f}, \emph{a} et
\emph{h} ont des sorties différentes, donc on place des \(\checkmark\)
dans les cases [a;c], [a;e], [a;f] et [a;h].
\item Si les sorties sont les mêmes, on place dans la case les paires
d'états qu'une équivalence nécessiterait. Par exemple, pour la
case [a;b], une équivalence entre \emph{a} et \emph{b} nécessiterait les
équivalences g=f et c=h entre les états prochains. Pour la case
[a;d], une équivalence entre \emph{a} et \emph{d} nécessiterait les
équivalences g=a et c=c. Cette dernière, évidente, n'est pas
inscrite dans le tableau. Pour [b;d], on trouve f=a et h=c.
\item Si les sorties sont les mêmes et les paires d'états suivants sont
identiques ou encore sont les états mêmes qu'on est en train de
considérer, on met directement OUI dans le tableau. Par exemple,
pour la case [a;g], on a les paires g=a et c=c, donc on met
OUI. Pour la case [d;g], on a a=a et c=c, on met OUI
également. On continue ainsi, de colonne en colonne, pour obtenir
après ces étapes le résultat suivant (tableau \ref{tab:orgd2d09e1}).
\end{itemize}
\end{enumerate}

\begin{table}[htbp]
\caption{\label{tab:orgd2d09e1}Tableau d'implication, après étape 1}
\centering
\begin{tabular}{lllllllll}
b &  & g=f c=h & \_ & \_ & \_ & \_ & \_ & \_\\[0pt]
c &  & \(\checkmark\) & \(\checkmark\) & \_ & \_ & \_ & \_ & \_\\[0pt]
d &  & g=a & f=a h=c & \(\checkmark\) & \_ & \_ & \_ & \_\\[0pt]
e &  & \(\checkmark\) & \(\checkmark\) & d=a & \(\checkmark\) & \_ & \_ & \_\\[0pt]
f &  & \(\checkmark\) & \(\checkmark\) & e=f d=b & \(\checkmark\) & c=f a=b & \_ & \_\\[0pt]
g &  & OUI & f=a h=c & \(\checkmark\) & OUI & \(\checkmark\) & \(\checkmark\) & \_\\[0pt]
h &  & \(\checkmark\) & \(\checkmark\) & e=c d=g & \(\checkmark\) & a=g & f=c b=g & \(\checkmark\)\\[0pt]
\hline
 &  & a & b & c & d & e & f & g\\[0pt]
\end{tabular}
\end{table}

\begin{enumerate}
\setcounter{enumi}{1}
\item L'étape suivante consiste à considérer chaque case qui comporte
une ou des paires d'états impliqués. On regarde la case
correspondant à chaque paire, et s'il y a un \(\checkmark\) dans la
case, alors l'implication ne fonctionne pas. Par exemple, la case
[a;b] repose sur les équivalences g=f et c=h. Or si on regarde la
case [f;g], on voit qu'il s'y trouve un \(\checkmark\), ce qui veut
dire que \emph{f} et \emph{g} ne peuvent pas être équivalents, ce qui
implique que \emph{a} et \emph{b} ne pourront pas être équivalents. Ce n'est
pas la peine de regarder la case [c;h].  On remplacera donc les
paires de la case [a;b] par un \(\checkmark \checkmark\), pour faire
ressortir ces nouveaux échecs.
\item Un \(\checkmark \checkmark\) dans le tableau peut faire échouer d'autres
implications. Il faut donc revoir les cases avec des paires d'états
impliqués pour voir s'il faut changer leur statut. On continue à
revoir ainsi jusqu'à ce qu'il n'y ait plus d'ajouts de
\(\checkmark \checkmark\). On obtient finalement le tableau suivant
(tableau \ref{tab:orge059e7b}).
\end{enumerate}

\begin{table}[htbp]
\caption{\label{tab:orge059e7b}Tableau d'implication, après étape 3}
\centering
\begin{tabular}{lllllllll}
b &  & \(\checkmark \checkmark\) & \_ & \_ & \_ & \_ & \_ & \_\\[0pt]
c &  & \(\checkmark\) & \(\checkmark\) & \_ & \_ & \_ & \_ & \_\\[0pt]
d &  & g=a & \(\checkmark \checkmark\) & \(\checkmark\) & \_ & \_ & \_ & \_\\[0pt]
e &  & \(\checkmark\) & \(\checkmark\) & d=a & \(\checkmark\) & \_ & \_ & \_\\[0pt]
f &  & \(\checkmark\) & \(\checkmark\) & \(\checkmark \checkmark\) & \(\checkmark\) & \(\checkmark \checkmark\) & \_ & \_\\[0pt]
g &  & OUI & \(\checkmark \checkmark\) & \(\checkmark\) & OUI & \(\checkmark\) & \(\checkmark\) & \_\\[0pt]
h &  & \(\checkmark\) & \(\checkmark\) & e=c d=g & \(\checkmark\) & a=g & \(\checkmark \checkmark\) & \(\checkmark\)\\[0pt]
\hline
 &  & a & b & c & d & e & f & g\\[0pt]
\end{tabular}
\end{table}

\begin{enumerate}
\setcounter{enumi}{3}
\item Après cette étape, toutes les  cases qui contiennent OUI ou des
paires d'implications indiquent des équivalences d'états. Ici, on a
les équivalences suivantes: a=d, a=g, c=e, c=h, d=g, e=h. Les états
uniques résultants sont \emph{a}, \emph{b}, \emph{c} et \emph{f}. On obtient le tableau
d'état réduit suivant (tableau \ref{tab:orga349cfc}).
\end{enumerate}

\begin{table}[htbp]
\caption{\label{tab:orga349cfc}Tableau d'état réduit (machine de Moore)}
\centering
\begin{tabular}{llllr}
État présent & État suivant &  & État suivant & \(S\)\\[0pt]
 & \(x=0\) &  & \(x=1\) & \\[0pt]
\hline
a & a &  & c & 0\\[0pt]
b & f &  & c & 0\\[0pt]
c & c &  & a & 1\\[0pt]
f & f &  & b & 1\\[0pt]
\end{tabular}
\end{table}
\end{enumerate}


\section{Codage des états}
\label{sec:orge902d4b}

Une fois que le nombre d'états a été réduit, il faut assigner des
codes binaires aux états. Si on doit coder \(m\) états, il faudra
\(n\) bits, avec \(2^n \geq m\). Si le nombre de combinaisons
binaires est plus grand que le nombre d'états nécessaires, les
combinaisons inutilisées seront considérées comme des cas facultatifs.

Le choix d'une assignation des codes aux états aura des répercussions
sur la complexité du décodeur de prochain état et sur le décodeur de
sortie. Plusieurs options peuvent être envisagées: assigner des codes
dans l'ordre naturel d'énumération binaire, assigner selon un code
Gray, ou encore choisir une assignation où il y a un seul bit 1 par
code binaire (approche dite \emph{one-hot}). L'approche \emph{one-hot} requiert
plus de bascules, mais permet souvent de simplifier les décodeurs de
prochain état et de sortie. Le tableau \ref{tab:orgcfb3ed8} montre
un exemple possible d'assignation pour chacune de ces approches.

\begin{table}[htbp]
\caption{\label{tab:orgcfb3ed8}Possibilités d'assignation de codes d'états}
\centering
\begin{tabular}{lrrr}
État & Binaire & Gray & \emph{One-hot}\\[0pt]
\hline
a & 00 & 00 & 0001\\[0pt]
b & 01 & 01 & 0010\\[0pt]
c & 10 & 11 & 0100\\[0pt]
e & 11 & 10 & 1000\\[0pt]
\end{tabular}
\end{table}

\section{Décodeur d'état}
\label{sec:org170c4cc}

Après avoir décidé d'une assignation, on refait le tableau d'état
simplifié en remplaçant les étiquettes d'états symboliques par les
codes binaires correspondants. On obtient ainsi un \textbf{tableau de
transition}, qui permet d'élaborer les expressions logiques pour le
décodeur de prochain état. Le type de bascules à utiliser déterminera
les sorties nécessaires pour le décodeur d'état, en se basant sur les
tableaux caractéristiques de la section \ref{sec:org624f622}.

\section{Décodeur de sortie}
\label{sec:org144894c}

Une fois que le codage d'état est établi, la conception du décodeur de
sortie est directe. Un tableau de vérité avec comme entrées les
valeurs binaires d'états et comme sorties les valeurs de sorties
externes permet de déterminer les fonctions combinatoires à
implémenter.

\section{Procédure de conception}
\label{sec:orgdbdada4}

La conception d'un circuit séquentiel suit une procédure bien
définie. Étant donnée la complexité de cette tâche, on limite la
conception manuelle à des circuits relativement petits. Pour des
besoins plus ambitieux, des outils de synthèse automatisés ont été
développés. Ces procédures automatisées supposent typiquement des
bascules D, car la correspondance entre l'entrée et la prochaine
sortie est directe. Voici les étapes à suivre:

\begin{enumerate}
\item À partir de la description et des spécifications du comportement
souhaité, concevoir un diagramme d'état
\item Réduire le nombre d'états (si pertinent)
\item Assigner des codes binaires aux états
\item Remplir le tableau de transition
\item Sélectionner un type de bascules à utiliser
\item Déterminer les expressions simplifiées pour le décodeur de prochain
état et le décodeur de sortie
\item Tracer le schéma logique du circuit
\end{enumerate}

\section{Exemple de conception}
\label{sec:org31d0ef0}

On doit concevoir un circuit séquentiel qui détecte la séquence
binaire 101 lorsqu'elle apparaît dans sa séquence d'entrée. Une fois
la séquence identifiée, le système produira une sortie 1 et demeurera
dans le même état en continuant de produire une sortie 1, jusqu'à une
remise à zéro.

\begin{enumerate}
\item Bascules D
\label{sec:org2a783f9}

\begin{enumerate}
\item Diagramme d'état
\label{sec:orgf48a224}

Selon le diagramme d'état de la figure \ref{fig:org44344fb}, le
système démarre dans l'état \emph{a} et demeure dans cet état tant que
l'entrée \(A=0\). Lorsque \(A=1\), on passe à l'état \emph{b}, début de la
reconnaissance du patron 101. Ensuite, si \(A=1\), on reste dans
l'état \emph{b} parce que ce pourrait être le début d'une autre
séquence 101. De l'état \emph{b}, si \(A=0\), on passe à l'état \emph{c}, car on
a observé 10 en séquence. De l'état \emph{c}, si on a \(A=0\), la séquence
observée est maintenant de 100 et on doit tout recommencer en
retournant à l'état \emph{a}.  De l'état \emph{c}, si on a \(A=1\), alors on a
reconnu la séquence 101. On met la sortie \(S=1\) et on reste dans cet
état pour toutes les autres transitions, quelle que soit l'entrée. Il
s'agit ici d'une machine de Moore, puisque la sortie \(S=1\) est
produite lorsqu'on est dans l'état \emph{d}; on a \(S=0\) dans les autres
états.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/seq_101_sanscode}
\caption{\label{fig:org44344fb}Diagramme d'état pour détecter la séquence 101}
\end{figure}


\item Réduction d'états
\label{sec:org6c362e0}

Il n'y a pas de réduction d'états possible ici.

\item Assigner des codes binaires aux états
\label{sec:org3ebfcaf}

Pour quatre états, il nous faudra deux bascules.  Le tableau
   \ref{tab:orgb0f2c93} présente l'assignation d'états choisie.

\begin{table}[htbp]
\caption{\label{tab:orgb0f2c93}Tableau d'assignation d'état}
\centering
\begin{tabular}{lr}
État & Code\\[0pt]
\hline
a & 00\\[0pt]
b & 01\\[0pt]
c & 10\\[0pt]
d & 11\\[0pt]
\end{tabular}
\end{table}


\item Remplir le tableau de transition
\label{sec:org0d86972}

Le tableau \ref{tab:org1f4afc5} donne les transitions d'états. 

\begin{table}[htbp]
\caption{\label{tab:org1f4afc5}Tableau de transition d'états}
\centering
\begin{tabular}{rrrlrrr}
\(Z_1^n\) & \(Z_0^n\) & \(A\) &  & \(Z_1^{n+1}\) & \(Z_0^{n+1}\) & \(S\)\\[0pt]
\hline
0 & 0 & 0 &  & 0 & 0 & 0\\[0pt]
0 & 0 & 1 &  & 0 & 1 & 0\\[0pt]
0 & 1 & 0 &  & 1 & 0 & 0\\[0pt]
0 & 1 & 1 &  & 0 & 1 & 0\\[0pt]
1 & 0 & 0 &  & 0 & 0 & 0\\[0pt]
1 & 0 & 1 &  & 1 & 1 & 0\\[0pt]
1 & 1 & 0 &  & 1 & 1 & 1\\[0pt]
1 & 1 & 1 &  & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{table}


\item Sélectionner un type de bascules à utiliser
\label{sec:org1fd231b}

On choisit des bascules D. 

\item Déterminer les expressions simplifiées
\label{sec:org8d7d8c1}

Les diagrammes de Karnaugh correspondants sont donnés pour
\(Z_0^{n+1}\) (figure \ref{fig:org7f90cd1}), \(Z_1^{n+1}\) (figure
\ref{fig:org436e152}) et \(S\) (figure \ref{fig:org018ddfb}).  

Notons que la convention d'étiquetage des diagrammes est différente de
ce que nous avons vu précédemment.  Au lieu d'étiqueter les lignes et
les colonnes avec bits de minterms, on indique ici à l'extérieur du
diagramme proprement dit les variables (telles quelles ou
complémentées) et les régions du diagramme où on les retrouve. Par
exemple, en dessous du diagramme de la figure \ref{fig:org7f90cd1}, on
indique à partir de la gauche, une première région où la variable
\(A\) est complémentée (première colonne à gauche), puis une région
correspondant à deux colonnes où la variable est telle quelle (deux
colonnes du centre), et enfin une région où la variable est
complémentée (colonne du centre).

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.65]{Sources_images_logiques/images/diag-k_z0.png}
\caption{\label{fig:org7f90cd1}Diag-K pour \(Z_0^{n+1}\)}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.65]{Sources_images_logiques/images/diag-k_z1.png}
\caption{\label{fig:org436e152}Diag-K pour \(Z_1^{n+1}\)}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.65]{Sources_images_logiques/images/diag-k_S.png}
\caption{\label{fig:org018ddfb}Diag-K pour \(S\)}
\end{figure}

\item Décodeur de prochain état
\label{sec:org4c65191}

Les expressions pour le décodeur de prochain état sont:

$$ Z_1^{n+1} = (A^\prime \cdot Z_0^{n}) + (A \cdot  Z_1^{n}) $$

$$ Z_0^{n+1} = A + (Z_0^{n} \cdot Z_1^{n}) $$

\item Décodeur de sortie
\label{sec:org669fb17}

L'expression pour le décodeur de sortie est:

$$ S = Z_0^{n} \cdot Z_1^{n} $$

\item Tracer le schéma logique du circuit
\label{sec:org4759f91}

Le circuit obtenu est représenté sur la figure
\ref{fig:org80770dc}. On montre sur la figure
\ref{fig:org5a54d81} une trace d'exécution. Les premiers coups
d'horloge, l'entrée \(A=0\) et le système demeure dans l'état 0. Puis,
lorsque \(A=1\), on passe à l'état 1. Comme \(A\) reste à 1, on
demeure dans l'état 1 un certain temps. Puis, lorsque \(A=0\), on
passe à l'état 2. Avec \(A=1\) de nouveau, on passe à l'état 3 en
activant la sortie \(S=1\). On ne quittera plus cet état par la
suite. Une deuxième trace d'exécution (figure \ref{fig:org63ba74d}
) montre un cas où le système retourne à l'état 0 après avoir reçu une
séquence 100.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemp_seq101_circ}
\caption{\label{fig:org80770dc}Détecteur pour la séquence 101}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemp_seq101_trace1}
\caption{\label{fig:org5a54d81}Trace d'exécution avec succès}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemp_seq101_trace2}
\caption{\label{fig:org63ba74d}Trace d'exécution sans succès}
\end{figure}
\end{enumerate}

\item Autres types de bascules
\label{sec:org1692069}

Les fonctions du décodeur de prochain état se formulent naturellement
en fonction de bascules D.  Pour faire l'implémentation avec des
bascules JK ou T, il faut pouvoir déterminer les entrées nécessaires
pour amener les changements d'état requis. Pour ce faire, on
utilisera des \textbf{tableaux d'excitation} qui listent les combinaisons
d'entrées pour passer d'un état présent \(Q_n\) à un état prochain
\(Q_{n+1}\). Le tableau d'excitation pour une bascule JK est donné
dans le tableau \ref{tab:orge96b9f5} et celui pour une bascule T est donné
dans le tableau \ref{tab:org98d166b}.

\begin{table}[htbp]
\caption{\label{tab:orge96b9f5}Tableau d'excitation, bascule JK}
\centering
\begin{tabular}{rrlll}
\(Q_n\) & \(Q_{n+1}\) &  & \(J\) & \(K\)\\[0pt]
\hline
0 & 0 &  & 0 & X\\[0pt]
0 & 1 &  & 1 & X\\[0pt]
1 & 0 &  & X & 1\\[0pt]
1 & 1 &  & X & 0\\[0pt]
\end{tabular}
\end{table}

\begin{table}[htbp]
\caption{\label{tab:org98d166b}Tableau d'excitation, bascule T}
\centering
\begin{tabular}{rrlr}
\(Q_n\) & \(Q_{n+1}\) &  & \(T\)\\[0pt]
\hline
0 & 0 &  & 0\\[0pt]
0 & 1 &  & 1\\[0pt]
1 & 0 &  & 1\\[0pt]
1 & 1 &  & 0\\[0pt]
\end{tabular}
\end{table}

Reprenons le tableau de transition d'états pour notre exemple, tableau
\ref{tab:org1f4afc5}, en ajoutant les signaux à générer pour des
bascules JK. On obtient alors le tableau \ref{tab:orgd5d4069}.

\begin{table}[htbp]
\caption{\label{tab:orgd5d4069}Tableau de transition d'états, avec bascules JK}
\centering
\begin{tabular}{rrrlrllrll}
\(Z_1^n\) & \(Z_0^n\) & \(A\) &  & \(Z_1^{n+1}\) & \(J\) & \(K\) & \(Z_0^{n+1}\) & \(J\) & \(K\)\\[0pt]
\hline
0 & 0 & 0 &  & 0 & 0 & X & 0 & 0 & X\\[0pt]
0 & 0 & 1 &  & 0 & 0 & X & 1 & 1 & X\\[0pt]
0 & 1 & 0 &  & 1 & 1 & X & 0 & X & 1\\[0pt]
0 & 1 & 1 &  & 0 & 0 & X & 1 & X & 0\\[0pt]
1 & 0 & 0 &  & 0 & X & 1 & 0 & 0 & X\\[0pt]
1 & 0 & 1 &  & 1 & X & 0 & 1 & 1 & X\\[0pt]
1 & 1 & 0 &  & 1 & X & 0 & 1 & x & 0\\[0pt]
1 & 1 & 1 &  & 1 & X & 0 & 1 & x & 0\\[0pt]
\end{tabular}
\end{table}

On trouve les expressions simplifiées suivantes:

$$ J_{Z_1} = A^\prime \cdot Z_0^n $$

$$ K_{Z_1} = A^\prime \cdot (Z_0^n)^\prime $$

$$ J_{Z_0} = A $$ 

$$ K_{Z_0} = (A + Z_1^n)^\prime $$

Ce qui nous donne l'implémentation de la figure \ref{fig:orga54fbec}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemp_seq101_JK}
\caption{\label{fig:orga54fbec}Détecteur pour la séquence 101, bascules JK}
\end{figure}
\end{enumerate}

\section{États interdits}
\label{sec:org68fe644}

Lorsque le nombre d'états nécessaires pour le fonctionnement de
l'automate fini est strictement inférieur au nombre total d'états
possibles avec les bascules utilisées, un certain nombre d'états
(physiques) ne seront pas utilisés dans le fonctionnement normal du
circuit séquentiel. On parlera alors d'\textbf{états interdits}.  Lors de la
formulation des tableaux de vérité pour le décodeur de prochain état,
ces états donneront lieu à des cas facultatifs, qui pourront permettre
la simplification du circuit combinatoire du décodeur.

Il faut toutefois se méfier de scénarios dans lesquels l'automate fini
pourrait se retrouver dans un tel état interdit en raison d'un
dysfonctionnement momentané ou lors de la mise en marche du
système. Considérons par exemple un circuit séquentiel dont le
diagramme d'état (tel qu'implémenté après conception) est illustré
ci-dessous (figure \ref{fig:orgec718f6}). En fonctionnement normal, le
système évolue entre les états \emph{a}, \emph{b} et \emph{c}. Mais si pour une
raison quelconque, le système entre dans l'état \emph{d}, il restera coincé
en bouclant sur cet état pour toujours (ou peut-être jusqu'à un
prochain dysfonctionnement).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/etat_interdit}
\caption{\label{fig:orgec718f6}Diagramme d'état avec état interdit}
\end{figure}


Une solution serait de modifier le décodeur de prochain état pour
s'assurer que, de l'état interdit, on revient toujours vers un état
normal, comme on peut le voir sur la figure suivante (figure
\ref{fig:orgecc1d63}), où de l'état \emph{d}, on reviendra toujours
vers l'état \emph{c}. 

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/etat_interdit_revient}
\caption{\label{fig:orgecc1d63}Diagramme d'état qui assure le retour en fonctionnement normal}
\end{figure}

\section{Exemple avec états \emph{one-hot}}
\label{sec:orgfe6824a}

Dans l'exemple suivant, on explore l'assignation d'états \emph{one-hot}
dans laquelle il n'y a qu'un bit 1 par code binaire.

Considérons le diagramme d'état suivant (figure \ref{fig:org16baf38}).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/exemple_one-hot}
\caption{\label{fig:org16baf38}Diagramme d'état pour assignation \emph{one-hot}}
\end{figure}

Le tableau d'assignation d'état correspondant est donné dans le
tableau \ref{tab:orgc04370c} ci-dessous.

\begin{table}[htbp]
\caption{\label{tab:orgc04370c}Assignation \emph{one-hot}}
\centering
\begin{tabular}{lr}
État & \emph{One-hot}\\[0pt]
\hline
a & 100\\[0pt]
b & 010\\[0pt]
c & 001\\[0pt]
\end{tabular}
\end{table}

Chaque état aura sa propre bascule active, dont les sorties seront
dénotées \(A\), \(B\) et \(C\). Le tableau de transition d'états qu'on
obtient comporte un grand nombre de cas facultatifs et d'états
inutilisés, que nous n'avons pas indiqués ici. Le tableau
\ref{tab:org7e5a342} ne montre que les six transitions spécifiées
dans le diagramme d'état.

\begin{table}[htbp]
\caption{\label{tab:org7e5a342}Tableau de transition d'états \emph{one-hot}}
\centering
\begin{tabular}{rrrllllrrr}
\(A^n\) & \(B^n\) & \(C^n\) & \(x\) & \(y\) & \(z\) &  & \(A^{n+1}\) & \(B^{n+1}\) & \(C^{n+1}\)\\[0pt]
\hline
0 & 0 & 1 & 0 & X & X &  & 0 & 0 & 1\\[0pt]
0 & 0 & 1 & 1 & X & X &  & 0 & 1 & 0\\[0pt]
0 & 1 & 0 & X & 0 & 0 &  & 0 & 1 & 0\\[0pt]
0 & 1 & 0 & X & 0 & 1 &  & 0 & 0 & 1\\[0pt]
0 & 1 & 0 & X & 1 & X &  & 1 & 0 & 0\\[0pt]
1 & 0 & 0 & X & X & X &  & 0 & 0 & 1\\[0pt]
\end{tabular}
\end{table}

Il est possible de formuler le décodeur de prochain état directement,
par inspection des transitions spécifiées.  Si on considère les
transitions qui entrent dans l'état \emph{a}, il y a trois façons différentes
d'arriver en \emph{a}:
\begin{itemize}
\item à partir de \emph{a}, sous la condition \(x=0\)
\item à partir de \emph{b}, sous la condition \(y=0, z=1\)
\item à partir de \emph{c}, sans conditions
\end{itemize}

L'équation de prochain état pour \emph{a} sera ainsi 
$$
A^{n+1} = A^{n}x^\prime + B^n y^\prime z + C^n
$$

Le même raisonnement nous permet d'écrire pour les autres bascules:
$$
B^{n+1} = A^{n}x + B^n y^\prime z^\prime
$$
et 
$$
C^{n+1} = B^n y
$$

Le décodeur de prochain état est simplifié, car les bits d'état
offrent une indication directe de l'état dans lequel la machine se
trouve. Le fonctionnement de la machine entraîne peu de transitions,
ce qui se traduit par une consommation d'énergie réduite et moins de
risque d'aléas (\emph{glitches}). La vitesse de commutation ne dépend pas du
nombre d'états. Il est possible d'ajouter ou retrancher un état sans avoir
à refaire entièrement la conception.  L'assignation \emph{one-hot} est
particulièrement intéressante lorsqu'il y a moins de contraintes sur
le nombre de bascules que sur le nombre d'éléments combinatoires.

Le principal inconvénient de cette approche est la croissance du
nombre de bascules, qui est linéaire avec le nombre d'états plutôt que
logarithmique. Par exemple, pour 30 états, il faudra 30 bascules alors
qu'avec un encodage binaire, il n'en faudrait que cinq. Il faut aussi
considérer qu'il y a un grand nombre d'états interdits et prendre les
précautions qui s'imposent pour éviter les problèmes de fonctionnement
coincé.

\chapter{Circuit séquentiels: registres et compteurs}
\label{sec:orgef87aa8}
\section{Objectifs}
\label{sec:org0590ed9}
\begin{itemize}
\item Se familiariser avec les principaux circuits séquentiels classiques:
registres, registres à décalage, compteurs
\item Savoir comment sont implémentées les différentes opérations:
chargement, remise à zéro, comptage vers le haut/bas, décalage
\item Utiliser des compteurs pour générer des séquences de
synchronisation
\item Faire la distinction entre compteur synchrone et compteur asynchrone
\end{itemize}

\section{Registres}
\label{sec:org009b5e9}

Un registre est un groupe de bascules activées par un même signal
d'horloge. Chaque bascule permet de stocker un bit en
mémoire. Différentes configurations d'interconnexion entre les
bascules et éventuellement des composants combinatoires permettent de
concevoir des types de registres pouvant remplir des rôles variés.

La figure \ref{fig:org9c2bcf5} montre un registre parallèle de quatre bits,
qui permet de stocker quatre valeurs binaires indépendantes. Le schéma
du bas est une représentation symbolique du registre, dans laquelle on
représente les entrées et sorties comme des vecteurs de quatre bits.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/regist_4}
\caption{\label{fig:org9c2bcf5}Registre parallèle à quatre bits}
\end{figure}

\begin{enumerate}
\item Chargement parallèle
\label{sec:org47192f0}

Si on veut concevoir un registre parallèle polyvalent, on doit le
munir de la possibilité de le charger à partir des entrées ou de
maintenir les valeurs déjà mémorisées. On ajoutera donc une entrée
\emph{charge} au registre pour contrôler ces opérations.

Pour mettre en oeuvre ce chargement/maintien, il faut un peu de
réflexion. Il serait possible d'agir (à la façon d'un signal \emph{enable}
via une porte ET, par exemple) sur l'entrée d'horloge des bascules pour
empêcher leur contenu d'être affecté par les entrées. Mais alors, on
briserait le principe de synchronisation qui veut que tous les
éléments d'un système soient commandés en même temps par une même
horloge.

La solution consiste à toujours mettre à jour le contenu des bascules: 

\begin{enumerate}
\item Lorsque \emph{charge} est inactif (fonction maintien), la sortie de
chaque bascule, réacheminée à l'entrée, est sélectionnée pour
récrire le même contenu.
\item Lorsque \emph{charge} est actif (fonction chargement), c'est l'entrée
externe qui est sélectionnée pour écrire un nouveau contenu.
\end{enumerate}

La sélection se fait au moyen d'un multiplexeur deux-vers-un à
l'entrée de chaque bascule. La figure \ref{fig:org3288bc5} montre le schéma
du registre chargeable.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/reg_4_paral}
\caption{\label{fig:org3288bc5}Registre parallèle à quatre bits chargeable}
\end{figure}

\item Registres à décalage
\label{sec:org8141ece}

Un registre à décalage consiste en une chaîne de bascules, la sortie
de l'une reliée à l'entrée de la suivante. La figure \ref{fig:orgbdcf34e} montre
un registre à décalage de quatre bits. À chaque coup d'horloge,
l'entrée est insérée dans la première bascule, à droite, et le contenu
du registre est décalé d'une position vers la gauche. La sortie
provient de la dernière bascule à droite.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/shift4}
\caption{\label{fig:orgbdcf34e}Registre à décalage 4 bits}
\end{figure}

En utilisant un multiplexeur quatre-vers-un pour sélectionner ce qui
sera inséré dans une bascule, il est possible de concevoir un registre
à décalage universel. Les différentes opérations sont le \emph{maintien}, le
\emph{décalage à droite} avec entrée \(G\), le \emph{décalage à gauche} avec entrée
\(D\) et le \emph{chargement parallèle}, avec les entrées \(I_i, i=1, \ldots,
4\).

Les différentes opérations sont commandées par les deux signaux de
sélection, comme indiqué dans le tableau \ref{tab:orga142de5}.

\begin{table}[htbp]
\caption{\label{tab:orga142de5}Codes de sélection et opérations}
\centering
\begin{tabular}{rl}
Sél. & Action\\[0pt]
\hline
00 & Maintien\\[0pt]
01 & Décalage à droite\\[0pt]
10 & Décalage à gauche\\[0pt]
11 & Chargement parallèle\\[0pt]
\end{tabular}
\end{table}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/shift4_univ}
\caption{\label{fig:org7d13a4a}Registre à décalage universel}
\end{figure} 

Les registres à décalage sont notamment utilisés pour convertir des
données parallèles en données sérielles et \emph{vice versa}, des opérations
très utiles dans le contexte d'interfaces de communication. On peut
également s'en servir pour faire des multiplications ou divisions par
deux, comme on l'a vu à la section \ref{sec:orgbbd1727}.
\end{enumerate}

\section{Compteurs}
\label{sec:org69c9b00}

Un registre dont la séquence d'états est systématique est appelé un
\textbf{compteur}. Le comptage peut être contrôlé par une entrée spécifique
ou par l'entrée d'horloge. La séquence d'états est toujours la même
pour un type de compteur donné. Par exemple, les états d'un compteur
binaire à deux bits suivent la séquence \(00 \rightarrow 01
\rightarrow 10 \rightarrow 11 \rightarrow 00 \ldots\) La sortie
correspond directement aux bits d'état. On distingue les compteurs
\textbf{asynchrones} et les compteurs \textbf{synchrones}. Quel que soit le type de
compteur, il y a toujours un retour vers l'état initial, car la
séquence d'états est un cycle.

\begin{enumerate}
\item Compteur asynchrone
\label{sec:org9ffbd70}

Dans un compteur binaire asynchrone, la sortie d'une bascule de poids
moins significatif est acheminée à l'entrée d'horloge de la bascule
suivante. C'est la transition de la sortie de la bascule de poids
moins significatif qui déclenche la bascule suivante. La figure
\ref{fig:org87544dd} montre un compteur asynchrone construit à partir de
bascules T. La séquence de sortie est donnée dans le tableau
\ref{tab:org27a3d96}. On peut voir qu'après huit étapes, la séquence se
répète.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/rippleT3}
\caption{\label{fig:org87544dd}Compteur asynchrone}
\end{figure}

\begin{table}[htbp]
\caption{\label{tab:org27a3d96}Séquence du compteur}
\centering
\begin{tabular}{rrr}
\(A_2\) & \(A_1\) & \(A_0\)\\[0pt]
\hline
0 & 0 & 0\\[0pt]
0 & 0 & 1\\[0pt]
0 & 1 & 0\\[0pt]
0 & 1 & 1\\[0pt]
1 & 0 & 0\\[0pt]
1 & 0 & 1\\[0pt]
1 & 1 & 0\\[0pt]
1 & 1 & 1\\[0pt]
0 & 0 & 0\\[0pt]
\end{tabular}
\end{table}

Les compteurs asynchrones sont très simples, mais l'inconvénient est
que les transitions d'état ne sont pas synchrones. En particulier,
les bits d'état ne changent pas tous en même temps. Par exemple, si le
compteur passe de 0111 à 1000, la sortie peut passer par des états
intermédiaires parasites: 0111 \(\rightarrow\) 0110 \(\rightarrow\) 1100
\(\rightarrow\) 1000.

\item Compteur synchrone
\label{sec:org7d9b12c}

Dans un compteur synchrone, toutes les bascules sont commandées par un
même signal d'horloge et les changements d'état sont
synchronisés. Les changements d'état sont contrôlés par les signaux
d'entrée appliqués aux bascules, comme dans le fonctionnement normal
d'un circuit séquentiel synchrone.

Le diagramme d'état d'un compteur trois bits (huit états) est un
cycle, comme on peut le voir sur la figure \ref{fig:org1a51210}. Le tableau
d'états correspondant est donné dans le tableau \ref{tab:orgf72be71}.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.65]{Sources_images_logiques/images/compt8_FSM}
\caption{\label{fig:org1a51210}Diagramme d'état d'un compteur}
\end{figure}

\begin{table}[htbp]
\caption{\label{tab:orgf72be71}Tableau d'état du compteur}
\centering
\begin{tabular}{rrrlrrr}
\(Z_2^n\) & \(Z_1^n\) & \(Z_0^n\) &  & \(Z_2^{n+1}\) & \(Z_1^{n+1}\) & \(Z_0^{n+1}\)\\[0pt]
\hline
0 & 0 & 0 &  & 0 & 0 & 1\\[0pt]
0 & 0 & 1 &  & 0 & 1 & 0\\[0pt]
0 & 1 & 0 &  & 0 & 1 & 1\\[0pt]
0 & 1 & 1 &  & 1 & 0 & 0\\[0pt]
1 & 0 & 0 &  & 1 & 0 & 1\\[0pt]
1 & 0 & 1 &  & 1 & 1 & 0\\[0pt]
1 & 1 & 0 &  & 1 & 1 & 1\\[0pt]
1 & 1 & 1 &  & 0 & 0 & 0\\[0pt]
\end{tabular}
\end{table}

Les expressions pour le décodeur de prochain état sont: 

$$  Z_2^{n+1} = Z_0^n \cdot Z_1^n \cdot (Z_2^{n})^\prime + (Z_0^{n})^\prime \cdot Z_2^n + (Z_1^{n})^\prime \cdot Z_2^n $$

$$  Z_1^{n+1} = Z_0^{n} \cdot (Z_1^{n})^\prime + (Z_0^{n})^\prime \cdot Z_1^n $$

$$  Z_0^{n+1} = (Z_0^{n})^\prime $$


Le schéma correspondant est donné à la figure \ref{fig:org80fffa0}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/compt8}
\caption{\label{fig:org80fffa0}Schéma logique du compteur à 3 bits}
\end{figure}

On peut ajouter aux compteurs des fonctions diverses: comptage vers le
haut, comptage vers le bas, préchargement parallèle, remise à zéro,
etc.

Le compteur de la figure \ref{fig:org80fffa0} a été conçu comme un circuit
séquentiel général, avec un décodeur de prochain état en forme \emph{somme
de produits}. Il est également possible de concevoir un compteur
synchrone directement, sans passer par la méthodologie classique, en
suivant un raisonnement tout simple. La bascule du bit le moins
significatif \(Z_0\) doit changer d'état à tous les coups
d'horloge. La bascule du bit suivant \(Z_1\) doit changer d'état
seulement lorsque le bit précédent \(Z_0\) vaut 1. La bascule du bit
suivant \(Z_2\) doit changer d'état seulement lorsque les bits
précédents \(Z_1, Z_0\) valent tous deux 1. Et on peut pousser le
raisonnement pour un compteur quelconque: 
\begin{quote}
la bascule d'un bit \(Z_i\)
doit changer d'état seulement lorsque les bits précédents
\(Z_{i-1},Z_{i-2},\ldots, Z_0\) valent tous 1.
\end{quote}

Le compteur à quatre bits de la figure \ref{fig:org1c167ed} a été conçu
selon cette approche, à partir de bascules JK.  L'utilisation d'une
porte ET par bascule permet de mettre en oeuvre les
conditions. L'entrée \(E\) est un contrôle \emph{enable} pour activer le
comptage. On a aussi prévu une sortie \texttt{Prochain} pour pouvoir
connecter en cascade d'autres compteurs.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/compt_4bits}
\caption{\label{fig:org1c167ed}Schéma logique du compteur à 4 bits}
\end{figure}

Si on réfléchit de la même façon pour le comptage vers le bas, on constate
que la règle devient:

\begin{quote}
la bascule d'un bit \(Z_i\) doit changer d'état
seulement lorsque les bits précédents \(Z_{i-1},Z_{i-2},\ldots, Z_0\)
valent tous 0.
\end{quote}
Cette fois-ci, les conditions se baseront sur les sorties
complémentées des bascules précédentes.

\item Compteur bidirectionnel
\label{sec:org8597f59}

En combinant les deux conditions au moyen d'un multiplexeur
deux-vers-un, il est facile de concevoir un compteur haut/bas, comme
illustré sur la figure \ref{fig:orga76e801}.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/compt_updown}
\caption{\label{fig:orga76e801}Schéma logique du compteur haut/bas à 4 bits}
\end{figure}

\item Compteur en anneau
\label{sec:org8bbb607}

Un compteur en anneau est un registre à décalage connecté en boucle où
une seule bascule est active à la fois. Il y a donc dans la sortie un
seul bit 1, qui se décale de façon cyclique: \(0010 \rightarrow 0001
\rightarrow 1000 \rightarrow 0100 \rightarrow 0010, \ldots\) La
figure \ref{fig:orgd1b86f9} illustre un compteur en anneau de quatre bits. Une
entrée \texttt{Init} permet d'injecter un bit 1 dans le registre au début. La
trace montre les formes d'onde obtenues.

On utilise fréquemment ce type de compteur pour générer des signaux de
synchronisation. En effet, chaque sortie devient active à son tour
dans le cycle, pendant une période d'horloge.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/ring4}
\caption{\label{fig:orgd1b86f9}Compteur en anneau à 4 bits}
\end{figure}

\item Compteur Johnson
\label{sec:orgfafefc2}

Un compteur Johnson permet de doubler le nombre d'états distincts par
rapport au compteur en anneau en injectant le complément du dernier
bit dans l'entrée du registre à décalage.  La figure \ref{fig:orge499074}
illustre un compteur en anneau Johnson de quatre bits, de même que la
trace de fonctionnement. La séquence d'états est donnée dans le
tableau \ref{tab:orgc7363d4}.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/johnson4}
\caption{\label{fig:orge499074}Compteur Johnson à 4 bits}
\end{figure}


\begin{table}[htbp]
\caption{\label{tab:orgc7363d4}Séquence d'états du compteur Johnson}
\centering
\begin{tabular}{rrrrrl}
No & \(a\) & \(b\) & \(c\) & \(d\) & ET requis\\[0pt]
\hline
1 & 0 & 0 & 0 & 0 & \(a^\prime d^\prime\)\\[0pt]
2 & 1 & 0 & 0 & 0 & \(a b^\prime\)\\[0pt]
3 & 1 & 1 & 0 & 0 & \(b c^\prime\)\\[0pt]
4 & 1 & 1 & 1 & 0 & \(c^\prime d^\prime\)\\[0pt]
5 & 1 & 1 & 1 & 1 & \(a d^\prime\)\\[0pt]
6 & 0 & 1 & 1 & 1 & \(a^\prime b\)\\[0pt]
7 & 0 & 0 & 1 & 1 & \(b^\prime c\)\\[0pt]
8 & 0 & 0 & 0 & 1 & \(c^\prime d\)\\[0pt]
\end{tabular}
\end{table}


On peut construire des signaux de synchronisation distincts en
combinant deux par deux au moyen d'une porte ET des signaux de sortie
voisins (dans le cycle) ou leurs compléments. Le tableau \ref{tab:orgc7363d4}
donne les paires de sorties à combiner pour ce faire avec le compteur
Johnson de quatre bits.

Nous avons appliqué ce principe à un compteur Johnson de deux bits,
présenté sur la figure \ref{fig:org30793a3}. La figure montre une trace
d'exécution avec les signaux de sortie. On y voit que chacun des
quatre signaux est activé à son tour.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/johnson2_quad_decode}
\caption{\label{fig:org30793a3}Compteur Johnson à 2 bits et circuit de décodage pour signaux de synchronisation}
\end{figure}

Si on s'intéresse aux sorties des bascules de ce même compteur
Johnson, on peut voir sur la trace d'exécution de la figure
\ref{fig:orgd35fa0a} qu'on obtient des signaux en \textbf{quadrature},
c'est-à-dire que les sorties sont déphasées de 90 degrés les unes par
rapport aux autres, comme le sont des fonctions \(\sin(), \cos(),
-\sin(), -\cos()\).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/johnson2_quad}
\caption{\label{fig:orgd35fa0a}Signaux en quadrature obtenus au moyen d'un compteur Johnson à 2 bits}
\end{figure} 

\item Diviseur de fréquence
\label{sec:org250fa46}

Un compteur peut être utilisé pour diviser la fréquence d'un signal
périodique. Par exemple, la sortie d'un compteur à un bit change
d'état à tous les deux coups d'horloge, ce qui constitue une division
par deux de la fréquence d'horloge. Cette approche permet
naturellement des divisions par des puissances de deux.

On peut aussi utiliser un compteur Johnson, qui permettra alors, selon
le nombre d'étages du compteur, des divisions de fréquence par des
diviseurs, comme trois ou cinq, qui ne sont pas des puissances de deux.

\item Compteur à chargement parallèle
\label{sec:org82af226}

Un compteur à chargement parallèle est illustré à la figure
\ref{fig:org4873c36}. En activant l'entrée \texttt{Compte}, le comptage
se fait vers le haut. En activant l'entrée \texttt{Charge}, les entrées \(I_i, i=0, \ldots, 3\) sont insérées dans les bascules. Il y a aussi une
sortie \texttt{ov} qui indique lorsque le compteur atteint sa valeur
maximale. Cette sortie peut être utilisée pour activer un autre
compteur pour des bits de plus haut niveau.

La trace d'exécution de la figure \ref{fig:orga550827}
montre le comptage de 4 jusqu'à 15 et retour à 0. On voit le signal
\texttt{ov} s'activer sur 15. 

\begin{figure}[htbp]
\centering
\includesvg[scale=0.65]{Sources_images_logiques/images/comptchargement}
\caption{\label{fig:org4873c36}Compteur à chargement parallèle}
\end{figure}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/compt_chargement_tracecompte}
\caption{\label{fig:orga550827}Trace d'exécution, de 0 à 15}
\end{figure}

La trace de la figure suivante montre le compteur qui
passe de 0 à 5, puis un chargement parallèle de la valeur 12.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/compt_chargement_trace_charge}
\caption{\label{fig:org1acfceb}Trace d'exécution, de 0 à 5 et chargement de 12}
\end{figure}

\item Compteur modulo
\label{sec:org8210fd0}

On peut réaliser aisément un compteur modulo dont le cycle est plus
court que le maximum possible, en utilisant un compteur avec
chargement parallèle.  Par exemple, pour réaliser un compteur qui
compte de 0 jusqu'à 12, il suffit de décoder au moyen d'une porte ET
l'état qui doit être le dernier du cycle, et d'utiliser le signal de
sortie obtenu pour charger la valeur 0 dans le compteur. On obtient
ainsi un compteur modulo-13, dont le cycle compte 13 états.  La figure
illustre le compteur modulo-13, de même qu'une trace d'exécution sur
laquelle on voit le passage de 12 à 0.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/compt_mod13}
\caption{\label{fig:orge96b7aa}Compteur modulo-13}
\end{figure}

On pourrait aussi réaliser un compteur qui compte par exemple de 4 à
15, en utilisant cette fois la sortie \texttt{ov} pour activer le chargement
d'une valeur initiale 4.
\end{enumerate}

\chapter{Mémoires}
\label{sec:org9bddc0f}
\section{Objectifs}
\label{sec:org364c238}
\begin{itemize}
\item Faire la distinction entre mémoire volatile et non-volatile
\item Faire la distinction entre mémoire volatile statique et dynamique
\item Connaître l'organisation typique d'une mémoire et le fonctionnement
de l'adressage
\item Comprendre le fonctionnement d'un bus de données
\item Interpréter les cycles d'écriture et de lecture
\item Implémenter une fonction combinatoire arbitraire à l'aide d'une
mémoire ROM
\item Utiliser un tableau de correspondance
\item Se familiariser avec les différents types de mémoires non-volatiles
\end{itemize}

\section{Mémoires}
\label{sec:org351f581}

Une mémoire est utilisée pour stocker des valeurs binaires à plus ou
moins long terme. Généralement, l'information stockée dans la mémoire
sera lue et acheminée dans des registres pour être traitée par un
circuit logique de traitement. Les résultats du traitement seront
typiquement stockés de nouveau dans la mémoire. Constituée d'un grand
nombre de cellules permettant chacune de stocker un bit, la mémoire
est dotée de mécanismes permettant d'accéder aux cellules pour en
faire la lecture ou l'écriture.

On distingue les mémoires non volatiles (en anglais, \emph{Read Only
Memories} (ROM)) et les mémoires volatiles (en anglais, \emph{Random Access
Memories} (RAM)).

\begin{enumerate}
\item Mémoires non-volatiles
\label{sec:org83855ab}

Dans une mémoire ROM, les données sont stockées une fois pour
toutes. Elles y demeurent même après que la mémoire ait été mise hors
tension. Dans le cycle de vie des données, il y a donc \textbf{une} écriture
initiale, mais autant de lectures qu'on le souhaite. Il ne peut pas y
avoir de réécriture.

Une mémoire ROM est considérée comme un dispositif \textbf{programmable},
dans le sens où le processus d'écriture initial demande une action
particulière, une procédure spécifique sur le plan matériel. Nous verrons
au chapitre \ref{sec:org9a463b0} d'autres dispositifs logiques
programmables. La programmation d'une ROM se fait en agissant sur des
connexions dites \textbf{fusibles}. Initialement, le fusible est comme un fil
qui permet au signal de passer. En le programmant, le fusible devient
un circuit ouvert qui ne laisse plus passer le signal.

\item Mémoires volatiles
\label{sec:orge173dfc}

Une mémoire RAM stocke l'information de façon temporaire. En principe,
le contenu est conservé tant que la mémoire est maintenue sous
tension. Mais la réalité est un peu plus complexe, comme nous le verrons
plus loin.

L'opération d'\textbf{écriture} permet de stocker des valeurs et la
\textbf{lecture} permet d'extraire l'information de la mémoire.

Une mémoire RAM \textbf{statique} consiste en un ensemble de loquets qui
permettent de conserver des données binaires. L'information est
maintenue tant que la mémoire est alimentée. 

Les mémoires RAM \textbf{dynamiques} stockent l'information sous la forme
d'une charge capacitive au sein des transistors du circuit
intégré. Comme cette charge se disperse au fil du temps, la mémoire
doit être rafraîchie régulièrement, en y récrivant périodiquement à
très court intervalle (millisecondes) la même valeur qui est déjà
stockée.

Les mémoires dynamiques consomment beaucoup moins que les mémoires
statiques et offrent des capacités de stockage largement supérieures,
car une cellule de mémoire comporte beaucoup moins d'éléments
(essentiellement un transistor par cellule). En contrepartie, les
temps d'accès aux mémoires statiques sont nettement meilleurs et on
n'a pas à se préoccuper de rafraîchissement.
\end{enumerate}

\section{Adressage}
\label{sec:org0db86b5}

Les cellules des mémoires sont organisées en petits groupes appelés
\textbf{mots}, de façon à ce que l'on puisse accéder à chaque groupe
indépendamment. Toutes les cellules d'un mot sont lues ou écrites
ensemble.

Cet accès individuel aux mots, appelé \textbf{adressage}, est une
caractéristique de flexibilité essentielle. Le temps d'accès aux
données est le même, quel que soit l'endroit dans la mémoire où un mot
en particulier est stocké. Les mots sont généralement constitués d'un
nombre de bits multiple de huit: 8, 16 ou 32 bits sont des tailles de
mot courantes. Un groupe de huit bits est appelé \textbf{octet}.

L'adressage se fait au moyen d'un \textbf{décodeur d'adresses}, qui est
simplement un décodeur binaire tel que nous l'avons vu à la section
\ref{sec:orgc4764d9}. Le nombre de bits d'adresse détermine la capacité (en nombre
de mots) de la mémoire: pour \(k\) adresses, on aura \(2^k\) mots
distincts. Les tailles de mémoire sont souvent exprimées au moyen de
multiplicateurs: K (kilo) correspondant à \(2^{10}\), M (méga)
correspondant à \(2^{20}\) ou G (giga) correspondant à \(2^{30}\).


\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{Sources_images_logiques/images/memoire.png}
\caption{\label{fig:org6218de9}Schéma d'une mémoire}
\end{figure}

\begin{enumerate}
\item Lecture et écriture
\label{sec:org5f9123c}

L'opération choisie, écriture ou lecture, est commandée par une ou des
entrées à cet effet. L'accès à un espace mémoire (un mot) se fait
selon une séquence bien précise. Pour une écriture:

\begin{enumerate}
\item Les bits d'adresse du mot sont appliqués aux lignes d'adresse.
\item Les données à écrire sont appliquées aux lignes d'entrée.
\item On active l'entrée de commande \texttt{Écriture}.
\end{enumerate}

Les données de l'entrée sont alors stockées dans la case mémoire adressée.

Pour une lecture:

\begin{enumerate}
\item Les bits d'adresse du mot sont appliqués aux lignes d'adresse.
\item On active l'entrée de commande \texttt{Lecture}.
\end{enumerate}

Les données présentes dans la case mémoire adressée sont ensuite
disponibles à la sortie de la mémoire.

Les mémoires offertes sur le marché optent souvent pour une
combinaison des signaux de contrôle, avec un seul signal qui détermine
le sens de l'action, comme le montre le tableau
\ref{tab:org630f466}. Le signal \texttt{Enable}, parfois appelé \texttt{Chip
select}, permet d'activer une mémoire dans un ensemble où plusieurs
mémoires sont utilisées.

\begin{table}[htbp]
\caption{\label{tab:org630f466}Signaux de contrôle d'une mémoire}
\centering
\begin{tabular}{rrl}
\texttt{Enable} & \texttt{Lecture/écriture} & Action\\[0pt]
\hline
0 & X & Aucune\\[0pt]
1 & 0 & Écriture\\[0pt]
1 & 1 & Lecture\\[0pt]
\end{tabular}
\end{table}

\item Bus de données
\label{sec:org4e8b27b}

Pour acheminer les données lues ou à écrire dans la mémoire, on
utilise des tampons émetteurs-récepteurs de bus (voir section \ref{sec:org1fde717}), organisés en vecteur, pour créer un
\textbf{bus de données} qui permet un aller-retour des données, selon le sens
de l'action. Cela permet de diminuer de moitié le nombre de connexions
nécessaires pour l'échange des données.  Un signal dérivé des signaux
\texttt{Lecture/écriture} et \texttt{Chip select (CS)} est typiquement utilisé pour
commander l'entrée de contrôle (voir figure \ref{fig:org97eb0ad}).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/bus_trans8}
\caption{\label{fig:org97eb0ad}Bus de données, 8 bits}
\end{figure}

\item Chronogrammes
\label{sec:org490832e}

La figure \ref{fig:orgfe0f271} présente un chronogramme qui décrit
l'opération d'écriture dans une mémoire RAM. Les valeurs d'adresse
sont d'abord présentées aux entrées d'adressage.  Le signal \texttt{L/not E}
est amené au niveau bas, en même temps que le signal \texttt{CS} est activé
(au niveau bas). Après un court délai, les données sont mises sur le
bus de données et seront écrites dans la mémoire. On peut voir que les
lignes du bus de données sont en mode \textbf{haute impédance} lorsque le bus
est inactif (situation représentée symboliquement sur l'illustration
par un signal situé entre les niveaux 0 et 1).

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/chron_ram_ecriture}
\caption{\label{fig:orgfe0f271}Mémoire RAM, chronogramme pour l'écriture}
\end{figure}

La figure \ref{fig:org8e2c464} présente un chronogramme qui décrit
l'opération de lecture d'une mémoire RAM. Les valeurs d'adresses sont
d'abord présentée aux entrées d'adressage.  Le signal \texttt{L/not E} est
maintenu au niveau élevé en même temps que le signal \texttt{CS} est activé
(au niveau bas). Après un court délai, les données sont disponibles sur
le bus de données.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/chron_ram_lecture}
\caption{\label{fig:org8e2c464}Mémoire RAM, chronogramme pour la lecture}
\end{figure}

La cellule de base d'une mémoire RAM qui permet de stocker un bit est
illustrée à la figure \ref{fig:org6d480e0}. Elle est construite autour d'un
loquet SR et de portes logiques pour le contrôle. Une mémoire complète
de \(m\) mots de taille \(n\) bits sera constituée d'une matrice de
format \(m \times n\) de telles cellules, avec un décodeur d'adresse
pour sélectionner quel mot sera affecté par l'opération choisie.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/cell_ram}
\caption{\label{fig:org6d480e0}Cellule mémoire RAM}
\end{figure}
\end{enumerate}


\section{Mémoires mortes}
\label{sec:org12b1287}

Dans son mode d'utilisation normal, une mémoire morte peut seulement
être lue. Il n'est donc pas nécessaire de préciser l'opération qui
sera effectuée. Il y aura donc des entrées pour les adresses et un
signal de contrôle de type \texttt{CS}.

La figure \ref{fig:orge351c9a} montre l'essentiel d'une mémoire ROM de
16 mots de 4 bits. Un décodeur d'adresse permet de sélectionner quel
mot sera lu, et la sortie est disponible sur les lignes \(A_3, \ldots,
A_0\). 

Pour simplifier la représentation de ce genre de configuration, on
utilise une schématisation symbolique compacte pour les portes OU de
sortie, dans laquelle chacune des 16 lignes horizontales représente en
fait 16 entrées d'une porte OU. La présence d'une croix à
l'intersection d'une ligne horizontale et d'une ligne verticale
signifie que le signal de la ligne horizontale est connecté à une des
entrées de la porte.  Avec cette schématisation, on peut voir que les
deux premiers mots stockés dans la mémoire illustrée dans l'exemple
seraient 0101 et 1101. La même schématisation compacte s'emploie aussi
pour des portes ET.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/proto_rom1_prog}
\caption{\label{fig:orge351c9a}Modèle d'une mémoire ROM}
\end{figure}

Cette mémoire relativement petite comporte ainsi 64 intersections
programmables, permettant de définir la valeur des 16 mots de mémoire
de 8 bits chacun.

\begin{enumerate}
\item Implémentation de fonctions combinatoires
\label{sec:org61b0bd2}

Comme on l'a vu dans la section \ref{sec:orgc4764d9}, un décodeur permet de
générer les \(2^k\) minterms possibles avec ses \(k\)
entrées. Regrouper avec une porte OU les minterms d'une
fonction permet d'implémenter cette fonction. Une mémoire ROM permet
de faire exactement cela sans avoir rien à ajouter, car elle est munie
d'un décodeur d'entrée et la porte OU de sortie fait déjà partie de
la ROM. On peut donc interpréter le fonctionnement d'une mémoire ROM
de \(k\) bits d'adresse et avec des mots de taille \(m\) comme un
dispositif qui permet, pour les entrées qui sont ses adresses, de
mettre en oeuvre \(m\) fonctions combinatoires différentes (une par
bit de mot) de \(k\) entrées.

Par exemple, la sortie \(A_2\) de la mémoire de la figure
\ref{fig:orge351c9a} implémente la fonction $$ A_2 = \sum (0,1,4,8) $$
exprimée en somme de minterms.

\item Tableau de correspondance
\label{sec:org6bb92cb}

Cette approche qui consiste à réaliser une fonction logique
combinatoire au moyen d'une mémoire qui spécifie, pour chaque
combinaison d'entrée possible, une valeur de sortie, est largement
utilisée dans les composants programmables. On parle alors de tableau
de correspondance (en anglais, \emph{LookUp Table} (LUT)). Il s'agit ni
plus ni moins que de stocker en mémoire le tableau de vérité de la
fonction à réaliser. Dans les composants programmables, on utilise
plutôt des mémoires RAM pour les tableaux de correspondance, afin que
la configuration des fonctions puisse être changée selon
l'application.

\item Catégories de mémoires ROM
\label{sec:org15f0d02}

On distingue quatre grandes approches technologiques pour réaliser des
mémoires mortes. Leurs usages typiques sont surtout déterminés par la
façon de les configurer (on dit couramment \emph{programmer}, même s'il
s'agit d'une intervention sur le plan matériel).

Dans la \textbf{programmation par masque}, la mémoire est programmée lors de
la fabrication de la puce. Le fabricant se base sur un tableau de
vérité fourni par le client pour établir des connexions qui seront
implémentées (ou pas) dans le procédé de fabrication via des masques
qui empêchent le dépôt de matériau conducteur sur les couches du
circuit intégré.  Cette approche convient à la production de masse à
grand volume.

Dans la \textbf{programmation sur mesure}, on utilise un type de mémoire qui
comporte initialement des connexions entre toutes les sorties du
décodeur et toutes les entrées des portes OU de sortie (la mémoire en
configuration initiale comporte des 1 partout). La programmation, qui
peut se faire chez le développeur au moyen d'un dispositif de
programmation (ou programmeur) spécialement conçu à cette fin,
consiste à supprimer les connexions qui ne sont pas nécessaires en
envoyant des impulsions à forte tension pour faire fondre les fusibles
de connexions spécifiques. Un fusible fondu (pas de connexion)
correspond à un bit 0 dans la mémoire. Cette programmation est bien
entendu irréversible: impossible de rétablir la connexion une fois que
le fusible est fondu.

Avec une \textbf{PROM} (pour \emph{Programmable ROM}), il est possible d'effacer la
configuration dans son ensemble en soumettant la puce à une lumière
ultraviolette pendant un certain temps. Ce bombardement énergétique
permet de décharger les grilles flottantes des dispositifs qui
implémentent les connexions. La mémoire PROM peut être configurée de
nouveau.

Avec la \textbf{programmation électrique}, il est possible de reconfigurer
l'ensemble d'une mémoire dite EEPROM (\emph{Electrically Erasable PROM})
en la soumettant à un signal électrique d'effacement. 

Les ROM à \textbf{programmation \emph{flash}} sont semblables aux EEPROM, mais la
reconfiguration peut se faire adresse par adresse.  Il est notamment
possible de reconfigurer une mémoire sans la retirer de son circuit.
Fonctionnellement, ces mémoires sont à mi-chemin entre la mémoire RAM
et la mémoire sur disque. Les mémoires \emph{flash} tendent d'ailleurs de
plus en plus à remplacer ce dernier type dans les systèmes portables:
téléphones, ordinateurs portables, etc.
\end{enumerate}

\chapter{Logique programmable}
\label{sec:org9a463b0}
\section{Objectifs}
\label{sec:org5a3875d}
\begin{itemize}
\item Se familiariser avec les différents types de composants logiques
programmables
\item Reconnaître les avantages et limitations des différents types
\item Comprendre le fonctionnement d'une matrice logique programmable
\item Comprendre le fonctionnement d'un composant logique à matrice programmable
\item Comprendre le fonctionnement d'un circuit séquentiel programmable
\item Se familiariser avec le concept de bloc logique programmable
\item Comprendre l'organisation d'une cellule logique programmable et
apprécier sa flexibilité
\end{itemize}

\section{Dispositifs programmables}
\label{sec:org59f1229}

Nous avons vu qu'une mémoire ROM est un dispositif logique
programmable qui, grâce à la matrice d'interconnexion entre son
décodeur (qui génère tous les minterms) et les portes OU de sortie,
permet de réaliser des fonctions logiques arbitraires. D'autres
composants utilisent à divers degrés cette approche pour offrir des
possibilités de configuration flexibles.

Il existe une grande variété de dispositifs programmables, des plus
simples aux plus complexes. De nombreux manufacturiers offrent des
variantes plus ou moins équivalentes dans chacune des gammes de
produits. Nous allons nous limiter à présenter brièvement les grandes
familles typiques, en ordre de complexité croissante.

\begin{enumerate}
\item Matrice logique programmable (PLA)
\label{sec:orgf47b821}

Une \textbf{matrice logique programmable} (en anglais, \emph{Programmable Logic
Array} (PLA)) est un dispositif spécifiquement conçu pour la
réalisation de fonctions combinatoires arbitraires. Elle fonctionne
selon une approche qui s'apparente à l'utilisation d'une mémoire morte
pour réaliser une fonction logique arbitraire.

La figure \ref{fig:org768f212} montre une matrice permettant de
réaliser deux fonctions pouvant comporter jusqu'à quatre termes
produits de trois variables. Puisque le nombre de termes produits est
limité, il n'est généralement pas possible de se baser directement sur
les minterms des fonctions pour l'implémentation. On doit donc
simplifier les fonctions avant l'implémentation. Un même terme produit
peut contribuer à plus d'une fonction.

La programmation des portes XOR de sortie permet de choisir
la fonction directe ou son complément. 

Les PLAs offertes sur le marché proposent des configurations avec de
plus grands nombres d'entrées, de termes et de sorties, typiquement
des dizaines.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/pla}
\caption{\label{fig:org768f212}Matrice logique programmable}
\end{figure}

\item Logique à matrice programmable (PAL)
\label{sec:org7c06b12}

Les dispositifs à \textbf{logique à matrice programmable} (an anglais,
\emph{Programmable Array Logic} (PAL)) sont une autre variante sur ce
thème, avec une matrice OU fixe et une matrice ET configurable. Ils
sont moins flexibles que les PLA.

La figure \ref{fig:org1c2f696} montre un dispositif de logique à matrice
programmable à quatre variables d'entrée, permettant de réaliser trois
fonctions pouvant comporter jusqu'à trois minterms. Les sorties
(directes et complémentée pour la première fonction) peuvent être
acheminées aux entrées des autres fonctions. Encore ici, le nombre de
termes produits est limité et on doit simplifier les fonctions avant
l'implémentation. Cependant, puisqu'il n'y a pas de matrice OU, il
n'est pas possible de partager un terme produit entre deux fonctions.

Les PAL offerts sur le marché proposent des configurations avec de
plus grands nombres d'entrées, de termes et de sorties, typiquement
des dizaines.


\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/pal}
\caption{\label{fig:org1c2f696}Logique à matrice programmable}
\end{figure}

\item Logique programmable séquentielle
\label{sec:org224e90b}

En combinant un \textbf{dispositif logique programmable} (en anglais,
\emph{Programmable Logic Device} (PLD)) avec un certain nombre de
bascules, il est possible de proposer un circuit programmable
séquentiel. La configuration générale est illustrée sur la
figure \ref{fig:org98cba68}.


\begin{figure}[htbp]
\centering
\includegraphics[scale=0.55]{Sources_images_logiques/images/circuit_seq_prog.png}
\caption{\label{fig:org98cba68}Modèle de circuit séquentiel programmable}
\end{figure} 

Plusieurs fabricants proposent une variété de dispositifs de ce type,
avec diverses options de configuration, d'interconnexion, etc.  On
offre par exemple des dispositifs complexes qui combinent plusieurs
cellules programmables sur un même circuit intégré, reliables au moyen
d'un réseau d'interconnexion configurable. La disposition générale de
ce genre de dispositif complexe est présentée à la figure \ref{fig:org311d3b7}.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.45]{Sources_images_logiques/images/CPLD.png}
\caption{\label{fig:org311d3b7}Modèle de circuit séquentiel programmable complexe}
\end{figure}
\end{enumerate}

\section{Circuits intégrés programmables}
\label{sec:orgfec1afb}

La version la plus sophistiquée des circuits logiques programmables
est sans contredit le \textbf{circuit intégré programmable} (en anglais, \emph{Field
Programmable gate array} (FPGA)). Un FPGA est constitué d'une matrice
de blocs polyvalents appelés \textbf{blocs logiques programmables} qui
permettent, selon leur configuration, de réaliser n'importe quelle
fonction logique. Un bloc logique est typiquement constitué d'une ou
de quelques \textbf{cellules logiques} élémentaires.

La figure \ref{fig:orge98afe4} montre une version simplifiée d'une cellule
logique comportant:
\begin{itemize}
\item un tableau de correspondance (LUT) à quatre entrées
\item un additionneur complet
\item une cellule de mémoire
\end{itemize}

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/cell_logique}
\caption{\label{fig:orge98afe4}Cellule logique}
\end{figure}

Le tableau de correspondance (LUT) à quatre entrées \(a, b, c, d\) est
fractionné en deux LUT à trois entrées, combinés par un multiplexeur
contrôlé par l'entrée \(d\). Pour des opérations arithmétiques, les
sorties des LUT à trois entrées sont additionnées avec une retenue
externe \(R_i\). Le multiplexeur du centre, commandé par le signal de
sélection \(S_1\), sélectionne le résultat d'addition ou la fonction
réalisée par la LUT à 4 entrées. Selon le signal de sélection \(S_2\),
la valeur obtenue peut être acheminée directement en sortie de la
cellule (cellule en mode combinatoire) ou être stockée dans la bascule
D (cellule en mode séquentiel). Dans d'autres configuration typiques
de cellules, l'additionneur complet est remplacé par un tableau de
correspondance.

En plus de la matrice de blocs logiques, un circuit intégré
programmable comporte également des composants consacrés aux
entrées/sorties, des lignes d'interconnexion programmables pour relier
les blocs entre eux, des lignes de distribution de signaux d'horloge,
et possiblement de la mémoire RAM supplémentaire.

Les LUTs font appel à de la mémoire RAM pour implémenter les tableaux
de vérité, ce qui permet une configuration dynamique qui doit être
chargée lors de la mise en route du circuit programmable. Un autre
avantage est que ces mémoires permettent des vitesses de
fonctionnement nettement plus rapides que si on utilisait des mémoires
ROM.  Les données de configuration peuvent être stockées dans de la
mémoire \emph{flash} externe par exemple. Le circuit FPGA peut donc être
reconfiguré et adapté à différentes fonctions, simplement en écrivant
de nouvelles données dans la mémoire externe qui contient ses
informations de configuration.

La configuration et la programmation d'un circuit programmable FPGA se
fait au moyen d'outils de synthèse spécialisés, souvent en fonction
d'une spécification au moyen d'un langage descriptif de matériel (en
anglais, \emph{Hardware Description Language} (HDL)).

\part{Langages descriptifs de matériel}
\label{sec:org1357455}
\chapter{Langages descriptifs et de modélisation}
\label{sec:org90bc1f0}

\section{Objectifs}
\label{sec:orgfd7c29f}
\begin{itemize}
\item Expliquer la différence entre un langage descriptif de matériel et
un langage de programmation
\item Expliquer les mécanismes d'assignation de signaux et la notion de concurrence
\item Faire la distinction entre une description d'entité et une architecture
\item Faire la distinction entre un modèle structural et un modèle
comportemental
\item Faire la distinction entre un signal et une variable
\item Se familiariser avec les principaux types utilisés en descriptions
de circuits
\item Préparer une description (modèle) de circuit en langage VHDL
\item Préparer un banc d'essai permettant de tester un modèle de circuit
\item Simuler un modèle VHDL au moyen d'un banc d'essai et interpréter les
résultats
\item Élaborer une description complète en VHDL pour un système simple
\end{itemize}


\section{Modélisation et simulation}
\label{sec:orge2a5f69}

Lorsque vient le temps de concevoir, simuler, tester et élaborer des
systèmes numériques complexes, les approches manuelles que nous avons
employées jusqu'ici ne suffisent plus. Il faut alors faire appel à des
familles d'outils plus puissants de conception assistée par
ordinateur. Avec ces outils, il est possible de concevoir et de
spécifier précisément le design voulu, en simuler le fonctionnement,
le valider par une batterie de tests, afin de s'assurer que le tout
correspond aux besoins de l'application avant même de solliciter une
seule porte logique physique.

Un élément clé de cette démarche est la possibilité de décrire
précisément le ou les circuits qui seront implémentés au moyen d'un
langage approprié. Un tel \textbf{langage descriptif de matériel} (en anglais
\emph{Hardware Description Language} (HDL)), qui s'apparente à un langage
de programmation, permet de décrire de façon textuelle les différents
éléments de notre circuit, leurs interconnexions et interactions.

Alors qu'un langage de programmation spécifie essentiellement des
procédures et les données qui y sont associées, un HDL est un langage
de modélisation qui décrit des structures matérielles et le
comportement de systèmes logiques. Un HDL peut spécifier des
diagrammes logiques, des expressions logiques, voire des tableaux de
vérité. Il permet aussi de décrire le comportement du système à
différents niveaux d'abstraction et les relations hiérarchiques entre
les différents sous-systèmes qui le composent.

On peut voir un modèle HDL comme la description des relations entre
les entrées et les sorties du système. Entrées et sorties sont
modélisées comme des \textbf{signaux}.

\section{Langage VHDL}
\label{sec:orgc1cab39}

Parmi les nombreux HDL en usage, quelques-uns ont été
standardisés. Les plus répandus sont \emph{Verilog} et VHDL. C'est ce
dernier langage que nous allons utiliser.  Le V dans l'acronyme VHDL
(\emph{VHSIC Hardware Description Language}) provient d'un autre acronyme,
VHSIC pour \emph{Very High Speed Integrated Circuits} (circuits intégrés à
très haute vitesse). On comprend que le langage a été créé dans
l'optique de concevoir des circuits intégrés rapides et complexes.

Un design en VHDL est un ensemble d'entités de conception. Une entité,
celle du plus haut niveau, invoque les autres entités comme
composants.  Le design dans son ensemble est structuré de façon
hiérarchique.

\section{Entité}
\label{sec:orga1e6ad9}

Une \textbf{entité} définit le nom d'un modèle et spécifie ses interfaces,
c'est-à-dire les entrées et les sorties qui permettent au modèle
d'interagir avec son environnement. Le nom, la direction et le type
de chaque signal d'interface sont déclarés dans le \textbf{port} de
l'entité. La fonction du modèle n'est aucunement précisée. Il s'agit
uniquement de décrire la «coquille» d'une boîte noire.

La déclaration d'entité spécifie le nom de l'entité et la liste des
ports d'entrée et de sortie. La forme générale est comme ci-dessous (les
éléments entre crochets sont optionnels). 

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity Nom_Entite is 
[generic generic_declarations);]

port (noms_signaux: mode type;

noms_signaux: mode type;
  .
  .
  .
noms_signaux: mode type);

end [Nom_Entite];
\end{minted}
\caption{Déclaration d'entité}
\end{listing}

La déclaration commence avec le mot réservé \texttt{entity}, suivi du nom et
du mot réservé \texttt{is}. Viennent ensuite les déclarations de ports avec le
mot réservé \texttt{port}. La déclaration se termine avec le mot réservé
\texttt{end} et optionnellement, le nom de l'entité.

\begin{itemize}
\item \texttt{Nom\_Entite} est un nom arbitraire choisi par le concepteur ou la
conceptrice.

\item \texttt{noms\_signaux} donne une liste d'un ou de plusieurs identifiants
séparés par des virgules qui définissent les signaux externes
d'interface.

\item \textbf{mode}: est un des mots réservés suivants, qui définissent la
direction des signaux:

\begin{itemize}
\item \texttt{in}: le signal est une entrée

\item \texttt{out}: le signal est une sortie de l'entité, qui peut être lue
par les autres entités qui y sont raccordées

\item \texttt{buffer}: le signal est une sortie qui peut être lue de
l'intérieur de l'architecture de l'entité

\item \texttt{inout}: le signal peut être une entrée ou une sortie
\end{itemize}

\item \texttt{type}: est un type de signal prédéfini ou défini par le concepteur
ou la conceptrice. Par exemple, \texttt{bit, bit\_vector, Boolean,
   character, std\_logic, ou std\_ulogic}.

\begin{itemize}
\item \texttt{bit}: une valeur binaire  0 ou 1

\item \texttt{bit\_vector}: un vecteur de bits

\item \texttt{std\_logic, std\_ulogic, std\_logic\_vector, std\_ulogic\_vector}: des
valeurs binaires plus nuancées (voir librairies)

\item \texttt{boolean}: deux valeurs possibles: TRUE ou FALSE

\item \texttt{integer}: des valeurs entières

\item \texttt{real}: des valeurs réelles

\item \texttt{character}: des caractères

\item \texttt{time}: des valeurs de temps
\end{itemize}

\item \textbf{generic:} les déclarations génériques sont optionnelles et
spécifient des constantes locales utilisées pour préciser par
exemple des valeurs de temps ou des tailles de vecteur. Un
générique peut avoir une valeur de défaut. La syntaxe est comme
ci-après.
\end{itemize}

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
generic (

nom_constante: type [:=valeur];

nom_constante: type [:=valeur];
.
.
.
nom_constante: type [:=valeur] );
\end{minted}
\caption{Déclarations génériques}
\end{listing}


Le listage qui suit montre un exemple simple de déclaration d'entité. 

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity ALU is
port (argl, arg2: in bit_vector;
add_or_sub: in bit;
result: out bit_vector);
end ALU;
\end{minted}
\caption{Déclaration d'entité 2}
\end{listing}

\section{Architecture}
\label{sec:orgb56cf2c}

Une \textbf{architecture} est une réalisation (ou implémentation) de
l'intérieur de la boîte noire. Jumelée à une entité, elle décrit
comment les sorties de l'entité sont obtenues à partir de ses
entrées. Il est possible d'associer de multiples architectures à une
même entité.

Une architecture peut contenir:

\begin{itemize}
\item des déclarations de données

\item des affectations concurrentes de signaux

\item des blocs processus

\item des instanciations de composants
\end{itemize}

La structure typique d'une architecture est comme dans le listage suivant.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
architecture nom_d_architecture of NOM_ENTITE is

-- Déclarations de types de données

-- Déclarations de composants

-- Déclarations de signaux

-- Déclarations de constantes

-- Déclarations de fonctions

-- Déclarations de procédures

begin

-- Énoncés concurrents ou séquentiels

end nom_d_architecture;
\end{minted}
\caption{Déclaration d'architecture}
\end{listing}

Les énoncés qui peuvent se trouver dans le corps de l'architecture
(entre le \texttt{begin} et le \texttt{end} peuvent être des instanciations de
composants, des assignations de signaux ou des énoncés de processus.

\section{Signaux et assignation}
\label{sec:org69eb7bc}

Un signal représente en quelque sorte un «fil». Une assignation comme

A <= NOT(B);

signifie que A et B sont des signaux reliés dont l'un est l'inverse
logique de l'autre.  Ainsi,

A <= B; 

signifie que les deux signaux A et B auront la même valeur logique.

\section{Notes sur la syntaxe}
\label{sec:orgcf0def6}

Des expressions aussi complexes que désiré peuvent être écrites, en
utilisant des parenthèses pour spécifier les priorités d'évaluation
des opérations (si elles doivent être différentes de la priorité
implicite de VHDL).

Voici des exemples d'expressions.
\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
a <= ((b and c and f) or (t nor r)) nand p;

a(3 downto 0) <=
b(4 downto 1) when (p and q)
else (p & q & q & p);
\end{minted}
\caption{Expressions}
\end{listing}

Les commentaires sont possibles: tout ce qui suit deux tirets (- -)
est ignoré.  Toutes les assignations doivent se terminer avec un
point-virgule (;)

Voici d'autres exemples d'assignations.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
A <= B OR C;

A <= B AND C;

A <= B NOR C;

A <= B NAND C;

A <= B XOR C;

A <= NOT B; --ceci est un commentaire

A <= (B AND C) OR (D AND E); --(aucune priorité 
                             -- préétablie de AND/OR)
\end{minted}
\caption{Assignations et commentaires}
\end{listing}

Nous nous contenterons de ces opérations pour le moment. Les
parenthèses permettent de préciser l'ordre des opérations.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
A <= B AND C AND D; -- ceci fonctionne

A <= B NAND C NAND D; -- pas ceci: NAND n'est pas associatif

A <= NOT(B AND C AND D); -- ceci fonctionne
\end{minted}
\caption{Priorité d'opérations et associativité}
\end{listing}

Voici encore d'autres exemples d'assignations.  Le dernier de ces
exemples fait appel à des vecteurs de signaux. Nous verrons plus loin
comment définir ces regroupements de signaux.


\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
Sum <= A XOR B XOR Cin;

Cout <= (A AND B) OR (A AND Cin);

Cout <= (A AND B) OR (A AND Cin) OR (B AND Cin);

a <= b when c else a; -- sélection (multiplexage)

a(6 downto 1) <= c & d(3 downto 0) & e; -- concaténation 
                                        -- bit-à-bit ("&")

\end{minted}
\caption{Assignations avec vecteurs de signaux}
\end{listing}

De façon générale, VHDL est insensible aux MAJUSCULES ou minuscules
et ignore les espaces supplémentaires et sauts de lignes. On doit
déclarer le type de tous les objets: signaux, constantes ou variables.

\section{Concurrence}
\label{sec:org1938d32}

Dans un corps d'architecture, les assignations sont
\textbf{concurrentes}. Par exemple, dans ce qui suit, les deux énoncés sont
évalués en parallèle. Les valeurs pour q et qb sont continuellement
mises à jour: dès qu'un des signaux à droite de l'assignation change
(on dit qu'un évènement se produit sur le signal), l'énoncé est évalué
de nouveau.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
q <= r nor qb; -- énoncé 1
qb <= s nor q; -- énoncé 2
\end{minted}
\caption{Énoncés concurrents}
\end{listing}

\textbf{Ce n'est pas comme en programmation} où les énoncés sont évalués
l'un après l'autre, une seule fois. Tous les énoncés concurrents sont
continuellement évalués.

L'effet de ces énoncés sera exactement le même si on les place dans un
autre ordre dans la description, comme ci-dessous.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
qb <= s nor q; -- énoncé 1
q <= r nor qb; -- énoncé 2
\end{minted}
\caption{Énoncés concurrents équivalents}
\end{listing}

Le langage décrit à la base un circuit et non pas une procédure:
toutes les portes sont toujours alimentées et les fils sont toujours
connectés. L'ordre dans lequel on donne la description n'a aucune
importance. Nous verrons plus loin qu'il est aussi possible de définir
des blocs dans lesquels l'exécution est séquentielle comme en
programmation.

\section{Vecteurs de bits}
\label{sec:orgaef080e}

Il est possible de grouper des signaux pour en faire des vecteurs, qui
sont des groupes ordonnés de bits: un mot, un bus, etc. De cette
façon, les spécifications sont plus compactes et faciles à
interpréter.

La convention la plus naturelle ordonne les indices de bits 
A(msb) \(\longleftrightarrow\) A(lsb),
mais l'ordre inverse est également possible. Il vaut mieux établir une
convention et s'y tenir pour éviter les erreurs d'interprétation.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
A(VALEUR_HAUTE downto VALEUR_BASSE)

A(15 downto 0) -- A comporte 16 bits

A(7 downto 3) -- 5 bits du milieu de A

A(0 to 7) -- A comporte 8 bits, énumérés de façon croissante
\end{minted}
\caption{Vecteur de bits}
\end{listing}

L'opérateur de concaténation \texttt{\&} permet de combiner des groupes de bits.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
A(15 downto 0) <= B(7 downto 0) &
                  C(7 downto 0);
\end{minted}
\caption{Concaténation}
\end{listing}

Considérons par exemple la partie du calcul de somme de la description
d'un additionneur 8 bits ci-dessous.  Avec des déclarations adéquates,
on pourrait écrire un calcul de somme plus compact.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
Sum(7 downto 0) <= A(7 downto 0)
xor B(7 downto 0)
xor C(7 downto 0);

C(7 downto 0) <= (A(7 downto 0) and
B(7 downto 0)
)
or (A(7 downto 0) and
(C(6 downto 0) & Cin)
)
or (B(7 downto 0) and
(C(6 downto 0) & Cin)
);

Cout <= C(7);
\end{minted}
\caption{Calcul de somme initial}
\end{listing}



\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
Sum <= A xor B xor (C(6 downto 0) & Cin);

C <= (A and B) or
(A and (C(6 downto 0) & Cin) ) or
(B and (C(6 downto 0) & Cin) );

Cout <= C(7);
\end{minted}
\caption{Calcul de somme compact}
\end{listing}

\section{Modèle complet}
\label{sec:org3f07cb7}

Considérons la bascule JK maître-esclave de la figure \ref{fig:org2322e34}
ci-dessous, construite au moyen de portes simples.  Un modèle
VHDL complet pour cette bascule JK maître-esclave est donné ensuite.

\begin{figure}[htbp]
\centering
\includesvg[scale=0.75]{Sources_images_logiques/images/JK-MS}
\caption{\label{fig:org2322e34}Bascule JK maître-esclave à modéliser}
\end{figure}


\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Bascule JK maître-esclave.
-- La bascule maître mémorise sur une horloge haute, 
-- la bascule esclave mémorise sur une horloge basse. 
-- Les deux rétroactions évitent les conditions 
-- interdites aux entrées 
entity mainJK is
  port (
    J: in std_logic; -- entrée J (set) de la bascule
    C: in std_logic; -- entrée d'horloge
    K: in std_logic; -- entrée K (reset) de la bascule
    Q: out std_logic; -- bit stocké
    notQ: out std_logic -- inverse du bit stocké
    );
end main;

architecture Complet of mainJK is
  signal notQ_temp: std_logic;
  signal Q_temp: std_logic;
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
begin
  s0 <= NOT C;
  s2 <= NOT ((notQ_temp AND J AND C) OR s1);
  s1 <= NOT (s2 OR (C AND K AND Q_temp));
  Q_temp <= NOT ((s2 AND s0) OR notQ_temp);
  notQ_temp <= NOT (Q_temp OR (s0 AND s1));
  Q <= Q_temp;
  notQ <= notQ_temp;
end Complet;
\end{minted}
\caption{Bascule JK maître-esclave}
\end{listing}

\section{Modèle comportemental}
\label{sec:orgf6467a0}

Un modèle comportemental d'une entité est un ensemble d'énoncés qui
sont exécutés séquentiellement. Ces énoncés peuvent se trouver dans
des blocs \texttt{process, function} ou \texttt{procedure}. Un tel bloc est concurrent
avec les autres énoncés du modèle général. Il est possible d'utiliser
des variables à l'intérieur des processus. Un énoncé d'assignation
spécifique aux variables permet d'assigner (sans délai) une valeur à
une variable qui a été préalablement déclarée. On se rapproche alors
de la programmation traditionnelle. Les variables sont locales aux
processus. Dans un bloc processus, il est possible d'avoir des
boucles, des branchements conditionnels, etc. Dans le corps de
l'entité, un bloc processus apparaît comme une grosse porte logique
arbitrairement définie lors de la conception du bloc.

\section{Modèle flux de données}
\label{sec:org9176bce}

Dans un modèle flux de données, c'est le mouvement des données qui est
exprimé par un ensemble d'énoncés concurrents. On peut faire appel à
des opérateurs logiques AND, OR, NOT, etc., pour décrire les relations
entre les signaux.

\section{Modèle structural}
\label{sec:orgd818417}

Un modèle structural décrit des ensembles de composants
interconnectés. Un énoncé d'instanciation d'un composant (qui revient
à dire quelque chose comme «utiliser le composant X ici» est un énoncé
concurrent qui indique de créer une instance de la «chose» spécifiée.

Une telle description structurale se contente de préciser quels
composants seront reliés à quels autres composants, sans référence au
comportement desdits composants.

Les énoncés qui suivent le \texttt{begin} spécifient l'instanciation de
composants et les interconnexions. Un énoncé d'instanciation de
composant crée un nouveau niveau hiérarchique. Chaque ligne commence
avec un \emph{nom d'instance}, suivi d'un deux-points (':'), d'un nom de
composant et du mot réservé \textbf{\texttt{port map}}.  Ce \texttt{port map} spécifie les
interconnexions du composant. Rappelons que l'ordre de ces
énoncés est sans conséquences.

\section{Bloc processus}
\label{sec:org062da0c}

Un énoncé \texttt{process} permet de définir un processus. Le format est le
suivant.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
[étiquette_processus:] process [ (liste_sensibilité) ] [is]
[déclarations_processus]
begin
--   liste d'énoncés séquentiels tels que:
-- assignations de signaux 
-- assignations de variables
-- énoncés case
-- énoncés exit
-- énoncés if 
-- énoncés loop 
-- énoncés next
-- énoncés null
-- appels de procedure
-- énoncés wait
end process [étiquette_processus];
\end{minted}
\caption{Bloc processus}
\end{listing}

Voici un exemple d'un modèle avec bloc processus d'une bascule D
déclenchée sur un front montant avec mise à zéro asynchrone.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
library ieee;
use ieee.std_logic_1164.all;

entity DFF_CLEAR is
   port (CLK, CLEAR, D : in std_logic;
      Q : out std_logic);

end DFF_CLEAR;

architecture COMPORT_DFF of DFF_CLEAR is
begin
DFF_PROCESS: process (CLK, CLEAR)
   begin
      if (CLEAR = '1') then
         Q <= '0';
      elsif (CLK'event and CLK = '1') then
         Q <= D;
      end if;
   end process;
end COMPORT_DFF;
\end{minted}
\caption{Bascule D, front montant, mise à zéro asynchrone}
\end{listing}

Le processus, déclaré à l'intérieur d'une architecture, est un énoncé
concurrent.  Mais tout ce qui se déroule à l'intérieur du processus
est exécuté de façon séquentielle. Comme tout énoncé concurrent, le
processus lit et écrit des signaux sur ses ports d'interface. Dans
l'exemple précédent, la sortie Q reçoit des valeurs par assignation au
sein du processus. L'expression \texttt{CLK'*event* *and* CLK = '1'} teste une
condition de front montant sur l'interface d'entrée CLK.

Il ne peut pas y avoir de déclarations de signaux dans un processus;
seules des variables ou des constantes peuvent être déclarées.

Une \textbf{liste de sensibilité} est un ensemble de signaux qui déclenchent
l'exécution du processus. N'importe quel changement sur un des signaux
de la liste provoque l'exécution immédiate du processus.

S'il n'y a pas de liste de sensibilité, il faudra inclure un énoncé
\texttt{wait} pour s'assurer que le processus se termine. Il n'est pas permis
d'avoir à la fois une liste de sensibilité et un énoncé \texttt{wait} pour un
même processus. Les variables et constantes utilisées dans le
processus sont définies dans la portion \texttt{déclarations\_processus}. 

Les énoncés entre \textbf{\texttt{begin}} et \textbf{\texttt{end}} sont exécutés séquentiellement. Les
assignations de variables, dénotées :=, sont exécutées immédiatement. 

Un énoncé concurrent est comme un processus d'une seule ligne, dont la
liste de sensibilité est constituée de tous les signaux qui sont à
droite de l'assignation.

Il est possible de définir un processus dont le corps est une
description combinatoire. Par exemple, le processus suivant permet de
modéliser une porte OU entre les entrées a et b. 

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
proc1: process
  begin
    wait on a, b;
    s <= a or b;
  end process proc1;
\end{minted}
\caption{Processus avec porte OU combinatoire}
\end{listing}

La sensibilité d'un tel processus (ici obtenue au moyen de l'énoncé
\texttt{wait on a, b;)} doit comporter tous les signaux utilisés pour que
l'exécution se fasse dès qu'une des entrées change de valeur.

Les assignations de signaux dans un processus ne prennent effet qu'une
fois que le processus est suspendu. Cela veut notamment dire que c'est
seulement la dernière assignation à un signal donné qui sera
effectivement exécutée.

Si un processus effectue une lecture d'un signal qui se verra aussi
assigner une valeur par le processus, la lecture prendra en compte la
valeur précédente du signal \textbf{avant} qu'il soit affecté par
l'assignation. Il est donc possible de créer de la rétroaction au sein
d'un même processus.

\section{Modélisation du délai}
\label{sec:org534387d}

Deux formes de délai peuvent être modélisés en VHDL. Le délai inertiel
et le délai de transport.

\begin{enumerate}
\item Délai inertiel
\label{sec:org0c507a3}

Le délai inertiel est la forme de délai par défaut. Le mot réservé
\texttt{after} suppose par défaut un délai inertiel. Avec du délai inertiel,
deux changements consécutifs du signal d'entrée qui sont plus
rapprochés temporellement que la valeur de délai ne seront pas
reflétés sur le signal de sortie. On modélise alors une inertie du
circuit, qui est trop lent pour réagir lorsque les changements
d'entrée sont trop rapides pour lui. Par exemple, avec une
assignation comme la suivante:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
b <= a after 30 ns;
\end{minted}
\caption{Délai inertiel}
\end{listing}

Si le signal a passe de '0' à '1' à 10 ns et de '1' à '0' à 20 ns, la
sortie ne changera pas du tout et restera tout le temps à '0'.

\item Délai de transport
\label{sec:org65e5fc4}

Le délai de transport applique un retard dans le signal de sortie. Par
exemple, avec la spécification suivante:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
b <= transport a after 20 ns;
\end{minted}
\caption{Délai de transport}
\end{listing}
Si le signal a passe de '0' à '1' à 10 ns et de '1' à '0' à 20 ns, la
sortie passera de '0' à '1' à 30 ns et de '1' à '0' à 40 ns,
reproduisant en sortie la même forme d'onde qu'en entrée, mais
retardée de 20 ns.
\end{enumerate}

\section{Librairies}
\label{sec:org347b4c3}

Des librairies de types peuvent être définies pour préciser des types
d'objets qui pourront ensuite être utilisés de façon standard. Par
exemple, la librairie IEEE \texttt{std\_logic\_1164} définit le type logique
\texttt{std\_logic} qui apporte plus de nuances que le simple type binaire,
qui lui ne comporte que deux valeurs numériques '0' et '1'.

Le tableau suivant donne la liste des valeurs possibles avec
\texttt{std\_logic}. Comme on peut le voir, les signaux pourront ainsi assumer
des valeurs comme Z (haute impédance pour les signaux trois-états), X
(pour valeur inconnue), - pour valeur facultative, etc. Il y a même
des nuances pour la solidité des valeurs logiques.

\begin{table}[htbp]
\caption{\label{tab:org58240a0}Valeurs pour \texttt{std\_logic}}
\centering
\begin{tabular}{ll}
Symbole & Interprétation\\[0pt]
\hline
'1' & 1 Logique\\[0pt]
'0' & 0 Logique\\[0pt]
'Z' & Haute impédance\\[0pt]
'W' & Signal faible, indéterminé entre 0 ou 1\\[0pt]
'L' & 0 faible, \emph{pulldown}\\[0pt]
'H' & 1 faible, \emph{pullup}\\[0pt]
'-' & \emph{Don't care}\\[0pt]
'U' & Non initialisé\\[0pt]
'X' & Inconnu, conflit entre sources multiples\\[0pt]
\end{tabular}
\end{table}

Une clause \texttt{use} permet de spécifier les librairies à utiliser au
début du fichier de spécification. Par exemple, le fichier VHDL
pourrait commencer avec les déclarations du listage suivant:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
\end{minted}
\caption{Déclaration de librairies}
\end{listing}

Nous avons déjà vu un exemple de l'utilisation de librairies dans le modèle
de la bascule JK maître-esclave.

\section{Encapsulation}
\label{sec:org56c3875}

Il est possible de grouper des énoncés et de les réutiliser
au besoin, dans d'autres modèles. Ceci nous permet de «cacher» la
description dans une boîte. Dans ce cas-ci, il s'agit d'un loquet SR
construit avec des portes NOR.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity rs is
port(r, s: in bit; q, qb: out bit);
end rs;

architecture norlogic of rs is
begin
q <= r nor qb;
qb <= s nor q;
end nor_logic;
\end{minted}
\caption{Encapsulation}
\end{listing}

L'entité définie est un composant qui peut être utilisée dans
d'autres circuits, à l'intérieur d'une hiérarchie de design. Voici
comment on peut utiliser le composant loquet pour modéliser un loquet D.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity Dlatch is
port (clk,d: in bit; q,qb: out bit);
end Dlatch;

architecture test of Dlatch is
--
signal db, cr, cs: bit;
--
component rs_ff
port (r, s: in bit;
q, qb: out bit);
end component;
--
label rs0;
--
for rs0: rs_ff
use entity rs(nor_logic);

begin
db <= not d;
cr <= db and clk;
cs <= d and clk;
rs0: rs_ff port map(cr, cs, q, qb);
end test;
\end{minted}
\caption{Utilisation d'un composant}
\end{listing}

Voici un exemple de bascule maître-esclave conçue de façon structurale
à partir du composant loquet:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity MS is
port (clear,reset,set,clock: in bit;
q, qbar: out bit);
end MS;

architecture ms_struct of MS is
signal clrbar, r0, s0, q0, qbar0,
r1, s1, cbar: bit;
label rs0, rs1;
component rs_ff
port (r,s: in bit; q,qbar: out bit);
end component;
for rs0, rs1: rs_ff
use entity RS(nor_logic);
begin
clrbar <= not clear;
cbar <= not clock;
r0 <= (reset and clock) or clear;
s0 <= (set and clock) and clrbar;
rs0: rs_ff port map(r0,s0,q0,qbar0);
r1 <= (qbar0 and cbar) or clear;
s1 <= (q0 and cbar) and clrbar;
rs1: rs_ff port map(r1,s1,q,qbar);
end ms_struct;
\end{minted}
\caption{Bascule maître-esclave structurale}
\end{listing}

Voici un exemple de compteur élaboré à partir de cette bascule maître-esclave:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity CNTER is
port (clock, clear: in bit;
a: out bit_vector(3 downto 0));
end CNTER;

architecture count of CNTER is
signal b: bit_vector(3 downto 0);
component ms_ff
port (clr, r, s, c: in bit;
q, qbar: out bit);
end component;
label ms0, msl, ms2, ms3;
for ms0, msl, ms2, ms3: ms_ff
use entity MS(ms_struct);
begin
ms0: ms_ff port map(
clear,a(0),b(0),clock,a(0),b(0));
ms1: ms_ff port map(
clear,a(1),b(1),a(0),a(1),b(1));
ms2: ms_ff port map(
clear,a(2),b(2),a(1),a(2),b(2));
ms3: ms_ff port map(
clear,a(3),b(3),a(2),a(3),b(3));
end count;
\end{minted}
\caption{Compteur basé sur la bascule}
\end{listing}


\section{Description de design en VHDL}
\label{sec:orgc0debce}

La description complète du système à simuler est placée dans un
fichier avec extension .vhdl qui est ensuite compilé et simulé.  On
appelle cette description «fichier de design» ou «design» tout court.

Un design en VHDL est un ensemble d'entités de conception. L'entité de
plus haut niveau invoque les autres entités comme composants. Le design
dans son ensemble est appelé «hiérarchie de design».

\begin{enumerate}
\item Multiplicateur huit bits
\label{sec:org8117761}

Voici l'exemple d'un multiplicateur huit bits construit à partir de
plusieurs autres composants.  Les listages qui suivent donnent le
détail de la modélisation.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity multiply is
port (load, clock: in bit;
input1, input2: in
bit_vector(7 downto 0);
product: out
bit_vector(15 downto 0);
output_valid: out bit);
end multiply;
--
entity adder is
port(a: in bit_vector(7 downto 0);
b: in bit_vector(7 downto 0);
cin: in bit;
sum: out bit_vector(7 downto 0)
cout: out bit) ;
end adder;
--
entity D_FF is
port(din: in bit_vector(7 downto 0)
dout: out bit_vector(7 downto 0)
enable: in bit);
end D_FF;
\end{minted}
\caption{Multiplicateur 8 bits: entités}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
architecture logic of adder is
signal cw, cx: bit_vector(7 downto 0);
--
begin
cw(0) <= cin;
cw(7 downto 1) <= cx(6 downto 1);
cx <= (a and b) or (a and cw) or (b and cw);
sum <= a xor b xor cw;
cout <= cx(7);
end logic;
\end{minted}
\caption{Multiplicateur 8 bits: composant adder}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
architecture edge of D_FF is
-- une bascule D de 8 bits de large
signal x, y, z, w, qb, e :
bit_vector(7 downto 0);
begin
e <= "11111111" when enable else 0;
x <= din nand y;
y <= e nand (not w);
z <= e nand w;
w <= z nand x;
dout <= z nand qb;
qb <= y nand dout;
end edge;
\end{minted}
\caption{Multiplicateur 8 bits: composant FF}
\end{listing}


\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
architecture mult of multiply is
signal mux1, mux2, mux3, mux4:
bit_vector(7 downto 0);
signal control, adder_out:
bit_vector(7 downto 0);
signal accum:
bit_vector(15 downto 0);
signal carry_out: bit;
label l1, l2, l3, l4;

component add
port (argl, arg2: in bitvec;
c_in: in bit;
result: out bitvec;
c_out: out bit);
end component;
for l4: add use entity adder(logic);

component latch
port (xin: in bitvec;
xout: out bitvec; enable: in bit);
end component;
for l1, l2, l3: latch use
entity D_FF(edge);
\end{minted}
\caption{Multiplicateur 8 bits: déclarations}
\end{listing}


\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
begin mux1(7 downto 0) <= 255 when load else "0" & contro1(7 downto
1); l1: latch port map ( mux1, control, clock);

mux2 <= 0 when load else
carry_out & adder_out(7 downto 1);
l2: latch port map (
mux2, accum(15 downto 8), clock);

mux3 <= input2 when load else
adder_out(0) & accum(7 downto 1);
l3: latch port map (
mux3, accum(7 downto 0), clock);

mux4 <= input1 when accum(0) else 0;
l4: add port map (
mux4, accum(15 downto 8), "0",
adder_out, carry_out);

output_valid <= not(control(0));
product <= accum when output_valid
else 0;
end mult;
\end{minted}
\caption{Multiplicateur 8 bits: descriptions}
\end{listing}
\end{enumerate}


\section{Banc d'essai}
\label{sec:org646fdfe}

Pour simuler un circuit avec un HDL, on doit lui appliquer des signaux
aux entrées afin que le simulateur puisse générer les sorties
correspondantes. Une description qui vise à générer ces signaux
d'entrée est appelée un \textbf{banc d'essai}.


\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{Sources_images_logiques/images/banc_essai.png}
\caption{\label{fig:orge38225a}Banc d'essai}
\end{figure}

Le bloc stimulus génère les signaux d'excitation qui sont appliqués
aux entrées du modèle à tester. Un bloc se charge de valider les
sorties observées, ce qui peut être fait automatiquement.

On commence par définir une entité de niveau supérieur pour le banc
d'essai:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity test_bench is

end entity test_bench;
\end{minted}
\caption{Entité banc d'essai}
\end{listing}

L'entité ne comporte pas de ports, puisque le banc d'essai ne comporte
pas d'entrées ou de sorties externes.

\section{Instanciation}
\label{sec:org9f5e8da}

Il faut ensuite instancier le modèle à tester. L'instanciation peut se
faire comme composant ou directement. À moins de vouloir définir un
\emph{package} pour le modèle à tester, le composant doit être défini \textbf{avant}
le code principal. 

Voici un exemple de déclaration d'instanciation par composant. Les
noms de composant et de ports doivent correspondre à ceux du modèle à
tester.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
component and_gate is 
port ( 
   a : in std_logic; 
   b : in std_logic; 
   and_out : out std_logic 
); 
end component and_gate; 
\end{minted}
\caption{Banc d'essai: instanciation par composant}
\end{listing}

Le composant est ensuite relié au modèle de test. 

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
and_gate_instance: component and_gate
  port map (
    a       => signal_a,
    b       => signal_b,
    and_out => signal_and_out
  );
\end{minted}
\caption{Composant lié}
\end{listing}

Chaque instanciation doit avoir son propre nom. Ici, c'est
\texttt{and\_gate\_instance}. Les noms de signaux à gauche sont les noms des
ports du composant. Les noms à droite sont les signaux qui sont reliés
aux ports. Ces signaux doivent être déclarés avant utilisation et
avoir le bon type.

Voici un exemple d'instanciation directe:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
and_gate_instance: entity work.and_gate(ltr)
  port map (
    a       => signal_a,
    b       => signal_b,
    and_out => signal_and_out
  );
\end{minted}
\caption{Instanciation directe}
\end{listing}

Dans ce cas, il faut également préciser la librairie et l'architecture
pour le modèle à tester. Ici, la librairie est «work» et
l'architecture est «ltr».

\section{Écoulement du temps}
\label{sec:org3d631be}

Pour tester le modèle, on doit typiquement produire des signaux qui
varient en fonction du temps. Pour ce faire, il est possible
d'utiliser les énoncés \texttt{after} et \texttt{wait}. Il existe un type prédéfini
VHDL pour le temps, qui utilise les unités suivantes:

\begin{table}[htbp]
\caption{\label{tab:org2878254}Unités de temps}
\centering
\begin{tabular}{ll}
Unité & Valeur\\[0pt]
\hline
fs & \\[0pt]
ps & 1000 fs\\[0pt]
ns & 1000 ps\\[0pt]
us & 1000 ns\\[0pt]
ms & 1000 us\\[0pt]
sec & 1000 ms\\[0pt]
min & 60 sec\\[0pt]
hr & 60 min\\[0pt]
\end{tabular}
\end{table}

La plus petite unité de temps correspond à une femtoseconde (\(10^{-15}\) seconde).

Voici des exemples d'énoncés liés au temps:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
time_ex <= 100 ps; -- 100 picoseconds 
time_ex <= 1.2 ns; -- 1200 picoseconds
time_ex <= 1.2 sec; -- 1200 milliseconds
\end{minted}
\caption{Énoncés liés au temps}
\end{listing}

\begin{enumerate}
\item Énoncé \texttt{after}
\label{sec:orge961859}

L'énoncé \texttt{after} ajoute un aspect temporel à une assignation. La
partie de l'énoncé qui précède la virgule est une assignation qui
fonctionne comme toute assignation normale. La deuxième partie de
l'énoncé spécifie une nouvelle valeur pour le signal, qui prendra effet
au temps (futur) indiqué.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
<signal> <= <valeur_initiale>, <valeur_finale> after <temps>;
\end{minted}
\caption{Énoncé \texttt{after}}
\end{listing}

Voici un exemple d'utilisation pour créer un signal de mise à zéro:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
reset <= '1', '0' after 1 us;
\end{minted}
\caption{Signal de mise à zéro}
\end{listing}

L'exemple suivant montre une méthode simple pour générer un signal
d'horloge. La période obtenue sera le double du délai, soit ici 20 ns.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
clock <= not clock after 10 ns;
\end{minted}
\caption{Signal d'horloge}
\end{listing}

\item L'énoncé \texttt{wait}
\label{sec:org3e9ff07}

L'énoncé \texttt{wait} suspend l'exécution dans un bloc processus pendant un
certain temps. Rappelons que le processus ne peut pas avoir de liste
de sensibilité. Trois types d'usage de \texttt{wait} sont possibles:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
wait for <time>; 

wait until <condition> for <time>;

wait on <signal_name>;
\end{minted}
\caption{Énoncé \texttt{wait}}
\end{listing}

Dans le premier cas, l'exécution est stoppée pendant la durée
indiquée.

Dans le deuxième cas, l'exécution est stoppée jusqu'à ce que la
condition soit remplie. Il est possible de fonder les conditions sur
des macros pour les fronts montants \texttt{rising\_edge} ou descendants
\texttt{falling\_edge}. La portion \texttt{for} est optionnelle. Elle permet de
prévoir un temps d'attente maximal. L'attente s'arrêtera donc si la
condition est remplie ou après l'écoulement du temps spécifié.

Dans le troisième cas, on attend simplement qu'un évènement se
produise sur le signal spécifié pour cesser l'attente. Il est possible
de spécifier une liste de signaux en les séparant par des virgules:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
wait on sig_a, sig_b;
\end{minted}
\caption{Liste de signaux en attente d'évènement}
\end{listing}
\end{enumerate}


\section{Exemples de banc d'essai}
\label{sec:orgb70f342}

Testons un circuit séquentiel simple comportant deux entrées A et
B qui passent par une porte ET et une bascule avec sortie Q.

\begin{enumerate}
\item Création d'une entité vide pour le banc d'essai
\label{sec:org9cd75f2}

L'extrait de code suivant montre le point de départ de notre banc
d'essai.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity exemple_tb is
end entity exemple_tb;

architecture test of exemple_tb is

--

end architecture exemple_tb;
\end{minted}
\caption{Entité vide pour banc d'essai}
\end{listing}

\item Instanciation du modèle à tester
\label{sec:orged2e8d0}

Nous faisons une instanciation directe. L'extrait de code suivant
montre comment la spécifier, en supposant que les signaux \texttt{in\_a, in\_b}
et \texttt{out\_q} ont été déclarés précédemment:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}

-- Instanciation du modèle à tester 
dut: entity work.exemple_design(rtl)
  port map (
    a => in_a,
    b => in_b,
    q => out_q
   );

\end{minted}
\caption{Instanciation du modèle}
\end{listing}

\item Génération de l'horloge et du signal de mise à zéro
\label{sec:org1c7bf04}

Il faut ensuite générer les signaux d'horloge et de mise à zéro, en
spécifiant les éléments temporels. Les deux signaux seront définis de
façon concurrente. Nous prévoyons une inversion d'horloge à toutes les
10 ns, ce qui donne une période de 20 ns qui correspond à une
fréquence de 50 MHz. L'extrait de code suivant montre les détails:

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
-- Reset et clock
clock <= not clock after 10 ns;
reset <= '1', '0' after 50 ns;
\end{minted}
\caption{Génération de signaux de test}
\end{listing}

\item Stimulus
\label{sec:orgf957401}

Le dernier élément à spécifier est le stimulus, c'est-à-dire les
signaux qui seront appliqués aux entrées de notre modèle à
tester. Nous utilisons un processus pour générer les quatre
combinaisons possibles de nos deux entrées.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
  -- Génération du stimulus
  stimulus:
  process begin
    -- Attendre que reset soit activé
    wait until (reset = '0');

    -- Générer chaque condition, avec 2 périodes entre chaque
    -- itération pour laisser du temps pour la propagation
    and_in <= "00";
    wait for 20 ns;
    and_in <= "01";
    wait for 20 ns;
    and_in <= "10";
    wait for 20 ns;
    and_in <= "11";

    -- Fin du test
    wait;
  end process stimulus;

end architecture exemple_tb;
\end{minted}
\caption{Stimulus pour entrées}
\end{listing}

\item Exemples complets
\label{sec:org9f34812}

Dans le premier exemple, nous faisons appel ici au mot réservé \texttt{alias}
qui permet de rendre le code plus facile à comprendre en nommant un
sous-ensemble du type \texttt{array} qui a été utilisé pour générer les
combinaisons d'entrées.

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity exemple_tb is
end entity exemple_tb;

architecture test of exemple_tb is
  signal clock  : std_logic := '0';
  signal reset  : std_logic := '1';
  signal and_in : std_logic_vector(1 down 0) := (others => '0');
  alias in_a is and_in(0);
  alias in_b is and_in(1);
  signal out_q  : std_logic;
begin
  -- Reset et clock
  clock <= not clock after 10 ns;
  reset <= '1', '0' after 50 ns;
  -- Instanciation du modèle à tester 
  dut: entity work.exemple_design(rtl)
    port map (
      a => in_a,
      b => in_b,
      q => out_q );
  -- Génération du stimulus
  stimulus:
  process begin
    wait until (reset = '0');  -- Attendre reset relâché
    -- Générer chaque condition, avec 2 périodes entre chaque
    -- itération pour laisser du temps pour la propagation
    and_in <= "00";
    wait for 2 ns;
    and_in <= "01";
    wait for 2 ns;
    and_in <= "10";
    wait for 2 ns;
    and_in <= "11";
    -- Fin du test
    wait;
  end process stimulus;
end architecture exemple_tb;
\end{minted}
\caption{Premier exemple complet de banc d'essai}
\end{listing}

Le listage du deuxième exemple de banc d'essai, qui teste le
fonctionnement d'un compteur haut/bas de quatre bits modélisé de façon
comportementale, est présenté en trois portions. Une façon différente
de générer le signal d'horloge y est utilisée.

\begin{listing}[htbp]
\begin{minted}[frame=lines,linenos=true]{vhdl}
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;


entity up_down_counter is
  port( clock : in std_logic;
        reset : in std_logic;
        up_down : in std_logic;
        counter : out std_logic_vector(3 downto 0));
end up_down_counter;

architecture bhv of up_down_counter is
  signal t_count: unsigned(3 downto 0);
begin
  process (clock, reset)
  begin
    if (reset='1') then
      t_count <= "0000";
    elsif rising_edge(clock) then
      if up_down = '0' then
        t_count <= t_count + 1;
      else
        t_count <= t_count - 1;
      end if;
    end if;
  end process;

  counter <= std_logic_vector(t_count);
end bhv;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_up_down is
end tb_up_down;

\end{minted}
\caption{Deuxième exemple complet de banc d'essai, portion 1}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[linenos,firstnumber=39,frame=lines,linenos=true]{vhdl}
architecture behavior of tb_up_down is

-- déclaration de composant pour le modèle à tester

component up_down_counter
port(
clock : in std_logic;
reset : in std_logic;
up_down : in std_logic;
counter : out std_logic_vector(3 downto 0)
);
end component up_down_counter;

--Inputs
signal clock : std_logic := '0';
signal reset : std_logic := '0';
signal up_down : std_logic := '0';

--Outputs
signal counter : std_logic_vector(3 downto 0);

-- Clock period definitions
constant clock_period : time := 20 ns;

begin

-- Instanciation du composant à tester
uut: component up_down_counter
  port map (
    clock => clock,
    reset => reset,
    up_down => up_down,
    counter => counter
);

\end{minted}
\caption{Deuxième exemple complet de banc d'essai, portion 2}
\end{listing}

\begin{listing}[htbp]
\begin{minted}[linenos,firstnumber=73,frame=lines,linenos=true]{vhdl}

-- Processus d'horloge
clock_process: process
begin
clock <= '0';
wait for clock_period/2;
clock <= '1';
wait for clock_period/2;
end process;

-- Processus de stimulus
stim_proc: process
begin
-- hold reset state for 100 ns.
wait for 20 ns;
reset <= '1';
wait for 20 ns;
reset <= '0';
up_down <= '0';
wait for 200 ns;
up_down <= '1';
wait;
end process;

end;
\end{minted}
\caption{Deuxième exemple complet de banc d'essai, portion 3}
\end{listing}
\end{enumerate}


\section{Compilation et simulation}
\label{sec:org3047441}

Voici enfin les grandes étapes permettant de passer de la spécification d'un
modèle à une simulation du comportement du circuit modélisé. 

\begin{enumerate}
\item Créer un fichier VHDL. Ce fichier ne contient qu'une seule paire
entité.architecture de niveau supérieur, qui sera le banc
d'essai. Il y aura typiquement d'autres entités de niveau
inférieur, notamment le modèle de circuit à simuler.
\end{enumerate}

\begin{listing}[htbp]
\begin{minted}[frame=lines]{vhdl}
entity MACHIN is
...
end MACHIN;

architecture TRUC of MACHIN is
...
end TRUC;
\end{minted}
\caption{Entité de niveau supérieur}
\end{listing}

\begin{enumerate}
\item Compiler cette description. Les commandes à utiliser dépendent du
simulateur qui est utilisé, mais deux étapes sont normalement
requises:
\begin{itemize}
\item l'\textbf{analyse} du code source
\item l'\textbf{élaboration} du design
\end{itemize}

\item Une fois le design élaboré, on peut \textbf{simuler} le résultat. Si le
simulateur ne permet pas directement la visualisation des
résultats, il faudra sauvegarder les résultats de simulation sous un
format qui permettra ensuite de les visualiser avec un autre outil.

\item Pour \textbf{visualiser} le résultat, on peut utiliser un outil intégré ou encore un
outil externe qui permet de visualiser les signaux obtenus (formes d'ondes,
résultats interprétés).
\end{enumerate}

\chapter{Préparation et simulation des modèles VHDL}
\label{sec:org1460e2b}

\section{Éditeurs}
\label{sec:orgb194a3c}

N'importe quel éditeur de programmation peut être utilisé pour éditer
les modèles VHDL. Certains simulateurs comportent un éditeur
intégré. Il peut être avantageux d'utiliser un éditeur avec fonction
de surlignage syntaxique pour le langage.

\section{Simulateurs gratuits}
\label{sec:orga09be9a}

Voici quelques simulateurs gratuits. 

\begin{enumerate}
\item Modelsim/Questa
\label{sec:orgfdbcd53}

Des versions de ce simulateur sont offertes par plusieurs fabricants
de circuits intégrés programmables:

Intel: 

\href{https://www.intel.com/content/www/us/en/collections/products/fpga/software/downloads.html?s=Newest\&f=\%255B\%257B\%2522name\%2522\%3A\%2522quartusedition\%2522\%2C\%2522facetId\%2522\%3A\%2522quartusedition\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522name\%2522\%3A\%2522quartusaddon\%2522\%2C\%2522facetId\%2522\%3A\%2522quartusaddon\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%257B\%2522value\%2522\%3A\%2522Intel\%25C2\%25AE\%2520FPGA\%2520Simulation\%2520Tools\%2522\%2C\%2522state\%2522\%3A\%2522idle\%2522\%2C\%2522children\%2522\%3A\%255B\%257B\%2522value\%2522\%3A\%2522Questa*-Intel\%25C2\%25AE\%2520FPGA\%2520Starter\%2520Edition\%2522\%2C\%2522state\%2522\%3A\%2522selected\%2522\%257D\%255D\%257D\%255D\%257D\%2C\%257B\%2522name\%2522\%3A\%2522fpgadevicefamily\%2522\%2C\%2522facetId\%2522\%3A\%2522fpgadevicefamily\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522name\%2522\%3A\%2522fpgaplatform\%2522\%2C\%2522facetId\%2522\%3A\%2522fpgaplatform\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522facetId\%2522\%3A\%2522os-rdc\%2522\%2C\%2522name\%2522\%3A\%2522OperatingSystem\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522facetId\%2522\%3A\%2522\%40emtcontenttype\_en\%2522\%2C\%2522name\%2522\%3A\%2522ContentType\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%2C\%257B\%2522facetId\%2522\%3A\%2522lastupdated-rdc\%2522\%2C\%2522name\%2522\%3A\%2522lastupdated\%2522\%2C\%2522currentValues\%2522\%3A\%255B\%255D\%257D\%255D\&q=lite}{FPGA Software Download Center}


\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat ou Ubuntu)
\item Un des simulateurs les plus populaires
\item L'utilisation requiert une licence (gratuite) spécifique à un
ordinateur donné, qu'il faut demander par courriel
\item L'installation et l'activation comportent plusieurs étapes
\end{itemize}


Lattice:

\href{http://www.latticesemi.com/icecube2}{iCEcube2 Design Software}

\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat)
\item Fait partie d'une suite logicielle en support à la gamme de FPGA du
fabricant
\item L'utilisation requiert une licence (gratuite) spécifique à un
ordinateur donné
\end{itemize}

Microchip:

\href{https://www.microchip.com/en-us/products/fpgas-and-plds/fpga-and-soc-design-tools/fpga/libero-software-later-versions\#downloads}{Libero SoC Design Suite}

\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat)
\item Fait partie d'un suite logicielle (Libero) en support à la gamme de
FPGA du fabricant
\item L'utilisation requiert une licence (gratuite) spécifique à un
ordinateur donné
\end{itemize}

\item Active-HDL (version étudiante)
\label{sec:org75d908d}

\href{https://www.aldec.com/en/products/fpga\_simulation/active\_hdl\_student}{Free Active-HDL Student Edition}

\begin{itemize}
\item Fonctionne sous Windows
\item Licence gratuite pour la communauté étudiante (on doit indiquer son université)
\item L'inscription donne accès à une page de téléchargement
\end{itemize}

\item Vivado (Xilinx)
\label{sec:org85389b6}

\href{https://www.xilinx.com/support/download.html}{Xilinx téléchargements}

\begin{itemize}
\item Fonctionne sous Windows ou Linux (Red Hat ou Ubuntu)
\item Cette suite pour conception de circuits intégrés programmables
comporte un simulateur
\item L'utilisation requiert une licence (gratuite) spécifique à un
ordinateur donné
\end{itemize}

\item GHDL/GTKWave
\label{sec:orgf3ed052}

\url{http://ghdl.free.fr/}

\url{https://github.com/ghdl/ghdl}

\url{http://gtkwave.sourceforge.net/}

\url{https://github.com/gtkwave/gtkwave}

Ces deux logiciels sont à code source ouvert, donc entièrement
gratuits.

\begin{itemize}
\item Fonctionnent sous Windows, Mac ou Linux
\item GHDL est utilisé pour la simulation
\item GTKWave est utilisé pour visualiser les résultats
\end{itemize}

\item EDA Playground
\label{sec:org3e1d484}

\href{https://www.edaplayground.com/}{EDA Playground}

\begin{itemize}
\item Cette option, utilisable via un fureteur Web, ne nécessite pas
d'installation et peut donc s'utiliser sur toutes les plateformes
\item On doit s'enregistrer
\item Il est possible de choisir le simulateur
\item On y trouve également des exemples de codes
\end{itemize}
\end{enumerate}

\part{Exercices}
\label{sec:org785118c}

\chapter*{Série 1}
\label{sec:org64ecb65}
\section*{Question}
\label{sec:org4d72a88}
Effectuez la conversion des nombres suivants dans la base demandée:

\begin{enumerate}
\item \((32)_{10} = ( )_{2}\)

\item \((F8,A7)_{16} = ( )_{2}\)

\item \((65)_{8} = ( )_{16}\)

\item \((240,51)_{8} = ( )_{10}\)

\item \((25)_{10} = ( )_{8}\)

\item \((100101011)_{2} = ( )_{10}\)

\item \((28)_{10} = ( )_{2}\)

\item \((E3)_{16} = ( )_{2}\)

\item \((B3)_{16} = ( )_{8}\)

\item \((11001011101)_{2} = ( )_{16}\)

\item \((754)_{8} = ( )_{10}\)

\item \((106)_{8} = ( )_{16}\)

\item \((27,52)_{10} = ( )_{2}\)

\item \((4F,3D9)_{16} = ( )_{2}\)

\item \((73,313)_{8} = ( )_{16}\)

\item \((364,3)_{8} = ( )_{10}\)

\item \((25)_{10} = ( )_{8}\)

\item \((111101011)_{2} = ( )_{10}\)

\item \((31,22)_{10} = ( )_{2}\)

\item \((43,39)_{16} = ( )_{2}\)

\item \((43,37)_{8} = ( )_{8}\)

\item \((36)_{8} = ( )_{10}\)

\item \((25)_{10} = ( )_{8}\)

\item \((101101111)_{2} = ( )_{10}\)
\end{enumerate}

\section*{Question}
\label{sec:orgff39fc1}
Donnez le nombre minimum de bits nécessaires pour définir un code
   pour représenter:

\begin{enumerate}
\item les chiffres de 0 à 9

\item les nombres de -17 à 17

\item les lettres A \dots{} Z et les chiffres 0 \dots{} 9

\item alphanumérique pour les lettres A \dots{} Z, a \dots{} z et les
chiffres 0 \dots{} 9
\end{enumerate}

\section*{Question}
\label{sec:org789aa9e}
Calculez les compléments suivants (pour un nombre de bits \(n\)):

\begin{enumerate}
\item complément à deux de \((1101011)_2\) en supposant \(n=8\)

\item complément à deux de \((110101)_2\) en supposant \(n=8\)

\item complément à un de \((0101101)_2\) en supposant \(n=8\)

\item complément à deux de \((01112)_3\) en supposant \(n=7\)

\item complément à cinq de \((32402)_5\) en supposant \(n=7\)

\item compl. à 2 de \((10110001)_2\)

\item compl. à 2 de \((0001101)_2\)

\item compl. à 1 de \((0101101)_2\)

\item compl. à 2 de \((02112)_3\)

\item compl. à 5 de \((42102)_5\)
\end{enumerate}

\section*{Question}
\label{sec:orga6bb2c4}
Effectuez les calculs suivants selon la méthode indiquée:

\begin{enumerate}
\item \((2CF3)_{16} + (2B)_{16}\), (add. directe base 16). Réponse: \(( )_{16}\)

\item \((704)_{8} + (230)_{8}\), add. directe base 8, conversion). Réponse: \(( )_{8} = ( )_{10}\)

\item \((34)_{8} - (42)_{8}\), complément à 2, conversion. Réponse: \(( )_{2} = ( )_{16}\)

\item \((11011101)_{2} - (55)_{10}\), complément à 2, conversion. Réponse: \(( )_{2}\)

\item \((AC)_{16} + (4)_{16}\) par addition directe en base 16. Réponse: \(( )_{16}\)

\item \((E1)_{16} - (1B)_{16}\) en utilisant le complément à 1 en base 2. Réponse: \(( )_{16}\)

\item \((46)_{8} - (73)_{8}\) en utilisant le complément à 2 en base 2. Réponse: \(( )_{16}\)

\item \((BE)_{16} + (22)_{16}\), (add. directe base 16). Réponse: \(( )_{16}\)

\item \((73)_{8} + (103)_{8}\), add. directe base 8, conversion). Réponse: \(( )_{8} = ( )_{10}\)

\item \((22)_{8} - (26)_{8}\), compl. à 2, conversion. Réponse: \(( )_{2} = ( )_{16}\)

\item \((11011100)_{2} - (57)_{10}\), compl. à 2, conversion. Réponse: \(( )_{2}\)

\item \((AE)_{16} + (12)_{16}\), (add. directe base 16). Réponse: \(( )_{16}\)

\item \((63)_{8} + (135)_{8}\), add. directe base 8, conversion). Réponse: \(( )_{8} = ( )_{10}\)

\item \((35)_{8} - (26)_{8}\), compl. à 2, conversion. Réponse: \(( )_{2} = ( )_{16}\)

\item \((11011100)_{2} - (55)_{10}\), compl. à 2, conversion. Réponse: \(( )_{2}\)
\end{enumerate}

\section*{Question}
\label{sec:org41472f3}
Vous disposez de blocs permettant de calculer les fonctions
   suivantes:

\begin{description}
\item[{C4}] complément à un d'un nombre de 4 bits

\item[{ADD4}] addition de deux nombres de 4 bits, avec entrée pour retenue et
retenue de sortie.
\end{description}

Indiquez par un schéma-bloc comment on peut relier ces blocs pour
calculer:

\begin{enumerate}
\item le complément à deux d'un nombre de 4 bits

\item le complément à deux d'un nombre de 8 bits

\item la somme de deux nombres de 8 bits

\item la soustraction de nombres de 4 bits
\end{enumerate}

\section*{Question}
\label{sec:org66ab6fb}
Un réseau informatique comporte 60 ordinateurs. On doit assigner à
   chacun de ces ordinateurs un mot-code binaire unique.

\begin{enumerate}
\item Combien de bits par mot sont nécessaire pour la codification?

\item Combien de mots-code ne seront pas utilisés?
\end{enumerate}

\section*{Question}
\label{sec:org84a050f}
Selon les critères d'achat du service des achats d'une entreprise, un
  article sera acheté s'il remplit au moins une des conditions
  suivantes:

\begin{itemize}
\item il est peu coûteux ou de qualité, tout en étant disponible
rapidement,

\item il est peu coûteux et n'est pas disponible rapidement,

\item il est coûteux et de mauvaise qualité, tout en étant disponible
rapidement.
\end{itemize}

En utilisant la notation suivante:

\begin{description}
\item[{A}] coûteux

\item[{B}] de bonne qualité

\item[{C}] disponible rapidement

\item Exprimez les critères d'achat sous forme d'une expression
booléenne (non-simplifiée).

\item Donnez le tableau de vérité de la fonction logique des critères
d'achat.

\item Donnez la forme canonique, en somme de produit, de la fonction
logique des critères d'achat.

\item Déterminez si les expressions logiques suivantes sont égales à la
fonction logique des critères d'achat:

$$F_1 = A^{\prime} B^{\prime} + B^{\prime} C^{\prime}$$

$$F_2 = A^{\prime} B^{\prime} C^{\prime} + A^{\prime} B^{\prime} C + A^{\prime} B C^{\prime} + A B^{\prime} C^{\prime}$$

$$F_2 = B^{\prime} C^{\prime} + A^{\prime} B^{\prime} + A^{\prime} C$$
\end{description}

\section*{Question}
\label{sec:org0c0b34b}
Donnez le nombre minimum de bits nécessaires pour définir un code pour représenter

\begin{enumerate}
\item les jours de la semaine

\item les jours du mois

\item les jours dans l'année (nombre entre 1 et 365)

\item les jours de l'année (mois et date)

\item une date de naissance (jour, mois, année)
\end{enumerate}

\chapter*{Série 2}
\label{sec:org787062c}
\section*{Question}
\label{sec:org58b160b}
La fonction logique à trois entrées \(S = F(A,B,C)\) donnée par son 
   tableau de vérité:
\begin{center}
\begin{tabular}{rrrlr}
\(A\) & \(B\) & \(C\) &  & \(S\)\\[0pt]
\hline
0 & 0 & 0 &  & 1\\[0pt]
0 & 0 & 1 &  & 1\\[0pt]
0 & 1 & 0 &  & 0\\[0pt]
0 & 1 & 1 &  & 1\\[0pt]
1 & 0 & 0 &  & 0\\[0pt]
1 & 0 & 1 &  & 0\\[0pt]
1 & 1 & 0 &  & 1\\[0pt]
1 & 1 & 1 &  & 0\\[0pt]
\end{tabular}
\end{center}

doit être implémentée par un circuit logique.

\begin{enumerate}
\item Donnez l'expression de cette fonction:

\begin{itemize}
\item Selon la première forme canonique ( \(\sum m_i\) )

\item Selon la deuxième forme canonique ( \(\prod M_i\) )
\end{itemize}

\item Trouvez une expression simplifiée pour la fonction en utilisant
les théorèmes de l'algèbre de Boole.

\item Dessinez le circuit logique correspondant à l'expression
simplifiée trouvée.
\end{enumerate}

\section*{Question}
\label{sec:org5ca0eeb}
Trouvez le complément de la fonction logique donnée par l'expression
   suivante en utilisant trois méthodes différentes.
   $$
    s = b (a^{\prime} c^{\prime} + a d + a c) + (b + c^{\prime}+
      d)^{\prime} + a^{\prime} b c^{\prime} d + a b c d
    $$

\section*{Question}
\label{sec:orgb1ca06f}
Considérez la fonction logique définie par l'expression \(F =
      [ (C + B) A^{\prime} + (A+B)^{\prime} ] B^{\prime}\).

\begin{enumerate}
\item Dessinez le circuit logique correspondant.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NAND.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NOR.
\end{enumerate}

\section*{Question}
\label{sec:org5b8cae2}
On doit concevoir un circuit logique qui détermine le complément à deux
  d'une entrée \(a\) binaire (signée) de 4 bits notés
  \(a_3, a_2, a_1, a_0\). Il y aura donc 4 bits de sortie, \(s_3,
      s_2, s_1, s_0\). En considérant chacun des bits de sortie comme une
  fonction des quatre bits d'entrée, par ex. \(s_3 = f(a_3, a_2, a_1,
      a_0)\), donnez les tableaux de vérité pour \(s_3, s_2, s_1\), et \(s_0\).

\section*{Question}
\label{sec:org1d3f65b}
Complétez la figure ci-dessous (en ajoutant des connexions) afin de
  réaliser la fonction 
  $$
    S= a^\prime + b^\prime + c d
    $$
  \begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc2a}
\end{center}

\section*{Question}
\label{sec:org82fa9c3}
Complétez la figure ci-dessous (en ajoutant des connexions) afin de
  réaliser une fonction dont la sortie est 
\begin{itemize}
\item \(S=1\) lorsque l'entrée est \(\leq 3\) ou impaire
\item \(S=0\) dans les autres cas.
\end{itemize}
    L'entrée \((a_3,a_2,a_1, a_0)\) représente un nombre entier
   décimal codé en BCD. Les entrées \(\geq 9\) peuvent donner
   n'importe quelle sortie.
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc2b}
\end{center}

\section*{Question}
\label{sec:org7a67a4c}
Dessinez le circuit logique de la fonction \(S = a b + c^\prime +
    d^\prime\) en utilisant au plus quatre portes NAND.

\section*{Question}
\label{sec:org6cce0ac}
Simplifiez la fonction logique donnée par l'expression suivante:
  $$
    s = b (a^{\prime} c^{\prime} + a d + a c) + (b + c^{\prime}+
      d)^{\prime} + a^{\prime} b c^{\prime} d + a b c d
    $$ 
  au moyen d'un
  diagramme de Karnaugh. Identifiez sur le diagramme les regroupements
  essentiels, les regroupements absoluments inutiles et les
  regroupements pour lesquels on a le choix. Donnez deux solutions
  aussi simplifiées.

\section*{Question}
\label{sec:orgd74e1fc}
Considérez la fonction logique définie par l'expression 
  $$
    F = [ (A + B) C^{\prime} + (A+B)^{\prime} ] B^{\prime}
    $$

\begin{enumerate}
\item Dessinez le circuit logique correspondant.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NAND.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NOR.

\item Dessinez un circuit équivalent qui ne comporte que trois niveaux de
portes (incluant les inversions).
\end{enumerate}

\section*{Question}
\label{sec:orga1a42f4}
Simplifiez la fonction logique donnée par l'expression suivante:
  $$
    s = a b ( c^{\prime} d^{\prime} + c d) + c^{\prime}(a^{\prime}
      b^{\prime} + a^{\prime} b)
    $$
   au moyen d'un diagramme de Karnaugh. Donnez deux solutions aussi simplifiées.

\section*{Question}
\label{sec:orga0687a2}
Considérez la fonction logique définie par l'expression \(F = (AB + C)
      A^{\prime} + C + A^{\prime}\).

\begin{enumerate}
\item Dessinez le circuit logique correspondant.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NAND.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NOR.

\item Dessinez un circuit équivalent qui ne comporte que deux niveaux de
portes (excluant les inversions).
\end{enumerate}

\section*{Question}
\label{sec:org7a9d174}
Donnez le tableau  de vérité des deux fonctions qui, à partir d'une
  entrée binaire non-signée sur trois bits, donnent en sortie la
  représentation binaire non-signée sur deux bits du plus grand diviseur
  \(< 3\) de l'entrée, s'il y a lieu. Simplifiez les deux fonctions en
  tenant compte des cas facultatifs.

\section*{Question}
\label{sec:org95464c5}
Complétez la figure ci-dessous (en ajoutant des connexions) afin de
  réaliser une  fonction NAND à trois entrées \(S = (a b c)^\prime\).
  \begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc2c}
\end{center}

\section*{Question}
\label{sec:org758346f}
Dans une application numérique, on doit concevoir un circuit logique
qui permet de détecter les nombre composés, qui peuvent être
décomposés en facteurs (nombres qui ne sont pas premiers. Le circuit
doit donner une sortie 1 quand un nombre composé est présenté à
l'entrée; par exemple, le circuit doit donner 1 pour une entrée 4
(0100) et 0 pour une entrée 3 (0011). Les nombres 0 et 1 seront
considérés comme des cas facultatifs.

\begin{enumerate}
\item Donnez le tableau de vérité pour réaliser cette application pour
un mot d'entrée (non-signé) de quatre bits, \(a, b, c\) et \(d\).

\item Au moyen d'un diagramme de Karnaugh, trouvez une expression
logique simplifiée pour cette fonction logique et ne représentez
que les impliquants premiers retenus pour la solution.

\item Donnez le schéma du circuit logique qui implémente cette fonction
en somme de produit à l'aide de portes NON-ET (pas de restrictions
sur le nombre d'entrées).
\end{enumerate}

\chapter*{Série 3}
\label{sec:orge7142f8}
\section*{Question}
\label{sec:orga889268}
À l'aide d'un diagramme de Karnaugh, simplifiez 
  $$
    S = A B^\prime +
    B^\prime CD + A^\prime B + B^\prime D + A^\prime B^\prime D
    $$
  en produit de sommes.

\section*{Question}
\label{sec:orgc8505b3}
À l'aide d'un diagramme de Karnaugh, simplifiez 
  $$
    S = ( A^\prime +
    B^\prime + C + D)(A+B^\prime +C^\prime +D)(A^\prime +B^\prime
    +C+D^\prime )(A+B^\prime +C^\prime +D^\prime )(A+C^\prime +D)
    $$
  en tenant compte des cas facultatifs suivants: \(\sum(3,8,11,14)\).
\begin{enumerate}
\item Donnez une solution qui n'utilise pas l'entrée \(D\).
\item Donnez une solution qui n'utilise pas l'entrée \(B\).
\end{enumerate}

\section*{Question}
\label{sec:org89eafd6}
À l'aide de la méthode Quine-McCluskey, simplifiez l'expression
  logique suivante: 
  $$
    F= A^\prime BCDEF^\prime  + A^\prime BCDEF+ AB^\prime CDEF+ ABCDEF^\prime 
    $$
  Tenez compte des cas facultatifs suivants: 
  $$
    A^\prime BCD^\prime EF^\prime +
    ABCDE^\prime F^\prime + A^\prime BCDE^\prime F+ ABCDEF
    $$

\section*{Question}
\label{sec:org2fd5137}
Complétez la figure ci-dessous pour obtenir un multiplicateur dont
  la sortie (5 bits) est le produite de deux entrées (de 3 bits et 2
  bits, respectivement). Comme on peut voir sur la figure, on dispose
  de quatre additionneurs complets à 1 bit et de six portes ET. La
  multiplication sera $$(P_4, P_3, P_2, P_1, P_0)_2 = (y_2, y_1, y_0)_2
    \times (z_1, z_0)_2$$.
  \begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc3a}
\end{center}

\section*{Question}
\label{sec:orgc754d10}
Considérez la fonction logique \(F\) définie par le tableau de vérité suivant
\begin{center}
\begin{tabular}{rrrrlr}
\(A\) & \(B\) & \(C\) & \(D\) &  & \(F\)\\[0pt]
\hline
0 & 0 & 0 & 0 &  & 0\\[0pt]
0 & 0 & 0 & 1 &  & 1\\[0pt]
0 & 1 & 0 & 0 &  & 0\\[0pt]
0 & 1 & 0 & 1 &  & 0\\[0pt]
0 & 0 & 1 & 0 &  & 1\\[0pt]
0 & 0 & 1 & 1 &  & 0\\[0pt]
0 & 1 & 1 & 0 &  & 0\\[0pt]
0 & 1 & 1 & 1 &  & 1\\[0pt]
1 & 0 & 0 & 0 &  & 0\\[0pt]
1 & 0 & 0 & 1 &  & 1\\[0pt]
1 & 1 & 0 & 0 &  & 0\\[0pt]
1 & 1 & 0 & 1 &  & 1\\[0pt]
1 & 0 & 1 & 0 &  & 0\\[0pt]
1 & 0 & 1 & 1 &  & 0\\[0pt]
1 & 1 & 1 & 0 &  & 0\\[0pt]
1 & 1 & 1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{center}
Vous devez réaliser cette fonction au moyen d'un multiplexeur à huit
entrées sans utiliser la variable \(A\) dans les lignes de
sélection. Complétez le tableau de réalisation et la figure
ci-dessous.
\begin{center}
\begin{tabular}{lllllllll}
 & \(E_0\) & \(E_1\) & \(E_2\) & \(E_3\) & \(E_4\) & \(E_5\) & \(E_6\) & \(E_7\)\\[0pt]
\hline
\(A\) &  &  &  &  &  &  &  & \\[0pt]
\(A^\prime\) &  &  &  &  &  &  &  & \\[0pt]
\end{tabular}
\end{center}
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc3b}
\end{center}

\section*{Question}
\label{sec:orge4317e6}
Simplifiez la fonction logique à six entrées
  $$
    S = F(A,B,C,D,E,F)
    $$
  représentée par la liste de minterms suivants

010000, 101000, 110100, 110101, 110110, 111100

en tenant compte des cas facultatifs représentés par les minterms
suivants

000000, 001100, 000111, 101001, 110111

par la méthode de Quine-McCluskey. Vous devez donner le détail de
toutes les étapes, remplir les tableaux de couverture initial et
réduit, identifier les impliquants premiers essentiels (i.p.e.), les
impliquants premiers absolument inessentiels (i.p.a.i.) et les
impliquants premiers inessentiels tout court (i.p.i.). Donnez la
solution sous la forme d'une expression en \(A,B,C,D,E,F\).

\section*{Question}
\label{sec:orgf6ac9a4}
Réalisez les fonctions logiques suivantes au moyen d'un multiplexeur
  quatre-vers-un.

\begin{enumerate}
\item $$f_1(a,b,c) = \sum m(2, 4, 5, 7)$$

\item $$f_2(a,b,c) = \prod M(0, 6, 7)$$
\end{enumerate}

\section*{Question}
\label{sec:org7518213}
Identifiez la fonction réalisée par le circuit ci-dessous, en donnant
  la liste des minterms en fonction des entrées \(a, b, c\) et \(d\).
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc3c}
\end{center}

\section*{Question}
\label{sec:orge9072f5}
Un circuit combinatoire est défini par les trois fonctions logiques
  suivantes. Dessinez un circuit réalisant ces trois fonctions en
  utilisant un décodeur constitué de portes NAND (vous devez dessiner
  le schéma du décodeur), et des portes NAND et ET
  externes.
  $$
     F_1  = x y^{\prime} + x^{\prime}y
    z^{\prime} 
    $$
  $$
    F_2  =  (x + y^{\prime})z 
    $$
  $$ F_3  =  (x^{\prime}
    y + x y^{\prime} z)^{\prime}
    $$

\section*{Question}
\label{sec:org4e6e33a}
Simplifiez la fonction donnée par l'expression suivante
  $$
    a^{\prime} b^{\prime} c d + a b c d + a b^{\prime} c^{\prime} d +
	a b c d^{\prime}
    $$
  en considérant les cas facultatifs suivants
  $$
    a b c^{\prime} + a^{\prime} b c^{\prime} d^{\prime} + a b^{\prime}
	c d^{\prime}
    $$
  par la méthode de Quine-McCluskey. Vous devez
  donner le détail de toutes les étapes, identifier à la fin les
  impliquants premiers essentiels (i.p.e.), les impliquants premiers
  absolument inessentiels (i.p.a.i.) et les impliquants premiers
  inessentiels tout court (i.p.i.). et donner la solution finale avec
  les variables.

\section*{Question}
\label{sec:org2e67a52}
Concevez un circuit qui permet de comparer deux mots de 3 bits et qui
  donne 1 lorsqu'ils sont égaux et 0 sinon. Vous devez utiliser des
  portes XOR et d'autres portes.

\section*{Question}
\label{sec:orgb594924}
La fonction logique à quatre entrées \(S = F(A,B,C, D)\) donnée par son 
  tableau de vérité:
\begin{center}
\begin{tabular}{rrrrlr}
\(A\) & \(B\) & \(C\) & \(D\) &  & \(S\)\\[0pt]
\hline
0 & 0 & 0 & 0 &  & 0\\[0pt]
0 & 0 & 0 & 1 &  & 1\\[0pt]
0 & 1 & 0 & 0 &  & 0\\[0pt]
0 & 1 & 0 & 1 &  & 1\\[0pt]
0 & 0 & 1 & 0 &  & X\\[0pt]
0 & 0 & 1 & 1 &  & 0\\[0pt]
0 & 1 & 1 & 0 &  & 0\\[0pt]
0 & 1 & 1 & 1 &  & 1\\[0pt]
1 & 0 & 0 & 0 &  & X\\[0pt]
1 & 0 & 0 & 1 &  & 1\\[0pt]
1 & 1 & 0 & 0 &  & 0\\[0pt]
1 & 1 & 0 & 1 &  & 0\\[0pt]
1 & 0 & 1 & 0 &  & 0\\[0pt]
1 & 0 & 1 & 1 &  & 1\\[0pt]
1 & 1 & 1 & 0 &  & X\\[0pt]
1 & 1 & 1 & 1 &  & 1\\[0pt]
\end{tabular}
\end{center}
doit être implémentée par un circuit logique.

\begin{enumerate}
\item Simplifiez la description de cette fonction en utilisant un diagramme de Karnaugh.

\item Trouvez le tableau de couverture pour la fonction et réduisez-le en tableau réduit.

\item Identifiez les impliquants premiers essentiels (i.p.e.), les
impliquants premiers absolument inessentiels (i.p.a.i.) et les
impliquants premiers inessentiels tout court (i.p.i.).

\item Dessinez le circuit logique simplifié, réalisé en n'utilisant que des portes NAND.
\end{enumerate}

\section*{Question}
\label{sec:orgab0dd56}
Un circuit combinatoire est défini par les trois fonctions logiques
  suivantes. Dessinez un circuit réalisant ces trois fonctions en
  utilisant un décodeur et des portes externes.
  $$
    F_1  = x^{\prime} y^{\prime} z^{\prime} + xz 
    $$
  $$
    F_2  = x y z^{\prime} + x^{\prime} y 
    $$
  $$
    F_3  = x^{\prime} y^{\prime} z + x y
    $$

\section*{Question}
\label{sec:org33d8709}
 Identifiez la fonction logique \(F(A,B,C,D)\) définie par le circuit
   logique suivant:
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc3d}
\end{center}
\begin{enumerate}
\item Donnez son tableau de vérité.

\item Donnez la forme canonique somme de produits de cette fonction.
\end{enumerate}

\section*{Question}
\label{sec:orgaf2cfb1}
Considérez le tableau de couverture suivant:

\begin{center}
\begin{tabular}{lrrrrrrr}
 & 0101 & 0110 & 0000 & 1100 & 1101 & 1011 & 0111\\[0pt]
\hline
−10− &  &  &  &  &  &  & \\[0pt]
110− &  &  &  &  &  &  & \\[0pt]
1011 &  &  &  &  &  &  & \\[0pt]
−00− &  &  &  &  &  &  & \\[0pt]
01−− &  &  &  &  &  &  & \\[0pt]
−111 &  &  &  &  &  &  & \\[0pt]
\end{tabular}
\end{center}

\begin{enumerate}
\item Complétez le tableau en mettant les '+' dans les cases
appropriées.

\item Identifiez les i.p.e. et les i.p.a.i.

\item Donnez les cas facultatifs qui ont été utilisés pour obtenir les
i.p.

\item Donnez le tableau réduit correspondant.

\item Donnez un exemple de ligne qui en domine une autre.

\item Donnez un exemple de colonne qui en domine une autre.

\item Donnez une forme canonique de la fonction.

\item Donnez l'expression simplifiée de la fonction \(F(u,v,w,x)\).
\end{enumerate}

\section*{Question}
\label{sec:org2824dcb}
Trouvez l'expression minimale pour les deux fonctions suivantes,
   sachant qu'elles doivent être implémentées dans un même
   circuit. Utilisez la méthode Quine-McCluskey.
   $$
     F_1(A, B, C, D)
     =\sum(2,5,6,7,10,11,14,15)
     $$
   $$
     F_2 = A B C D + A^\prime B C D +
     A^\prime B^\prime C D + A B^\prime C + ABC
     $$

\section*{Question}
\label{sec:orgfdb91fb}
La fonction logique à trois entrées \(S = F(A,B,C)\) représentée par le
  tableau de vérité:

\begin{center}
\begin{tabular}{rrrr}
A & B & C & S\\[0pt]
\hline
0 & 0 & 0 & 1\\[0pt]
0 & 0 & 1 & 1\\[0pt]
0 & 1 & 0 & 0\\[0pt]
0 & 1 & 1 & 1\\[0pt]
1 & 0 & 0 & 0\\[0pt]
1 & 0 & 1 & 0\\[0pt]
1 & 1 & 0 & 1\\[0pt]
1 & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{center}

doit être implémentée par un circuit logique.

\begin{enumerate}
\item Donnez l'expression de cette fonction:

\begin{itemize}
\item Selon la première forme canonique ( \(\sum m_i\) )

\item Selon la deuxième forme canonique ( \(\prod M_i\) )
\end{itemize}

\item Trouvez une expression simplifié pour cette fonction en utilisant
un diagramme de Karnaugh en format horizontal.

\item Donnez l'expression du \textbf{complément} de cette fonction:

\begin{itemize}
\item Selon la première forme canonique ( \(\sum m_i\) )

\item En complémentant votre expression simplifiée au moyen du
théorême de DeMorgan.
\end{itemize}

\item Dessinez le circuit logique à partir de l'expression simplifiée
trouvée.
\end{enumerate}

\section*{Question}
\label{sec:org5bde599}
Simplifiez la fonction logique donnée par la forme canonique
  suivante:
  $$
    m_0 + m_2 + m_4 + m_5 + m_8 + m_A + m_B + m_E
    $$
  au
  moyen d'un diagramme de Karnaugh (la numérotation des termes est en
  hexadécimal). Identifiez sur le diagramme les regroupements
  essentiels, les regroupements absoluments inutiles et les
  regroupements pour lesquels on a le choix. Donnez deux solutions
  aussi simplifiées.

\section*{Question}
\label{sec:org3903003}
Considérez la fonction logique définie par l'expression
  $$
    F =
      (A + B) A^{\prime} C + C^{\prime}(A+B^{\prime}) + A^{\prime}B
      C^{\prime}
    $$

\begin{enumerate}
\item Dessinez le circuit logique correspondant.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NAND.

\item Dessinez un circuit équivalent qui n'utilise que des portes
NOR.

\item Dessinez un circuit équivalent qui ne comporte que 3 niveaux de
portes (incluant les inversions).
\end{enumerate}

\section*{Question}
\label{sec:org917d951}
Donnez le tableau de vérité pour les fonctions logiques correspondant
  à:

\begin{enumerate}
\item $$f(A, B) = A + B^{\prime}$$

\item $$f(a, b, c) = a(b+c^{\prime})(b^{\prime}+c)$$
\end{enumerate}

\section*{Question}
\label{sec:org6409cd4}
Considérez la fonction logique donnée par l'expression suivante:

\begin{multline*}
F = A^{\prime} B^{\prime} C^{\prime} D^{\prime} E^{\prime} + {A} B^{\prime} C^{\prime} D^{\prime} E^{\prime} + A^{\prime} B^{\prime} {C} D^{\prime} E^{\prime} + A^{\prime} {B} {C} {D} E^{\prime} \\ + {A} {B} C^{\prime} D^{\prime} {E} + {A} B^{\prime} C^{\prime} D^{\prime} {E} + {A} B^{\prime} D^{\prime} E^{\prime} \\ + {A} B^{\prime} {C} {D} {E} + {A} B^{\prime}  {C} D^{\prime} {E}
\end{multline*}

Les cas suivants sont facultatifs:
\begin{displaymath}
A^{\prime} B^{\prime} C^{\prime} D^{\prime} {E} + {A} {B} C^{\prime} {D} {E} +  A^{\prime}B^{\prime} {C} D^{\prime} {E} + {A} {B} {C} D^{\prime} {E}
\end{displaymath}

\begin{enumerate}
\item Simplifiez cette expression logique par la méthode de
Quine-McCluskey, en tenant compte des cas facultatifs. Identifiez
clairement les implicants essentiels et non-essentiels.

\item Dessinez un réseau logique qui réalise votre expression logique
simplifiée en n'utilisant que des portes NAND.
\end{enumerate}

\section*{Question}
\label{sec:orgff5f2a7}
Vous devez concevoir un circuit logique combinatoire qui calcule la
valeur absolue d'un nombre de 4 bits signé en complément à deux. Les
seules valeurs d'entrée possibles sont donc de -7 à 7 inclusivement,
les autres nombres seront considérées comme des cas facultatifs. Vous
disposez de composants programmables pour réaliser cette fonction.

\begin{enumerate}
\item Réalisez votre circuit logique combinatoire en utilisant un PROM à
quatre entrées et deux sorties tel qu'illustré.
Vous devez mettre des croix aux endroits où vous voulez que les
connections soient effectuées (dans la section programmable).
\end{enumerate}
\begin{center}
\includesvg[scale=0.45]{Modeles_exercices/prom4}
\end{center}

\begin{enumerate}
\item Réalisez votre circuit logique combinatoire en utilisant le PAL à
quatre entrées et trois sorties tel qu'illustré.
Vous devez mettre des croix aux endroits où vous voulez que les
connections soient effectuées (dans la section programmable).
\end{enumerate}
\begin{center}
\includesvg[scale=0.45]{Modeles_exercices/pal3}
\end{center}

\section*{Question}
\label{sec:org9378cc1}
Considérez le circuit logique ci-dessous. Le signal \(A\) passe de 0 à 1
l'instant 15 ns; le signal \(B\) passe de 1 à 0 à l'instant 15 ns; le
signal \(C\) passe de 1 à 0 à l'instant 60 ns.
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc3e}
\end{center}

\begin{enumerate}
\item Complétez un chronogramme qui montre les traces pour chacun des
signaux d'entrée \(A, B, C\) et de sortie \(T, U, V, X, Y, Z_1,
       Z_2, Z_3, F\), en supposant un temps de propagation de 10 ns
pour toutes les portes. Identifiez clairement sur le
chronogramme les temps de propagation et les éventuels problèmes
(glitchs) occasionnés par les délais.

\item Identifiez la fonction logique réalisée par ce circuit logique.

\item Déterminer le délai de propagation (des entrées à la sortie)
maximal pour ce circuit, et précisez le chemin critique.

\item Si ce circuit doit être utilisé à répétition, de façon périodique,
quelle est la plus courte période qu'on puisse utiliser tout en
étant sûr que le circuit fonctionne correctement.

\item On désire remplacer ce circuit par un circuit à trois niveaux
logiques. Donnez le schéma d'un circuit en forme somme de produit
qui remplit la même fonction.

\item Donnez le délai de propagation maximal pour le nouveau circuit
somme de produit.
\end{enumerate}

\chapter*{Série 4}
\label{sec:orgd10cc80}
\section*{Question}
\label{sec:orgb84147c}
Construisez un décodeur 5-vers-32 en utilisant quatre décodeurs
  3-vers-8 avec entrée \emph{enable}.

\section*{Question}
\label{sec:orge2469f5}
Vous devez concevoir un encodeur à priorité à quatre
  entrées. L'entrée \(D_0\) doit avoir la plus grande priorité et
  l'entrée \(D_3\) doit avoir la plus faible priorité, avec la
  priorité des autres entrées qui suivent le même ordre. Les sorties
  seront \(s_1, s_0\) et \(v\) qui indique la validité des sorties:
  \(v=0\) si toutes les entrées sont à 0; \(v=1\) si au moins une
  entrée est 1.

\section*{Question}
\label{sec:org7ae083f}
Un circuit séquentiel à deux bascules D, \(A\) et \(B\), comporte
  deux entrées \(x\) et \(y\) et une sortie \(z\). Les équations de
  prochain état sont:

$$A_{n+1} = x^\prime y + x A$$

$$B_{n+1} = x^\prime B + x A$$

L'équation de sortie est 

$$z=B$$

\begin{enumerate}
\item Dessinez le schéma logique du circuit

\item Déterminez le tableau d'états

\item Dessinez le diagramme d'état
\end{enumerate}

\section*{Question}
\label{sec:org23f310c}
 Considérez le circuit logique suivant:
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc4a}
\end{center}

\begin{enumerate}
\item Quelle est la fonction combinatoire réalisée par la section
logique combinatoire, c'est-à-dire, quelle est la fonction \(S =
         f(A,B)\) ?

\item Complétez le diagramme temporel de la figure, en supposant un
temps de propagation \textbf{maximum} de 10 ns pour les portes NOR et OU,
et de 40 ns pour les bascules.

\item Si les temps de maintien \(t_{h}\) et de mise en place \(t_{su}\)
sont de 5 ns pour toutes les bascules, quelle est la fréquence
maximale d'horloge utilisable pour que le circuit fonctionne
convenablement? Utilisez un diagramme temporel pour évaluer la
période minimum.
\end{enumerate}

\section*{Question}
\label{sec:org1263e88}
 Analysez le circuit logique suivant:
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc4b}
\end{center}

\begin{enumerate}
\item Analysez le comportement du circuit, en supposant qu'au départ les
entrées sont \(A=0\) et \(B=0\) et la sortie \(S=0\). Vous devez
supposer des changements des valeurs d'entrées et décrire les
changements des sorties, en tenant compte de la mémoire du
circuit.

\item Identifiez la fonction des entrées \(A\) et \(B\).

\item Identifiez la fonction du circuit.
\end{enumerate}

\section*{Question}
\label{sec:org6895df3}
Considérez circuit séquentiel décrit par le diagramme d'état suivant:
\begin{center}
\includesvg[scale=0.45]{Modeles_exercices/ex_bloc5b}
\end{center}
\begin{enumerate}
\item En utilisant l'assignation d'états \(a = 00, b = 01, c = 10, d
         = 11\), construisez le tableau d'état pour ce circuit séquentiel.

\item Concevez le circuit en utilisant des portes standards et des
bascules D.
\end{enumerate}

\section*{Question}
\label{sec:orgf39f9ea}
Vous devez concevoir un circuit logique séquentiel à une entrée et
  une sortie qui identifie les deux séquences d'entrée 0110 et 11111
  appliquées immédiatement après une remise à zéro asynchrone du
  circuit. Donnez le diagramme d'état simplifié pour ce circuit.

\section*{Question}
\label{sec:org8474253}
Vous devez concevoir un circuit logique séquentiel à une entrée et
 une sortie qui identifie les deux séquences d'entrée 0110
 et 11111. Les séquences d'entrée doivent être identifiées à
 n'importe quel moment où elles apparaissent en entrée.

\section*{Question}
\label{sec:orgc3a5f09}
Déterminez le diagramme d'état pour un circuit séquentiel synchrone
  avec une entrée \(x\) et une sortie \(z\) qui est utilisé pour
  reconnaître la séquence d'entrée 101. La sortie doit donc être \(z=1\)
  lorsque le dernier 1 de la séquence 101 est identifié. \(z\) est
  ensuite remis à zéro au prochain coup d'horloge. Deux séquences 101
  peuvent se chevaucher. On a par exemple,
  $$
    x  =  010101101
    $$
  $$ z = 000101001
    $$

\section*{Question}
\label{sec:orgbdf4220}
Déterminez le diagramme d'état pour un circuit séquentiel synchrone
  avec une entrée \(x\) et une sortie \(z\) qui est utilisé pour
  reconnaître la séquence d'entrée 101. La sortie doit donc être \(z=1\)
  lorsque le dernier 1 de la séquence 101 est identifié. \(z\) est
  ensuite remis à zéro au prochain coup d'horloge. Les chevauchements de 101 ne sont pas 
  permis. Par exemple,
  $$
    x = 010101101
    $$
  $$
    z = 000100001
    $$

\section*{Question}
\label{sec:org12e68ae}
Concevez le circuit séquentiel synchrone décrit par le tableau
  d'état ci-dessous. Vous devez considérer des bascules JK et D et
  choisir la solution la plus simple. Présentez clairement toutes les
  étapes, jusqu'au schéma du circuit correspondant.
\begin{center}
\begin{tabular}{rrrr}
État courant & Entrée & Prochain & Sortie\\[0pt]
\hline
00 & 0 & 01 & 0\\[0pt]
00 & 1 & 11 & 0\\[0pt]
01 & 0 & 10 & 0\\[0pt]
01 & 1 & 00 & 1\\[0pt]
11 & 0 & 00 & 1\\[0pt]
11 & 1 & 10 & 0\\[0pt]
10 & 0 & 10 & 1\\[0pt]
10 & 1 & 01 & 1\\[0pt]
\end{tabular}
\end{center}

\section*{Question}
\label{sec:org5efa832}
Les deux bascules du circuit suivant sont activées par les
   transitions montantes du signal présent à leur entrée
   d'horloge. 
   \begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc4c}
\end{center}

Tracez le chronogramme pour \(X, X^\prime, Y, S\)

\section*{Question}
\label{sec:orgb7b1cf9}
Vous devez analyser le circuit séquentiel suivant:
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc4d}
\end{center}

\begin{enumerate}
\item Donnez les équations pour le décodeur de prochain état.

\item Donnez le tableau d'activation avec état présent, entrée, entrées
des bascules, prochain état, sortie.

\item Donnez le diagramme d'état correspondant.

\item tracez le chronogramme de fonctionnement, en
faisant abstraction des délais de propagation.

\item En sachant que la bascule a les caractéristiques suivantes:

\begin{itemize}
\item temps de pré-positionnement minimum: 11 ns

\item temps de maintien minimum: 9 ns

\item temps de propagation maximum: de Horloge à \(Q\) ou
\(Q^{\prime}\): \(t_{pLH}\) = 15 ns, \(t_{pHL}\) = 13 ns.
\end{itemize}

et en suppoosant un délai de propagation de 15 ns pour la porte
XOR, déterminez la période minimale et la fréquence
maximale qu'on puisse utiliser tout en étant assuré que le circuit
fonctionne correctement. Donnez les détails de votre raisonnement.
\end{enumerate}

\section*{Question}
\label{sec:orgec35f9b}
Vous devez concevoir un circuit logique utilisé dans un système
permettant de trier des données. Le circuit reçoit deux nombres
non-signés de 4 bits, multiplexés en série sur une même entrée. Par
exemple, si les entrées sont 1010 et 1110, le circuit recevra
\begin{enumerate}
\item Le circuit doit acheminer le plus grand des deux nombres à
\end{enumerate}
une sortie (parallèle) appelée PG et le plus petit à une sortie
(parallèle) appelée PP. Vous devez réaliser votre circuit en utilisant
les éléments suivants:

\begin{itemize}
\item démultiplexeur un-vers-deux

\item multiplexeur 4 bits deux-vers-un (il s'agit de quatre
multiplexeurs deux-vers-un à un bit avec le même signal de
commande, et qui traitent ainsi en parallèle des mots de quatre bits)

\item registre à décalage entrée série/sortie parallèle

\item comparateur de magnitude: deux entrées parallèles de 4 bits: \(A\) et
\(B\), trois sorties: \(A>B\), \(A=B\), \(A<B\)

\item registre entrée parallèle/sortie parallèle
\end{itemize}

Donnez un schéma-bloc de votre circuit en indiquant seulement les
blocs qui traitent les données (pas les blocs qui serviront à contrôler
le circuit).

\section*{Question}
\label{sec:orgccddb7e}
On doit concevoir un système séquentiel avec une entrée \(E\) et une
sortie, et qui génère les séquences de sortie suivantes:

\begin{itemize}
\item si \(E=0\), séquence de sortie = 1100, périodique

\item si \(E=1\), séquence de sortie = 1011, périodique
\end{itemize}

On envisage deux versions du système:

\begin{description}
\item[{version 1}] si  \(E\) change, la séquence de sortie suit le
changement au vol.

\item[{version 2}] si \(E\) change, la séquence de sortie recommence à
partir du début.
\end{description}

Par exemple,
\begin{center}
\begin{tabular}{lrrrrrrrrrrrrrr}
Entrée & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 0 & 0\\[0pt]
\hline
Sortie version 1 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 1 & 1 & 1\\[0pt]
Sortie version 2 & 1 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 1 & 1\\[0pt]
\end{tabular}
\end{center}

Donnez un diagramme d'état pour chacune des deux versions.

\section*{Question}
\label{sec:orgf847ddf}
Considérez le tableau d'état suivant:
\begin{center}
\begin{tabular}{lrlr}
État présent & Entrée \(A\) & État suivant & Sortie \(S\)\\[0pt]
\hline
a & 0 & c & 1\\[0pt]
a & 1 & a & 1\\[0pt]
b & 0 & e & 0\\[0pt]
b & 1 & f & 1\\[0pt]
c & 0 & b & 1\\[0pt]
c & 1 & d & 0\\[0pt]
d & 0 & a & 0\\[0pt]
d & 1 & b & 1\\[0pt]
e & 0 & e & 0\\[0pt]
e & 1 & f & 1\\[0pt]
f & 0 & c & 1\\[0pt]
f & 1 & f & 1\\[0pt]
\end{tabular}
\end{center}
correspondant à un circuit séquentiel synchrone.

\begin{enumerate}
\item Simplifiez ce tableau d'état en identifiant les états
équivalents, en utilisant la méthode du tableau d'implication.

\item Donnez le diagramme d'état simplifié correspondant au tableau
d'état simplifié. Nommez les états simplifiés qui restent a,
b, c, \dots{}

\item Assignez des codes aux états, en commençant avec la
représentation binaire de 0 pour a, de 1 pour b, etc.

\item Donnez les diagrammes de Karnaugh pour le décodeur de prochain
état en supposant des bascules JK, et les fonctions simplifiées
correspondantes.

\item Donnez le diagramme de Karnaugh pour le décodeur de sortie.

\item Dessinez le schéma du circuit séquentiel obtenu.
\end{enumerate}

\section*{Question}
\label{sec:orgc8c7646}
Considérez le circuit séquentiel synchrone ci-dessous.
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/exbloc4e}
\end{center}

Déterminez la vitesse d'horloge maximale en considérant les
caractéristiques suivantes:

\begin{itemize}
\item Portes: temps de propagation maximum: 10 ns.

\item Bascules: temps de mise en place minimum: 12 ns.

\item Bascules: temps de maintien minimum: 15 ns.

\item Bascules: temps de propagation maximum: de H à \(Q\) ou
\(Q^{\prime}\): \(t_{pLH}\) = 25 ns, \(t_{pHL}\) = 20 ns.
\end{itemize}

\chapter*{Série 5}
\label{sec:org05446d1}
\section*{Question}
\label{sec:org8f3d412}
Faire le diagramme d'état d'un circuit séquentiel synchrone qui génère
à sa sortie un 1 lorsqu'il détecte à son entrée la séquence 0110 ou la
séquence 0101.

\section*{Question}
\label{sec:org7317371}
Un circuit séquentiel synchrone est construit à partir de trois
   bascules, \(A\), \(B\), et \(C\). Il comporte une entrée \(x\) et
   une sortie \(y\). Son diagramme d'état est donné ci-dessous. 
\begin{center}
\includesvg[width=.9\linewidth]{Modeles_exercices/ex_bloc5}
\end{center}

Vous devez concevoir ce circuit en considérant les états inutilisés
comme des cas facultatifs. Le circuit final doit être analysé pour
déterminer si, à partir des états inutilisés, le système revient vers
son fonctionnement normal.
\begin{enumerate}
\item Conception avec des bascules D
\item Conception avec des bascules JK
\end{enumerate}

\section*{Question}
\label{sec:org2acf791}
Faire le diagramme d'état d'un compteur synchrone qui produit les
  séquences d'états suivants, selon la valeur de l'entrée \(x\)

\begin{itemize}
\item \(x=0\), séquence: 0, 6, 2, 1, 4, 0, 6, 2, 1, 4, \dots{}
\item \(x=1\), séquence: 0, 6, 5, 7, 2, 1, 0, 6, 5, 7, 2, 1, \dots{}
\end{itemize}
\end{document}